<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rtype Engine: asio::experimental Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Rtype Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasio.html">asio</a></li><li class="navelem"><a class="el" href="namespaceasio_1_1experimental.html">experimental</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">asio::experimental Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceasio_1_1experimental_1_1awaitable__operators" id="r_namespaceasio_1_1experimental_1_1awaitable__operators"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental_1_1awaitable__operators.html">awaitable_operators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1experimental_1_1channel__errc" id="r_namespaceasio_1_1experimental_1_1channel__errc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental_1_1channel__errc.html">channel_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1experimental_1_1detail" id="r_namespaceasio_1_1experimental_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1experimental_1_1error" id="r_namespaceasio_1_1experimental_1_1error"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1as__single__t.html">as_single_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1basic__channel.html">basic_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A channel for messages.  <a href="classasio_1_1experimental_1_1basic__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1basic__concurrent__channel.html">basic_concurrent_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A channel for messages.  <a href="classasio_1_1experimental_1_1basic__concurrent__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits.html">channel_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits used for customising channel behaviour.  <a href="structasio_1_1experimental_1_1channel__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07asio_1_1error__code_08_4.html">channel_traits&lt; R(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07asio_1_1error__code_00_01Args_8_8_8_08_00_01Signatures_8_8_8_01_4.html">channel_traits&lt; R(asio::error_code, Args...), Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07std_1_1exception__ptr_08_4.html">channel_traits&lt; R(std::exception_ptr)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07std_1_1exception__ptr_00_01Args_8_8_8_08_00_01Signatures_8_8_8_01_4.html">channel_traits&lt; R(std::exception_ptr, Args...), Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07T_08_4.html">channel_traits&lt; R(T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main type of a resumable coroutine.  <a href="structasio_1_1experimental_1_1coro.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1coro__traits.html">coro_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1coro__traits_3_01T_07U_08_01noexcept_00_01Return_00_01Executor_01_4.html">coro_traits&lt; T(U) noexcept, Return, Executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1coro__traits_3_01T_07U_08_00_01Return_00_01Executor_01_4.html">coro_traits&lt; T(U), Return, Executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1is__promise.html">is_promise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1is__promise_3_01promise_3_01Ts_8_8_8_01_4_01_4.html">is_promise&lt; promise&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1parallel__group.html">parallel_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A group of asynchronous operations that may be launched in parallel.  <a href="classasio_1_1experimental_1_1parallel__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise.html">promise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise_3_01void_07Ts_8_8_8_08_00_01Executor_00_01Allocator_01_4.html">promise&lt; void(Ts...), Executor, Allocator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise__value__type.html">promise_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise__value__type_3_01T_01_4.html">promise_value_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise__value__type_3_4.html">promise_value_type&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1use__coro__t.html">use_coro_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A completion_token that creates another coro for the task completion.  <a href="structasio_1_1experimental_1_1use__coro__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1use__promise__t.html">use_promise_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1wait__for__all.html">wait_for_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all operations to complete.  <a href="classasio_1_1experimental_1_1wait__for__all.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1wait__for__one.html">wait_for_one</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until an operation completes, then cancel the others.  <a href="classasio_1_1experimental_1_1wait__for__one.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1wait__for__one__error.html">wait_for_one_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until an operation completes with an error, then cancel the others.  <a href="classasio_1_1experimental_1_1wait__for__one__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1wait__for__one__success.html">wait_for_one_success</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until an operation completes without an error, then cancel the others.  <a href="classasio_1_1experimental_1_1wait__for__one__success.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab9bc95bb81ce2f161c5fade03ea92947" id="r_ab9bc95bb81ce2f161c5fade03ea92947"><td class="memTemplParams" colspan="2">template&lt;typename ExecutorOrSignature , typename... Signatures&gt; </td></tr>
<tr class="memitem:ab9bc95bb81ce2f161c5fade03ea92947"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9bc95bb81ce2f161c5fade03ea92947">channel</a></td></tr>
<tr class="memdesc:ab9bc95bb81ce2f161c5fade03ea92947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type alias for common use of channel.  <br /></td></tr>
<tr class="separator:ab9bc95bb81ce2f161c5fade03ea92947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fefafb3f653f41e014f2139169119a1" id="r_a7fefafb3f653f41e014f2139169119a1"><td class="memTemplParams" colspan="2">template&lt;typename ExecutorOrSignature , typename... Signatures&gt; </td></tr>
<tr class="memitem:a7fefafb3f653f41e014f2139169119a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7fefafb3f653f41e014f2139169119a1">concurrent_channel</a></td></tr>
<tr class="memdesc:a7fefafb3f653f41e014f2139169119a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type alias for common use of channel.  <br /></td></tr>
<tr class="separator:a7fefafb3f653f41e014f2139169119a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8700ef24cc17fcf8f3ae9fb35b1539e3" id="r_a8700ef24cc17fcf8f3ae9fb35b1539e3"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> , typename Executor  = asio::any_io_executor, typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a8700ef24cc17fcf8f3ae9fb35b1539e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8700ef24cc17fcf8f3ae9fb35b1539e3">generator</a> = <a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt;<a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor, Allocator&gt;</td></tr>
<tr class="memdesc:a8700ef24cc17fcf8f3ae9fb35b1539e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generator is a coro that returns void and yields value.  <br /></td></tr>
<tr class="separator:a8700ef24cc17fcf8f3ae9fb35b1539e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1412f0b02504799c6e210a4ccb5398e6" id="r_a1412f0b02504799c6e210a4ccb5398e6"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> , typename Executor  = asio::any_io_executor, typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a1412f0b02504799c6e210a4ccb5398e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1412f0b02504799c6e210a4ccb5398e6">task</a> = <a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt;<a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor, Allocator&gt;</td></tr>
<tr class="memdesc:a1412f0b02504799c6e210a4ccb5398e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task is a coro that does not yield values.  <br /></td></tr>
<tr class="separator:a1412f0b02504799c6e210a4ccb5398e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a848ebb188067fe5b7278a591bbc0e92f" id="r_a848ebb188067fe5b7278a591bbc0e92f"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a848ebb188067fe5b7278a591bbc0e92f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> constexpr <a class="el" href="classasio_1_1experimental_1_1as__single__t.html">as_single_t</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a848ebb188067fe5b7278a591bbc0e92f">as_single</a> (CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:a848ebb188067fe5b7278a591bbc0e92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac83b8b49276d49470c7a45cdb5eb2bf" id="r_aac83b8b49276d49470c7a45cdb5eb2bf"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> , typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:aac83b8b49276d49470c7a45cdb5eb2bf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac83b8b49276d49470c7a45cdb5eb2bf">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr, <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>)) <a class="el" href="#af580e11a7608adfd35588421fbc592b3">co_spawn</a>(<a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a></td></tr>
<tr class="memdesc:aac83b8b49276d49470c7a45cdb5eb2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a resumable coroutine.  <br /></td></tr>
<tr class="separator:aac83b8b49276d49470c7a45cdb5eb2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1558c3d3b0c140ab3bc99d78d8372ed8" id="r_a1558c3d3b0c140ab3bc99d78d8372ed8"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1558c3d3b0c140ab3bc99d78d8372ed8">async_compose&lt; CompletionToken, void(std::exception_ptr, T)&gt;</a> (<a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;{std::move(<a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>)}, <a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>, exec)</td></tr>
<tr class="separator:a1558c3d3b0c140ab3bc99d78d8372ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dd4cdae510a6353182475976cb8594" id="r_ac7dd4cdae510a6353182475976cb8594"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7dd4cdae510a6353182475976cb8594">async_compose&lt; CompletionToken, void(std::exception_ptr, T)&gt;</a> (<a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;{std::move(<a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>)}, <a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>, exec)</td></tr>
<tr class="separator:ac7dd4cdae510a6353182475976cb8594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af580e11a7608adfd35588421fbc592b3" id="r_af580e11a7608adfd35588421fbc592b3"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> , typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:af580e11a7608adfd35588421fbc592b3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af580e11a7608adfd35588421fbc592b3">co_spawn</a> (<a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>() noexcept, <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt; <a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>, CompletionToken &amp;&amp;<a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</td></tr>
<tr class="memdesc:af580e11a7608adfd35588421fbc592b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a resumable coroutine.  <br /></td></tr>
<tr class="separator:af580e11a7608adfd35588421fbc592b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88bbac9488527afe4a8e0055fcbf6d3" id="r_ad88bbac9488527afe4a8e0055fcbf6d3"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:ad88bbac9488527afe4a8e0055fcbf6d3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad88bbac9488527afe4a8e0055fcbf6d3">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr)) <a class="el" href="#af580e11a7608adfd35588421fbc592b3">co_spawn</a>(<a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a></td></tr>
<tr class="memdesc:ad88bbac9488527afe4a8e0055fcbf6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a resumable coroutine.  <br /></td></tr>
<tr class="separator:ad88bbac9488527afe4a8e0055fcbf6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e8c93a15f335b266e14235f20291b" id="r_a0b3e8c93a15f335b266e14235f20291b"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b3e8c93a15f335b266e14235f20291b">async_compose&lt; CompletionToken, void(std::exception_ptr)&gt;</a> (<a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;{std::move(<a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>)}, <a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>, exec)</td></tr>
<tr class="separator:a0b3e8c93a15f335b266e14235f20291b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89249a63579083cae4bab8a2513e4a49" id="r_a89249a63579083cae4bab8a2513e4a49"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89249a63579083cae4bab8a2513e4a49">async_compose&lt; CompletionToken, void(std::exception_ptr)&gt;</a> (<a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;{std::move(<a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>)}, <a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>, exec)</td></tr>
<tr class="separator:a89249a63579083cae4bab8a2513e4a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157a82d35a5d4826c5151c7e8f146607" id="r_a157a82d35a5d4826c5151c7e8f146607"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a157a82d35a5d4826c5151c7e8f146607"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a157a82d35a5d4826c5151c7e8f146607">co_spawn</a> (<a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>() noexcept, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt; <a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>, CompletionToken &amp;&amp;<a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</td></tr>
<tr class="memdesc:a157a82d35a5d4826c5151c7e8f146607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a resumable coroutine.  <br /></td></tr>
<tr class="separator:a157a82d35a5d4826c5151c7e8f146607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78270ecd9580964681522fad7c4d7923" id="r_a78270ecd9580964681522fad7c4d7923"><td class="memTemplParams" colspan="2">template&lt;typename... Ops&gt; </td></tr>
<tr class="memitem:a78270ecd9580964681522fad7c4d7923"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1parallel__group.html">parallel_group</a>&lt; Ops... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78270ecd9580964681522fad7c4d7923">make_parallel_group</a> (Ops... ops)</td></tr>
<tr class="memdesc:a78270ecd9580964681522fad7c4d7923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a group of operations that may be launched in parallel.  <br /></td></tr>
<tr class="separator:a78270ecd9580964681522fad7c4d7923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5b9cea9e913734e05923a8314a25ab" id="r_a6a5b9cea9e913734e05923a8314a25ab"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a6a5b9cea9e913734e05923a8314a25ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Range &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a5b9cea9e913734e05923a8314a25ab">make_parallel_group</a> (Range &amp;&amp;range, <a class="el" href="namespaceasio.html#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Range &gt; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a6a5b9cea9e913734e05923a8314a25ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a group of operations that may be launched in parallel.  <br /></td></tr>
<tr class="separator:a6a5b9cea9e913734e05923a8314a25ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade976ef3f044a7757eb4364c1c5d17d1" id="r_ade976ef3f044a7757eb4364c1c5d17d1"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename Range &gt; </td></tr>
<tr class="memitem:ade976ef3f044a7757eb4364c1c5d17d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Range &gt;, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade976ef3f044a7757eb4364c1c5d17d1">make_parallel_group</a> (allocator_arg_t, const Allocator &amp;<a class="el" href="classallocator.html">allocator</a>, Range &amp;&amp;range, <a class="el" href="namespaceasio.html#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Range &gt; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ade976ef3f044a7757eb4364c1c5d17d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a group of operations that may be launched in parallel.  <br /></td></tr>
<tr class="separator:ade976ef3f044a7757eb4364c1c5d17d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6692ccba725d4d7752e9cc97c4da6f" id="r_a0f6692ccba725d4d7752e9cc97c4da6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="structasio_1_1experimental_1_1use__coro__t.html">use_coro_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f6692ccba725d4d7752e9cc97c4da6f">use_coro</a> (0, 0, 0)</td></tr>
<tr class="separator:a0f6692ccba725d4d7752e9cc97c4da6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a229bf7c85d1678e8808e8bc543af3d44" id="r_a229bf7c85d1678e8808e8bc543af3d44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a></td></tr>
<tr class="separator:a229bf7c85d1678e8808e8bc543af3d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4607a9754bf2707c054f0ff16b958b82" id="r_a4607a9754bf2707c054f0ff16b958b82"><td class="memItemLeft" align="right" valign="top">Executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a></td></tr>
<tr class="separator:a4607a9754bf2707c054f0ff16b958b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9975daab69c7b93e79ce807410ffb9d9" id="r_a9975daab69c7b93e79ce807410ffb9d9"><td class="memItemLeft" align="right" valign="top">Executor CompletionToken &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a></td></tr>
<tr class="separator:a9975daab69c7b93e79ce807410ffb9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04f505f291ec3b9eb3018fea6835fea" id="r_ac04f505f291ec3b9eb3018fea6835fea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a></td></tr>
<tr class="separator:ac04f505f291ec3b9eb3018fea6835fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6a92f119223e8ce2c565c4c9fa5983" id="r_a7b6a92f119223e8ce2c565c4c9fa5983"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> &gt; </td></tr>
<tr class="memitem:a7b6a92f119223e8ce2c565c4c9fa5983"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b6a92f119223e8ce2c565c4c9fa5983">is_promise_v</a> = <a class="el" href="structasio_1_1experimental_1_1is__promise.html">is_promise</a>&lt;<a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>&gt;::value</td></tr>
<tr class="separator:a7b6a92f119223e8ce2c565c4c9fa5983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35196bb3ff70ea0de8446d22b8762757" id="r_a35196bb3ff70ea0de8446d22b8762757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="structasio_1_1experimental_1_1use__promise__t.html">use_promise_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35196bb3ff70ea0de8446d22b8762757">use_promise</a></td></tr>
<tr class="separator:a35196bb3ff70ea0de8446d22b8762757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab9bc95bb81ce2f161c5fade03ea92947" name="ab9bc95bb81ce2f161c5fade03ea92947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bc95bb81ce2f161c5fade03ea92947">&#9670;&#160;</a></span>channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutorOrSignature , typename... Signatures&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab9bc95bb81ce2f161c5fade03ea92947">asio::experimental::channel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <span class="keyword">typename</span> detail::channel_type&lt;</div>
<div class="line">    ExecutorOrSignature&gt;::template inner&lt;Signatures...&gt;::type</div>
</div><!-- fragment -->
<p>Template type alias for common use of channel. </p>

</div>
</div>
<a id="a7fefafb3f653f41e014f2139169119a1" name="a7fefafb3f653f41e014f2139169119a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fefafb3f653f41e014f2139169119a1">&#9670;&#160;</a></span>concurrent_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutorOrSignature , typename... Signatures&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7fefafb3f653f41e014f2139169119a1">asio::experimental::concurrent_channel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <span class="keyword">typename</span> detail::concurrent_channel_type&lt;</div>
<div class="line">    ExecutorOrSignature&gt;::template inner&lt;Signatures...&gt;::type</div>
</div><!-- fragment -->
<p>Template type alias for common use of channel. </p>

</div>
</div>
<a id="a8700ef24cc17fcf8f3ae9fb35b1539e3" name="a8700ef24cc17fcf8f3ae9fb35b1539e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8700ef24cc17fcf8f3ae9fb35b1539e3">&#9670;&#160;</a></span>generator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> , typename Executor  = asio::any_io_executor, typename Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8700ef24cc17fcf8f3ae9fb35b1539e3">asio::experimental::generator</a> = <a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt;<a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generator is a coro that returns void and yields value. </p>

</div>
</div>
<a id="a1412f0b02504799c6e210a4ccb5398e6" name="a1412f0b02504799c6e210a4ccb5398e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1412f0b02504799c6e210a4ccb5398e6">&#9670;&#160;</a></span>task</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> , typename Executor  = asio::any_io_executor, typename Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1412f0b02504799c6e210a4ccb5398e6">asio::experimental::task</a> = <a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt;<a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A task is a coro that does not yield values. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a848ebb188067fe5b7278a591bbc0e92f" name="a848ebb188067fe5b7278a591bbc0e92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848ebb188067fe5b7278a591bbc0e92f">&#9670;&#160;</a></span>as_single()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> constexpr <a class="el" href="classasio_1_1experimental_1_1as__single__t.html">as_single_t</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt; &gt; asio::experimental::as_single </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to specify that the completion handler arguments should be combined into a single argument. </p>

</div>
</div>
<a id="ad88bbac9488527afe4a8e0055fcbf6d3" name="ad88bbac9488527afe4a8e0055fcbf6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88bbac9488527afe4a8e0055fcbf6d3">&#9670;&#160;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr)</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a resumable coroutine. </p>
<p>This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coroutine</td></tr>
    <tr><td class="paramname">token</td><td>The completion token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation defined </dd></dl>

</div>
</div>
<a id="aac83b8b49276d49470c7a45cdb5eb2bf" name="aac83b8b49276d49470c7a45cdb5eb2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac83b8b49276d49470c7a45cdb5eb2bf">&#9670;&#160;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> , typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr, <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>)</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a resumable coroutine. </p>
<p>This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coroutine</td></tr>
    <tr><td class="paramname">token</td><td>The completion token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation defined </dd></dl>

</div>
</div>
<a id="a89249a63579083cae4bab8a2513e4a49" name="a89249a63579083cae4bab8a2513e4a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89249a63579083cae4bab8a2513e4a49">&#9670;&#160;</a></span>async_compose&lt; CompletionToken, void(std::exception_ptr)&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return asio::experimental::async_compose&lt; CompletionToken, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;{std::move(<a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>)}</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a></td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exec</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b3e8c93a15f335b266e14235f20291b" name="a0b3e8c93a15f335b266e14235f20291b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e8c93a15f335b266e14235f20291b">&#9670;&#160;</a></span>async_compose&lt; CompletionToken, void(std::exception_ptr)&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return asio::experimental::async_compose&lt; CompletionToken, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;{std::move(<a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>)}</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a></td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exec</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7dd4cdae510a6353182475976cb8594" name="ac7dd4cdae510a6353182475976cb8594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dd4cdae510a6353182475976cb8594">&#9670;&#160;</a></span>async_compose&lt; CompletionToken, void(std::exception_ptr, T)&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return asio::experimental::async_compose&lt; CompletionToken, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr, <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;{std::move(<a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>)}</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a></td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exec</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1558c3d3b0c140ab3bc99d78d8372ed8" name="a1558c3d3b0c140ab3bc99d78d8372ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1558c3d3b0c140ab3bc99d78d8372ed8">&#9670;&#160;</a></span>async_compose&lt; CompletionToken, void(std::exception_ptr, T)&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return asio::experimental::async_compose&lt; CompletionToken, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr, <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;{std::move(<a class="el" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>)}</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a></td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exec</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af580e11a7608adfd35588421fbc592b3" name="af580e11a7608adfd35588421fbc592b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af580e11a7608adfd35588421fbc592b3">&#9670;&#160;</a></span>co_spawn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> , typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::co_spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>() noexcept, <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a resumable coroutine. </p>
<p>This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coroutine</td></tr>
    <tr><td class="paramname">token</td><td>The completion token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation defined </dd></dl>

</div>
</div>
<a id="a157a82d35a5d4826c5151c7e8f146607" name="a157a82d35a5d4826c5151c7e8f146607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157a82d35a5d4826c5151c7e8f146607">&#9670;&#160;</a></span>co_spawn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::co_spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>() noexcept, <a class="el" href="#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a resumable coroutine. </p>
<p>This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coroutine</td></tr>
    <tr><td class="paramname">token</td><td>The completion token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation defined </dd></dl>

</div>
</div>
<a id="ade976ef3f044a7757eb4364c1c5d17d1" name="ade976ef3f044a7757eb4364c1c5d17d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade976ef3f044a7757eb4364c1c5d17d1">&#9670;&#160;</a></span>make_parallel_group() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Range &gt;, Allocator &gt; asio::experimental::make_parallel_group </td>
          <td>(</td>
          <td class="paramtype">allocator_arg_t</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Range &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a group of operations that may be launched in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>Specifies the allocator to be used with the result vectors.</td></tr>
    <tr><td class="paramname">range</td><td>A range containing the operations to be launched.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">using </span>op_type =</div>
<div class="line">  <span class="keyword">decltype</span>(socket1.async_read_some(<a class="code hl_function" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data1)));</div>
<div class="line"> </div>
<div class="line">std::vector&lt;op_type&gt; ops;</div>
<div class="line">ops.push_back(socket1.async_read_some(<a class="code hl_function" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data1)));</div>
<div class="line">ops.push_back(socket2.async_read_some(<a class="code hl_function" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data2)));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#a78270ecd9580964681522fad7c4d7923">asio::experimental::make_parallel_group</a>(</div>
<div class="line">    std::allocator_arg_t,</div>
<div class="line">    my_allocator,</div>
<div class="line">    ops</div>
<div class="line">  ).async_wait(</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a>(),</div>
<div class="line">    [](</div>
<div class="line">        std::vector&lt;std::size_t&gt; completion_order,</div>
<div class="line">        std::vector&lt;std::error_code&gt; e,</div>
<div class="line">        std::vector&lt;std::size_t&gt; n</div>
<div class="line">      )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; completion_order.size(); ++i)</div>
<div class="line">      {</div>
<div class="line">        std::size_t idx = completion_order[i];</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;socket &quot;</span> &lt;&lt; idx &lt;&lt; <span class="stringliteral">&quot; finished: &quot;</span>;</div>
<div class="line">        std::cout &lt;&lt; e[idx] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; n[idx] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  );</div>
<div class="ttc" id="aclassasio_1_1experimental_1_1wait__for__all_html"><div class="ttname"><a href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a></div><div class="ttdoc">Wait for all operations to complete.</div><div class="ttdef"><b>Definition</b> cancellation_condition.hpp:31</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_a78270ecd9580964681522fad7c4d7923"><div class="ttname"><a href="#a78270ecd9580964681522fad7c4d7923">asio::experimental::make_parallel_group</a></div><div class="ttdeci">ASIO_NODISCARD parallel_group&lt; Ops... &gt; make_parallel_group(Ops... ops)</div><div class="ttdoc">Create a group of operations that may be launched in parallel.</div><div class="ttdef"><b>Definition</b> parallel_group.hpp:275</div></div>
<div class="ttc" id="anamespaceasio_html_af691d016b23fd6c2da9ac91ce00c2e7e"><div class="ttname"><a href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a></div><div class="ttdeci">ASIO_NODISCARD ASIO_MUTABLE_BUFFER buffer(const mutable_buffer &amp;b) noexcept</div><div class="ttdoc">Create a new modifiable buffer from an existing buffer.</div><div class="ttdef"><b>Definition</b> buffer.hpp:862</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a78270ecd9580964681522fad7c4d7923" name="a78270ecd9580964681522fad7c4d7923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78270ecd9580964681522fad7c4d7923">&#9670;&#160;</a></span>make_parallel_group() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ops&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1parallel__group.html">parallel_group</a>&lt; Ops... &gt; asio::experimental::make_parallel_group </td>
          <td>(</td>
          <td class="paramtype">Ops...</td>          <td class="paramname"><span class="paramname"><em>ops</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a group of operations that may be launched in parallel. </p>
<p>For example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a78270ecd9580964681522fad7c4d7923">asio::experimental::make_parallel_group</a>(</div>
<div class="line">  in.async_read_some(<a class="code hl_function" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data)),</div>
<div class="line">  <a class="code hl_class" href="classasio_1_1basic__waitable__timer.html">timer</a>.<a class="code hl_function" href="classasio_1_1basic__waitable__timer.html#a42394599c4f3efb7a6c46c78a0166dd3">async_wait</a>()</div>
<div class="line">).async_wait(</div>
<div class="line">  <a class="code hl_class" href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a>(),</div>
<div class="line">  [](</div>
<div class="line">      std::array&lt;std::size_t, 2&gt; completion_order,</div>
<div class="line">      std::error_code ec1, std::size_t <a class="code hl_typedef" href="blocking_8cpp.html#a055ae01cc3681d2bed68e4a9ca84dd93">n1</a>,</div>
<div class="line">      std::error_code ec2</div>
<div class="line">  )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">switch</span> (completion_order[0])</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> 0:</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;descriptor finished: &quot;</span> &lt;&lt; ec1 &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code hl_typedef" href="blocking_8cpp.html#a055ae01cc3681d2bed68e4a9ca84dd93">n1</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 1:</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;timer finished: &quot;</span> &lt;&lt; ec2 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="ttc" id="ablocking_8cpp_html_a055ae01cc3681d2bed68e4a9ca84dd93"><div class="ttname"><a href="blocking_8cpp.html#a055ae01cc3681d2bed68e4a9ca84dd93">n1</a></div><div class="ttdeci">exec::blocking_t::possibly_t n1</div><div class="ttdef"><b>Definition</b> blocking.cpp:27</div></div>
<div class="ttc" id="aclassasio_1_1basic__waitable__timer_html"><div class="ttname"><a href="classasio_1_1basic__waitable__timer.html">asio::basic_waitable_timer&lt; chrono::steady_clock &gt;</a></div></div>
<div class="ttc" id="aclassasio_1_1basic__waitable__timer_html_a42394599c4f3efb7a6c46c78a0166dd3"><div class="ttname"><a href="classasio_1_1basic__waitable__timer.html#a42394599c4f3efb7a6c46c78a0166dd3">asio::basic_waitable_timer::async_wait</a></div><div class="ttdeci">auto async_wait(WaitToken &amp;&amp;token=default_completion_token_t&lt; executor_type &gt;()) -&gt; decltype(async_initiate&lt; WaitToken, void(asio::error_code)&gt;(declval&lt; initiate_async_wait &gt;(), token))</div><div class="ttdoc">Start an asynchronous wait on the timer.</div><div class="ttdef"><b>Definition</b> basic_waitable_timer.hpp:767</div></div>
</div><!-- fragment --><p>If preferred, the asynchronous operations may be explicitly packaged as function objects: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a78270ecd9580964681522fad7c4d7923">asio::experimental::make_parallel_group</a>(</div>
<div class="line">  [&amp;](<span class="keyword">auto</span> <a class="code hl_variable" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> in.async_read_some(<a class="code hl_function" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data), <a class="code hl_variable" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>);</div>
<div class="line">  },</div>
<div class="line">  [&amp;](<span class="keyword">auto</span> <a class="code hl_variable" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_typedef" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>.async_wait(<a class="code hl_variable" href="#a9975daab69c7b93e79ce807410ffb9d9">token</a>);</div>
<div class="line">  }</div>
<div class="line">).async_wait(</div>
<div class="line">  <a class="code hl_class" href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a>(),</div>
<div class="line">  [](</div>
<div class="line">      std::array&lt;std::size_t, 2&gt; completion_order,</div>
<div class="line">      std::error_code ec1, std::size_t <a class="code hl_typedef" href="blocking_8cpp.html#a055ae01cc3681d2bed68e4a9ca84dd93">n1</a>,</div>
<div class="line">      std::error_code ec2</div>
<div class="line">  )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">switch</span> (completion_order[0])</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> 0:</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;descriptor finished: &quot;</span> &lt;&lt; ec1 &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code hl_typedef" href="blocking_8cpp.html#a055ae01cc3681d2bed68e4a9ca84dd93">n1</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 1:</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;timer finished: &quot;</span> &lt;&lt; ec2 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="ttc" id="abind__allocator_8cpp_html_af1abddd6ed87a43a672d1f851b84a694"><div class="ttname"><a href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a></div><div class="ttdeci">steady_timer timer</div><div class="ttdef"><b>Definition</b> bind_allocator.cpp:26</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_a9975daab69c7b93e79ce807410ffb9d9"><div class="ttname"><a href="#a9975daab69c7b93e79ce807410ffb9d9">asio::experimental::token</a></div><div class="ttdeci">Executor CompletionToken &amp;&amp; token</div><div class="ttdef"><b>Definition</b> co_spawn.hpp:67</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6a5b9cea9e913734e05923a8314a25ab" name="a6a5b9cea9e913734e05923a8314a25ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5b9cea9e913734e05923a8314a25ab">&#9670;&#160;</a></span>make_parallel_group() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Range &gt; &gt; asio::experimental::make_parallel_group </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a>&lt; <a class="el" href="namespaceasio.html#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Range &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a group of operations that may be launched in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>A range containing the operations to be launched.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">using </span>op_type =</div>
<div class="line">  <span class="keyword">decltype</span>(socket1.async_read_some(<a class="code hl_function" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data1)));</div>
<div class="line"> </div>
<div class="line">std::vector&lt;op_type&gt; ops;</div>
<div class="line">ops.push_back(socket1.async_read_some(<a class="code hl_function" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data1)));</div>
<div class="line">ops.push_back(socket2.async_read_some(<a class="code hl_function" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data2)));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#a78270ecd9580964681522fad7c4d7923">asio::experimental::make_parallel_group</a>(ops).async_wait(</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a>(),</div>
<div class="line">    [](</div>
<div class="line">        std::vector&lt;std::size_t&gt; completion_order,</div>
<div class="line">        std::vector&lt;std::error_code&gt; e,</div>
<div class="line">        std::vector&lt;std::size_t&gt; n</div>
<div class="line">      )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; completion_order.size(); ++i)</div>
<div class="line">      {</div>
<div class="line">        std::size_t idx = completion_order[i];</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;socket &quot;</span> &lt;&lt; idx &lt;&lt; <span class="stringliteral">&quot; finished: &quot;</span>;</div>
<div class="line">        std::cout &lt;&lt; e[idx] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; n[idx] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  );</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0f6692ccba725d4d7752e9cc97c4da6f" name="a0f6692ccba725d4d7752e9cc97c4da6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6692ccba725d4d7752e9cc97c4da6f">&#9670;&#160;</a></span>use_coro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="structasio_1_1experimental_1_1use__coro__t.html">use_coro_t</a> asio::experimental::use_coro </td>
          <td>(</td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A completion_token object that represents the currently executing resumable coroutine. See the documentation for asio::use_coro_t for a usage example. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4607a9754bf2707c054f0ff16b958b82" name="a4607a9754bf2707c054f0ff16b958b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4607a9754bf2707c054f0ff16b958b82">&#9670;&#160;</a></span>c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor asio::experimental::c</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b6a92f119223e8ce2c565c4c9fa5983" name="a7b6a92f119223e8ce2c565c4c9fa5983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6a92f119223e8ce2c565c4c9fa5983">&#9670;&#160;</a></span>is_promise_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool asio::experimental::is_promise_v = <a class="el" href="structasio_1_1experimental_1_1is__promise.html">is_promise</a>&lt;<a class="el" href="#a229bf7c85d1678e8808e8bc543af3d44">T</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a229bf7c85d1678e8808e8bc543af3d44" name="a229bf7c85d1678e8808e8bc543af3d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229bf7c85d1678e8808e8bc543af3d44">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9975daab69c7b93e79ce807410ffb9d9" name="a9975daab69c7b93e79ce807410ffb9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9975daab69c7b93e79ce807410ffb9d9">&#9670;&#160;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor CompletionToken &amp;&amp; asio::experimental::token</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_namespace" href="namespaceasio_1_1execution.html">exec</a> = <a class="code hl_variable" href="#a4607a9754bf2707c054f0ff16b958b82">c</a>.get_executor()</div>
<div class="ttc" id="anamespaceasio_1_1execution_html"><div class="ttname"><a href="namespaceasio_1_1execution.html">asio::execution</a></div><div class="ttdef"><b>Definition</b> handler_work.hpp:46</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_a4607a9754bf2707c054f0ff16b958b82"><div class="ttname"><a href="#a4607a9754bf2707c054f0ff16b958b82">asio::experimental::c</a></div><div class="ttdeci">Executor c</div><div class="ttdef"><b>Definition</b> co_spawn.hpp:66</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a35196bb3ff70ea0de8446d22b8762757" name="a35196bb3ff70ea0de8446d22b8762757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35196bb3ff70ea0de8446d22b8762757">&#9670;&#160;</a></span>use_promise</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="structasio_1_1experimental_1_1use__promise__t.html">use_promise_t</a> asio::experimental::use_promise</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac04f505f291ec3b9eb3018fea6835fea" name="ac04f505f291ec3b9eb3018fea6835fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04f505f291ec3b9eb3018fea6835fea">&#9670;&#160;</a></span>void</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
