<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rtype Engine: asio Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Rtype Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">asio Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceasio_1_1buffer__literals" id="r_namespaceasio_1_1buffer__literals"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1buffer__literals.html">buffer_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1chrono" id="r_namespaceasio_1_1chrono"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1chrono.html">chrono</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1detail" id="r_namespaceasio_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1error" id="r_namespaceasio_1_1error"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1execution" id="r_namespaceasio_1_1execution"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1execution.html">execution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1experimental" id="r_namespaceasio_1_1experimental"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1generic" id="r_namespaceasio_1_1generic"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1generic.html">generic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1ip" id="r_namespaceasio_1_1ip"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ip.html">ip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1placeholders" id="r_namespaceasio_1_1placeholders"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1resolver__errc" id="r_namespaceasio_1_1resolver__errc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1resolver__errc.html">resolver_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1socket__errc" id="r_namespaceasio_1_1socket__errc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1socket__errc.html">socket_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1ssl" id="r_namespaceasio_1_1ssl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ssl.html">ssl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1stream__errc" id="r_namespaceasio_1_1stream__errc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1stream__errc.html">stream_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1this__coro" id="r_namespaceasio_1_1this__coro"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1this__coro.html">this_coro</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1traits" id="r_namespaceasio_1_1traits"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1traits.html">traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1aligned__storage.html">aligned_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1allocator__binder.html">allocator_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__completion__executor.html">any_completion_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic executor type for use with I/O objects.  <a href="classasio_1_1any__completion__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__completion__handler.html">any_completion_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic wrapper for completion handlers.  <a href="classasio_1_1any__completion__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__completion__handler__allocator.html">any_completion_handler_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__completion__handler__allocator_3_01void_00_01Signatures_8_8_8_01_4.html">any_completion_handler_allocator&lt; void, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__io__executor.html">any_io_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic executor type for use with I/O objects.  <a href="classasio_1_1any__io__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1append__t.html">append_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1as__tuple__t.html">as_tuple_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the allocator associated with an object.  <a href="structasio_1_1associated__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01allocator__binder_3_01T_00_01Allocator_01_4_00_01Allocator1_01_4.html">associated_allocator&lt; allocator_binder&lt; T, Allocator &gt;, Allocator1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01reference__wrapper_3_01T_01_4_00_01Allocator_01_4.html">associated_allocator&lt; reference_wrapper&lt; T &gt;, Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structasio_1_1associated__allocator.html" title="Traits type used to obtain the allocator associated with an object.">associated_allocator</a> for <code>std::reference_wrapper</code>.  <a href="structasio_1_1associated__allocator_3_01reference__wrapper_3_01T_01_4_00_01Allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a> associated with an object.  <a href="structasio_1_1associated__cancellation__slot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__cancellation__slot_3_01cancellation__slot__binder_3_01T_00_01Cancellatc4eed5d80dfb03900583a9d9e232507b.html">associated_cancellation_slot&lt; cancellation_slot_binder&lt; T, CancellationSlot &gt;, CancellationSlot1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__cancellation__slot_3_01reference__wrapper_3_01T_01_4_00_01CancellationSlot_01_4.html">associated_cancellation_slot&lt; reference_wrapper&lt; T &gt;, CancellationSlot &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the executor associated with an object.  <a href="structasio_1_1associated__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01any__completion__handler_3_01Signatures_8_8_8_01_4_00_01Candidate_01_4.html">associated_executor&lt; any_completion_handler&lt; Signatures... &gt;, Candidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Executor1_01_4.html">associated_executor&lt; executor_binder&lt; T, Executor &gt;, Executor1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01reference__wrapper_3_01T_01_4_00_01Executor_01_4.html">associated_executor&lt; reference_wrapper&lt; T &gt;, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structasio_1_1associated__executor.html" title="Traits type used to obtain the executor associated with an object.">associated_executor</a> for <code>std::reference_wrapper</code>.  <a href="structasio_1_1associated__executor_3_01reference__wrapper_3_01T_01_4_00_01Executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the immediate executor associated with an object.  <a href="structasio_1_1associated__immediate__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__immediate__executor_3_01any__completion__handler_3_01Signatures_8_8_8_01_4_00_01Candidate_01_4.html">associated_immediate_executor&lt; any_completion_handler&lt; Signatures... &gt;, Candidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__immediate__executor_3_01immediate__executor__binder_3_01T_00_01Executor_01_4_00_01Executor1_01_4.html">associated_immediate_executor&lt; immediate_executor_binder&lt; T, Executor &gt;, Executor1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__immediate__executor_3_01reference__wrapper_3_01T_01_4_00_01Executor_01_4.html">associated_immediate_executor&lt; reference_wrapper&lt; T &gt;, Executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator.html">associator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to generically specialise associators for a type.  <a href="structasio_1_1associator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01allocator__binder_3_01T_00_01Allocator_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, allocator_binder&lt; T, Allocator &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01cancellation__slot__binder_3_01T_00_01CancellationS16ea2030429147662159ab5b8b8c10ce.html">associator&lt; Associator, cancellation_slot_binder&lt; T, CancellationSlot &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1append__handler_3_01Handler_00_01Values_87e9d01edec3ae13439b7689dbbbc8f93.html">associator&lt; Associator, detail::append_handler&lt; Handler, Values... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1as__tuple__handler_3_01Handler_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::as_tuple_handler&lt; Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder0_3_01Handler_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::binder0&lt; Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder1_3_01Handler_00_01Arg1_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::binder1&lt; Handler, Arg1 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder2_3_01Handler_00_01Arg1_00_01Arg2_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::binder2&lt; Handler, Arg1, Arg2 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder3_3_01Handler_00_01Arg1_00_01Arg2_09bd080fd76ec8145f6601d8c51453d64.html">associator&lt; Associator, detail::binder3&lt; Handler, Arg1, Arg2, Arg3 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder4_3_01Handler_00_01Arg1_00_01Arg2_050a4bed10c672931b90c89a21fe59188.html">associator&lt; Associator, detail::binder4&lt; Handler, Arg1, Arg2, Arg3, Arg4 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder5_3_01Handler_00_01Arg1_00_01Arg2_04cb1e404b95af920a52ae3dbe213b42d.html">associator&lt; Associator, detail::binder5&lt; Handler, Arg1, Arg2, Arg3, Arg4, Arg5 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1buffered__fill__handler_3_01ReadHandler_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::buffered_fill_handler&lt; ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1buffered__flush__handler_3_01WriteHandlerd7dd930bacfe01efde8eec04549b422a.html">associator&lt; Associator, detail::buffered_flush_handler&lt; WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1buffered__read__some__handler_3_01Mutableba928f90a91172ec6479f165f9f87b22.html">associator&lt; Associator, detail::buffered_read_some_handler&lt; MutableBufferSequence, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1buffered__write__some__handler_3_01ConstBdf8856a81aa37eac88005d61d2d05cd0.html">associator&lt; Associator, detail::buffered_write_some_handler&lt; ConstBufferSequence, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1completion__payload__handler_3_01Payload_e2cb2c262150398b02d83f403e0123b1.html">associator&lt; Associator, detail::completion_payload_handler&lt; Payload, Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1composed__op_3_01Impl_00_01Work_00_01Handd2b60f25858fe2b2c8fde81f2d2191d6.html">associator&lt; Associator, detail::composed_op&lt; Impl, Work, Handler, Signature &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1consign__handler_3_01Handler_00_01Values_ce7a72adc63608e4116ab6d39c342dd0.html">associator&lt; Associator, detail::consign_handler&lt; Handler, Values... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1deferred__sequence__handler_3_01Handler_09755d84f2556cfea0d01de4e9c435368.html">associator&lt; Associator, detail::deferred_sequence_handler&lt; Handler, Tail &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1iterator__connect__op_3_01Protocol_00_01Ed9e7e0bf65755c467a79770b2d60914f.html">associator&lt; Associator, detail::iterator_connect_op&lt; Protocol, Executor, Iterator, ConnectCondition, IteratorConnectHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1move__binder1_3_01Handler_00_01Arg1_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::move_binder1&lt; Handler, Arg1 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1move__binder2_3_01Handler_00_01Arg1_00_0161eaa9a35134749d6d6c28bae505d8f5.html">associator&lt; Associator, detail::move_binder2&lt; Handler, Arg1, Arg2 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1prepend__handler_3_01Handler_00_01Values_b046c901742e13ade848eaa1fbf82d94.html">associator&lt; Associator, detail::prepend_handler&lt; Handler, Values... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1range__connect__op_3_01Protocol_00_01Exec6610d253133b2f33c529aa6911687715.html">associator&lt; Associator, detail::range_connect_op&lt; Protocol, Executor, EndpointSequence, ConnectCondition, RangeConnectHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__at__op_3_01AsyncRandomAccessReadDevcef155d55787c8da333a4ae885d8c727.html">associator&lt; Associator, detail::read_at_op&lt; AsyncRandomAccessReadDevice, MutableBufferSequence, MutableBufferIterator, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__at__streambuf__op_3_01AsyncRandomAcecfa833cd2087a0c50e518c0c4625908.html">associator&lt; Associator, detail::read_at_streambuf_op&lt; AsyncRandomAccessReadDevice, Executor, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__dynbuf__v1__op_3_01AsyncReadStream_26756f839f25e64de26021382dd49ec3.html">associator&lt; Associator, detail::read_dynbuf_v1_op&lt; AsyncReadStream, DynamicBuffer_v1, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__dynbuf__v2__op_3_01AsyncReadStream_6819db99172d8e4b09407e94635a6a19.html">associator&lt; Associator, detail::read_dynbuf_v2_op&lt; AsyncReadStream, DynamicBuffer_v2, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__op_3_01AsyncReadStream_00_01Mutable43249ffb3ae8e7023069da5aec3be814.html">associator&lt; Associator, detail::read_op&lt; AsyncReadStream, MutableBufferSequence, MutableBufferIterator, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__delim__op__v1_3_01AsyncReadSa7be94242e84ee491d0d4a039a7e0e3b.html">associator&lt; Associator, detail::read_until_delim_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__delim__op__v2_3_01AsyncReadSaea4defad4ab6a119013ead28c062191.html">associator&lt; Associator, detail::read_until_delim_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__delim__string__op__v1_3_01As57d02d712a24211631cb0d0c67c501be.html">associator&lt; Associator, detail::read_until_delim_string_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__delim__string__op__v2_3_01As8f406661583e15aabe3248142c1de8af.html">associator&lt; Associator, detail::read_until_delim_string_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__match__op__v1_3_01AsyncReadSb6f2f976d5232ce652ebe6841f0b066e.html">associator&lt; Associator, detail::read_until_match_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, MatchCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__match__op__v2_3_01AsyncReadScf5b8f0a27806f899ea1b5e1baa8231d.html">associator&lt; Associator, detail::read_until_match_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, MatchCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1redirect__error__handler_3_01Handler_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::redirect_error_handler&lt; Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1timed__cancel__op__handler_3_01Op_00_01Siebca126747b535c687262412c03d6c49.html">associator&lt; Associator, detail::timed_cancel_op_handler&lt; Op, Signatures... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1timed__cancel__timer__handler_3_01Op_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::timed_cancel_timer_handler&lt; Op &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__at__op_3_01AsyncRandomAccessWriteD1734ea544f509b0655ab6176e1cfa3b7.html">associator&lt; Associator, detail::write_at_op&lt; AsyncRandomAccessWriteDevice, ConstBufferSequence, ConstBufferIterator, CompletionCondition, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__at__streambuf__op_3_01Executor_00_f2360bde8672b7510f9d41c58243048a.html">associator&lt; Associator, detail::write_at_streambuf_op&lt; Executor, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__dynbuf__v1__op_3_01AsyncWriteStrea7a2bf910039707817c36e054d69697ee.html">associator&lt; Associator, detail::write_dynbuf_v1_op&lt; AsyncWriteStream, DynamicBuffer_v1, CompletionCondition, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__dynbuf__v2__op_3_01AsyncWriteStreaf7183f6b0e66364d2eedd774efa702ac.html">associator&lt; Associator, detail::write_dynbuf_v2_op&lt; AsyncWriteStream, DynamicBuffer_v2, CompletionCondition, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__op_3_01AsyncWriteStream_00_01Const945952beb6b88739ce3f365bd57fcec3.html">associator&lt; Associator, detail::write_op&lt; AsyncWriteStream, ConstBufferSequence, ConstBufferIterator, CompletionCondition, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01executor__binder_3_01T_00_01Executor_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, executor_binder&lt; T, Executor &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01experimental_1_1detail_1_1as__single__handler_3_01H6c2fad8b25c05174c255b98fc93985b6.html">associator&lt; Associator, experimental::detail::as_single_handler&lt; Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01experimental_1_1detail_1_1parallel__group__completi0ef89a80519f57ed7ecef86848b30d67.html">associator&lt; Associator, experimental::detail::parallel_group_completion_handler&lt; Handler, Ops... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01experimental_1_1detail_1_1ranged__parallel__group__527bebfad597413b545f18618fcaed86.html">associator&lt; Associator, experimental::detail::ranged_parallel_group_completion_handler&lt; Handler, Op, Allocator &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01immediate__executor__binder_3_01T_00_01Executor_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, immediate_executor_binder&lt; T, Executor &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01ssl_1_1detail_1_1io__op_3_01Stream_00_01Operation_0e7503c15a9b710dbdd4bfdefbd7cc155.html">associator&lt; Associator, ssl::detail::io_op&lt; Stream, Operation, Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__completion.html">async_completion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result.html">async_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01allocator__binder_3_01T_00_01Allocator_01_4_00_01Signature_01_4.html">async_result&lt; allocator_binder&lt; T, Allocator &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01append__t_3_01CompletionToken_00_01Values_8_8_8_01_4_00_01Signature_01_4.html">async_result&lt; append_t&lt; CompletionToken, Values... &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01archetypes_1_1immediate__handler_00_01Signature_01_4.html">async_result&lt; archetypes::immediate_handler, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01archetypes_1_1lazy__handler_00_01Signature_01_4.html">async_result&lt; archetypes::lazy_handler, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01as__tuple__t_3_01CompletionToken_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; as_tuple_t&lt; CompletionToken &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01basic__yield__context_3_01Executor_01_4_00_01Signature_01_4.html">async_result&lt; basic_yield_context&lt; Executor &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01cancel__after__t_3_01CompletionToken_00_01Clock_00_01WaitTraits_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; cancel_after_t&lt; CompletionToken, Clock, WaitTraits &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01cancel__after__timer_3_01CompletionToken_00_01Clock_00_01WaitTra56d5abf7ca11d558da43f0e11ad42eec.html">async_result&lt; cancel_after_timer&lt; CompletionToken, Clock, WaitTraits, Executor &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01cancel__at__t_3_01CompletionToken_00_01Clock_00_01WaitTraits_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; cancel_at_t&lt; CompletionToken, Clock, WaitTraits &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01cancel__at__timer_3_01CompletionToken_00_01Clock_00_01WaitTraits4cde8caad80b3c9d0ebb0d936252e5a7.html">async_result&lt; cancel_at_timer&lt; CompletionToken, Clock, WaitTraits, Executor &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01cancellation__slot__binder_3_01T_00_01CancellationSlot_01_4_00_01Signature_01_4.html">async_result&lt; cancellation_slot_binder&lt; T, CancellationSlot &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01close__after_00_01void_07std_1_1error__code_00_01T_08_4.html">async_result&lt; close_after, void(std::error_code, T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01consign__t_3_01CompletionToken_00_01Values_8_8_8_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; consign_t&lt; CompletionToken, Values... &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01deferred__function_3_01Function_01_4_00_01Signature_01_4.html">async_result&lt; deferred_function&lt; Function &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01deferred__function_3_01Function_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; deferred_function&lt; Function &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01deferred__t_00_01Signature_01_4.html">async_result&lt; deferred_t, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01deferred__t_00_01Signatures_8_8_8_01_4.html">async_result&lt; deferred_t, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01detached__t_00_01Signatures_8_8_8_01_4.html">async_result&lt; detached_t, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1async__operation__probe_00_01Signatures_8_8_8_01_4.html">async_result&lt; detail::async_operation_probe, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1completion__signature__probe_00_01Signature_01_4.html">async_result&lt; detail::completion_signature_probe, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1completion__signature__probe_00_01Signatures_8_8_8_01_4.html">async_result&lt; detail::completion_signature_probe, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1packaged__token_3_01Function_00_01Allocator_01_4_00_01Result_07Args_8_8_8_08_4.html">async_result&lt; detail::packaged_token&lt; Function, Allocator &gt;, Result(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Signature_01_4.html">async_result&lt; executor_binder&lt; T, Executor &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1as__single__t_3_01CompletionToken_01_4_00_01Signature_01_4.html">async_result&lt; experimental::as_single_t&lt; CompletionToken &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07asio_1_1error__code_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07asio_1_1error__code_00_01T_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(asio::error_code, T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07std_1_1exception__ptr_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(std::exception_ptr)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07std_1_1exception__ptr_00_01T_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(std::exception_ptr, T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07T_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__promise__t_3_01Allocator_01_4_00_01R_07Args_8_8_8_08_4.html">async_result&lt; experimental::use_promise_t&lt; Allocator &gt;, R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01immediate__executor__binder_3_01T_00_01Executor_01_4_00_01Signature_01_4.html">async_result&lt; immediate_executor_binder&lt; T, Executor &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01incrementer__token__v1_00_01void_07asio_1_1error__code_08_4.html">async_result&lt; incrementer_token_v1, void(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01incrementer__token__v2_00_01void_07asio_1_1error__code_08_4.html">async_result&lt; incrementer_token_v2, void(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__allocator__binder_3_01Allocator_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; partial_allocator_binder&lt; Allocator &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__as__tuple_00_01Signatures_8_8_8_01_4.html">async_result&lt; partial_as_tuple, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__cancel__after_3_01Clock_00_01WaitTraits_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; partial_cancel_after&lt; Clock, WaitTraits &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__cancel__after__timer_3_01Clock_00_01WaitTraits_00_01Exead8025047ecab77fc3ed138018506484.html">async_result&lt; partial_cancel_after_timer&lt; Clock, WaitTraits, Executor &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__cancel__at_3_01Clock_00_01WaitTraits_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; partial_cancel_at&lt; Clock, WaitTraits &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__cancel__at__timer_3_01Clock_00_01WaitTraits_00_01Execut032b1b57e20af6687fbde9365a47a25e.html">async_result&lt; partial_cancel_at_timer&lt; Clock, WaitTraits, Executor &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__cancellation__slot__binder_3_01CancellationSlot_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; partial_cancellation_slot_binder&lt; CancellationSlot &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__executor__binder_3_01Executor_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; partial_executor_binder&lt; Executor &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__immediate__executor__binder_3_01Executor_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; partial_immediate_executor_binder&lt; Executor &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01partial__redirect__error_00_01Signatures_8_8_8_01_4.html">async_result&lt; partial_redirect_error, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01prepend__t_3_01CompletionToken_00_01Values_8_8_8_01_4_00_01Signature_01_4.html">async_result&lt; prepend_t&lt; CompletionToken, Values... &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01redirect__error__t_3_01CompletionToken_01_4_00_01Signature_01_4.html">async_result&lt; redirect_error_t&lt; CompletionToken &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01use__awaitable__t_3_01Executor_01_4_00_01R_07Args_8_8_8_08_4.html">async_result&lt; use_awaitable_t&lt; Executor &gt;, R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01use__future__t_3_01Allocator_01_4_00_01Result_07Args_8_8_8_08_4.html">async_result&lt; use_future_t&lt; Allocator &gt;, Result(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01void_00_01Signatures_8_8_8_01_4.html">async_result&lt; void, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1bad__executor.html">bad_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when trying to access an empty polymorphic executor.  <a href="classasio_1_1bad__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__datagram__socket.html">basic_datagram_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides datagram-oriented socket functionality.  <a href="classasio_1_1basic__datagram__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__io__object.html">basic_io_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all I/O objects.  <a href="classasio_1_1basic__io__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__io__object_3_01IoObjectService_00_01true_01_4.html">basic_io_object&lt; IoObjectService, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__raw__socket.html">basic_raw_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides raw-oriented socket functionality.  <a href="classasio_1_1basic__raw__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__seq__packet__socket.html">basic_seq_packet_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides sequenced packet socket functionality.  <a href="classasio_1_1basic__seq__packet__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides signal functionality.  <a href="classasio_1_1basic__signal__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides socket functionality.  <a href="classasio_1_1basic__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the ability to accept new connections.  <a href="classasio_1_1basic__socket__acceptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__iostream.html">basic_socket_iostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream interface for a socket.  <a href="classasio_1_1basic__socket__iostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__streambuf.html">basic_socket_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream streambuf for a socket.  <a href="classasio_1_1basic__socket__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__stream__socket.html">basic_stream_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides stream-oriented socket functionality.  <a href="classasio_1_1basic__stream__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically resizable buffer class based on std::streambuf.  <a href="classasio_1_1basic__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> to the dynamic buffer sequence type requirements.  <a href="classasio_1_1basic__streambuf__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__system__executor.html">basic_system_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An executor that uses arbitrary threads.  <a href="classasio_1_1basic__system__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides waitable timer functionality.  <a href="classasio_1_1basic__waitable__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A completion_token that represents the currently executing coroutine.  <a href="classasio_1_1basic__yield__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically registers and unregistered buffers with an execution context.  <a href="classasio_1_1buffer__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read-related operations of a stream.  <a href="classasio_1_1buffered__read__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__stream.html">buffered_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read- and write-related operations of a stream.  <a href="classasio_1_1buffered__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the write-related operations of a stream.  <a href="classasio_1_1buffered__write__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator over the bytes in a buffer sequence.  <a href="classasio_1_1buffers__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1can__prefer.html">can_prefer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1can__query.html">can_query</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1can__require.html">can_require</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1can__require__concept.html">can_require_concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancel__after__t.html">cancel_after_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A completion_token adapter that cancels an operation after a timeout.  <a href="classasio_1_1cancel__after__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancel__after__timer.html">cancel_after_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A completion_token adapter that cancels an operation after a timeout.  <a href="classasio_1_1cancel__after__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancel__at__t.html">cancel_at_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A completion_token adapter that cancels an operation at a given time.  <a href="classasio_1_1cancel__at__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancel__at__timer.html">cancel_at_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A completion_token adapter that cancels an operation at a given time.  <a href="classasio_1_1cancel__at__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple cancellation signal propagation filter.  <a href="structasio_1_1cancellation__filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancellation__signal.html">cancellation_signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cancellation signal with a single slot.  <a href="classasio_1_1cancellation__signal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancellation__slot.html">cancellation_slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot associated with a cancellation signal.  <a href="classasio_1_1cancellation__slot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancellation__slot__binder.html">cancellation_slot_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancellation__state.html">cancellation_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cancellation state is used for chaining signals and slots in compositions.  <a href="classasio_1_1cancellation__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1completion__signature__of.html">completion_signature_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1conjunction.html">conjunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1conjunction_3_01Head_00_01Tail_8_8_8_01_4.html">conjunction&lt; Head, Tail... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1conjunction_3_01T_01_4.html">conjunction&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1consign__t.html">consign_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that cannot be modified.  <a href="classasio_1_1const__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a registered buffer over non-modifiable data.  <a href="classasio_1_1const__registered__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1constraint.html">constraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1coroutine.html">coroutine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides support for implementing stackless coroutines.  <a href="classasio_1_1coroutine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1default__completion__token.html">default_completion_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__async__operation.html">deferred_async_operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a deferred asynchronous operation.  <a href="classasio_1_1deferred__async__operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__async__operation_3_01deferred__signatures_3_01Signatures_8_8_8_01_4_00_01d2f4f46bc21d724b8f906416eaee9202.html">deferred_async_operation&lt; deferred_signatures&lt; Signatures... &gt;, Initiation, InitArgs... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__conditional.html">deferred_conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to represent a deferred conditional branch.  <a href="classasio_1_1deferred__conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__function.html">deferred_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1deferred__init__tag.html">deferred_init_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to disambiguate deferred constructors.  <a href="structasio_1_1deferred__init__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1deferred__noop.html">deferred_noop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to represent an empty deferred action.  <a href="structasio_1_1deferred__noop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__sequence.html">deferred_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a link between two consecutive operations in a sequence.  <a href="classasio_1_1deferred__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1deferred__signatures.html">deferred_signatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to wrap multiple completion signatures.  <a href="structasio_1_1deferred__signatures.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__t.html">deferred_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__values.html">deferred_values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates deferred values.  <a href="classasio_1_1deferred__values.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1detached__t.html">detached_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a basic_string to the DynamicBuffer requirements.  <a href="classasio_1_1dynamic__string__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a vector to the DynamicBuffer requirements.  <a href="classasio_1_1dynamic__vector__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1execution__context.html">execution_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context for function object execution.  <a href="classasio_1_1execution__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor.html">executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic wrapper for executors.  <a href="classasio_1_1executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__work__guard_3_01Executor_00_01enable__if__t_3_01_9is__executor_3_01Execut25e5ea9994b9460d12280043f650d2a0.html">executor_work_guard&lt; Executor, enable_if_t&lt; !is_executor&lt; Executor &gt;::value &gt;, enable_if_t&lt; execution::is_executor&lt; Executor &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__work__guard_3_01Executor_00_01enable__if__t_3_01is__executor_3_01Executor_01_4_1_1value_01_4_01_4.html">executor_work_guard&lt; Executor, enable_if_t&lt; is_executor&lt; Executor &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1immediate__executor__binder.html">immediate_executor_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1invalid__service__owner.html">invalid_service_owner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1io__context.html">io_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core I/O functionality.  <a href="classasio_1_1io__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property.html">is_applicable_property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01object_00_01prop_01_4.html">is_applicable_property&lt; object, prop &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01object_3_01N_01_4_00_01prop_3_01M_01_4_01_4.html">is_applicable_property&lt; object&lt; N &gt;, prop&lt; M &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1allocator__t_3_01ProtoAllocator_01_4_01_4.html">is_applicable_property&lt; T, execution::allocator_t&lt; ProtoAllocator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__adaptation__t_01_4.html">is_applicable_property&lt; T, execution::blocking_adaptation_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__adaptation__t_1_1allowed__t_01_4.html">is_applicable_property&lt; T, execution::blocking_adaptation_t::allowed_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__adaptation__t_1_1disallowed__t_01_4.html">is_applicable_property&lt; T, execution::blocking_adaptation_t::disallowed_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__t_01_4.html">is_applicable_property&lt; T, execution::blocking_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__t_1_1always__t_01_4.html">is_applicable_property&lt; T, execution::blocking_t::always_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__t_1_1never__t_01_4.html">is_applicable_property&lt; T, execution::blocking_t::never_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__t_1_1possibly__t_01_4.html">is_applicable_property&lt; T, execution::blocking_t::possibly_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1context__as__t_3_01U_01_4_01_4.html">is_applicable_property&lt; T, execution::context_as_t&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1context__t_01_4.html">is_applicable_property&lt; T, execution::context_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1mapping__t_01_4.html">is_applicable_property&lt; T, execution::mapping_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1mapping__t_1_1new__thread__t_01_4.html">is_applicable_property&lt; T, execution::mapping_t::new_thread_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1mapping__t_1_1other__t_01_4.html">is_applicable_property&lt; T, execution::mapping_t::other_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1mapping__t_1_1thread__t_01_4.html">is_applicable_property&lt; T, execution::mapping_t::thread_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1occupancy__t_01_4.html">is_applicable_property&lt; T, execution::occupancy_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1outstanding__work__t_01_4.html">is_applicable_property&lt; T, execution::outstanding_work_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1outstanding__work__t_1_1tracked__t_01_4.html">is_applicable_property&lt; T, execution::outstanding_work_t::tracked_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1outstanding__work__t_1_1untracked__t_01_4.html">is_applicable_property&lt; T, execution::outstanding_work_t::untracked_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1prefer__only_3_01InnerProperty_01_4_01_4.html">is_applicable_property&lt; T, execution::prefer_only&lt; InnerProperty &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1relationship__t_01_4.html">is_applicable_property&lt; T, execution::relationship_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1relationship__t_1_1continuation__t_01_4.html">is_applicable_property&lt; T, execution::relationship_t::continuation_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1relationship__t_1_1fork__t_01_4.html">is_applicable_property&lt; T, execution::relationship_t::fork_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__async__operation.html">is_async_operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred.html">is_deferred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for detecting objects that are usable as deferred operations.  <a href="structasio_1_1is__deferred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__async__operation_3_01Signature_00_01Initiation_00_01InitArgs_8_8_8_01_4_01_4.html">is_deferred&lt; deferred_async_operation&lt; Signature, Initiation, InitArgs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__conditional_3_01OnTrue_00_01OnFalse_01_4_01_4.html">is_deferred&lt; deferred_conditional&lt; OnTrue, OnFalse &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__function_3_01Function_01_4_01_4.html">is_deferred&lt; deferred_function&lt; Function &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__noop_01_4.html">is_deferred&lt; deferred_noop &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__sequence_3_01Head_00_01Tail_01_4_01_4.html">is_deferred&lt; deferred_sequence&lt; Head, Tail &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__values_3_01Values_8_8_8_01_4_01_4.html">is_deferred&lt; deferred_values&lt; Values... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to determine whether a type satisfies the DynamicBuffer requirements.  <a href="structasio_1_1is__dynamic__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__executor.html">is_executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__match__condition_3_01match__char_01_4.html">is_match_condition&lt; match_char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__nothrow__prefer.html">is_nothrow_prefer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__nothrow__query.html">is_nothrow_query</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__nothrow__require.html">is_nothrow_require</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__nothrow__require__concept.html">is_nothrow_require_concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__read__buffered.html">is_read_buffered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__write__buffered.html">is_write_buffered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1multiple__exceptions.html">multiple_exceptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when there are multiple pending exceptions to rethrow.  <a href="classasio_1_1multiple__exceptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that can be modified.  <a href="classasio_1_1mutable__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a registered buffer over modifiable data.  <a href="classasio_1_1mutable__registered__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1null__buffers.html">null_buffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1partial__allocator__binder.html">partial_allocator_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1partial__as__tuple.html">partial_as_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1partial__cancel__after.html">partial_cancel_after</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1partial__cancel__after__timer.html">partial_cancel_after_timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1partial__cancel__at.html">partial_cancel_at</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1partial__cancel__at__timer.html">partial_cancel_at_timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1partial__cancellation__slot__binder.html">partial_cancellation_slot_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1partial__executor__binder.html">partial_executor_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1partial__immediate__executor__binder.html">partial_immediate_executor_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1partial__redirect__error.html">partial_redirect_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1prefer__result.html">prefer_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1prepend__t.html">prepend_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1query__result.html">query_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1recycling__allocator.html">recycling_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator that caches memory blocks in thread-local storage for reuse.  <a href="classasio_1_1recycling__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1recycling__allocator_3_01void_01_4.html">recycling_allocator&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1registered__buffer__id.html">registered_buffer_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify a registered buffer.  <a href="classasio_1_1registered__buffer__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1require__concept__result.html">require_concept_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1require__result.html">require_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1service__already__exists.html">service_already_exists</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1signal__set__base.html">signal_set_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html">socket_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1strand.html">strand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides serialised function invocation for any executor type.  <a href="classasio_1_1strand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__context.html">system_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor context for the system executor.  <a href="classasio_1_1system__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread.html">thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple abstraction for starting threads.  <a href="classasio_1_1thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple fixed-size thread pool.  <a href="classasio_1_1thread__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1uses__executor.html">uses_executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1uses__executor_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Executor_01_4.html">uses_executor&lt; executor_binder&lt; T, Executor &gt;, Executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1void__type.html">void_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1wait__traits.html">wait_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait traits suitable for use with the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> class template.  <a href="structasio_1_1wait__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:affc78250721f13a1263cfd53002d6bd0" id="r_affc78250721f13a1263cfd53002d6bd0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:affc78250721f13a1263cfd53002d6bd0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affc78250721f13a1263cfd53002d6bd0">associated_allocator_t</a> = typename <a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt;T, Allocator&gt;::type</td></tr>
<tr class="separator:affc78250721f13a1263cfd53002d6bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61679c8b9f47d8af2c022e82c02a633" id="r_af61679c8b9f47d8af2c022e82c02a633"><td class="memTemplParams" colspan="2">template&lt;typename T , typename CancellationSlot  = cancellation_slot&gt; </td></tr>
<tr class="memitem:af61679c8b9f47d8af2c022e82c02a633"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af61679c8b9f47d8af2c022e82c02a633">associated_cancellation_slot_t</a></td></tr>
<tr class="separator:af61679c8b9f47d8af2c022e82c02a633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c819bb7b358898e38408c978e6c93f2" id="r_a0c819bb7b358898e38408c978e6c93f2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor  = system_executor&gt; </td></tr>
<tr class="memitem:a0c819bb7b358898e38408c978e6c93f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c819bb7b358898e38408c978e6c93f2">associated_executor_t</a> = typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, Executor&gt;::type</td></tr>
<tr class="separator:a0c819bb7b358898e38408c978e6c93f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98749f025f2ea9356fbffe308e3e4afb" id="r_a98749f025f2ea9356fbffe308e3e4afb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:a98749f025f2ea9356fbffe308e3e4afb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a98749f025f2ea9356fbffe308e3e4afb">associated_immediate_executor_t</a></td></tr>
<tr class="separator:a98749f025f2ea9356fbffe308e3e4afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e56380c6e0bff931bfc27cb24546b5" id="r_aa6e56380c6e0bff931bfc27cb24546b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa6e56380c6e0bff931bfc27cb24546b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6e56380c6e0bff931bfc27cb24546b5">completion_signature_of_t</a></td></tr>
<tr class="separator:aa6e56380c6e0bff931bfc27cb24546b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7be67c717fae6f2e1b186573b74b44" id="r_a8c7be67c717fae6f2e1b186573b74b44"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8">cancellation_type::none</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c7be67c717fae6f2e1b186573b74b44">disable_cancellation</a></td></tr>
<tr class="memdesc:a8c7be67c717fae6f2e1b186573b74b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cancellation filter that disables cancellation.  <br /></td></tr>
<tr class="separator:a8c7be67c717fae6f2e1b186573b74b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbee6470702e960e05ea7d244173a53" id="r_a8bbee6470702e960e05ea7d244173a53"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bbee6470702e960e05ea7d244173a53">enable_terminal_cancellation</a></td></tr>
<tr class="memdesc:a8bbee6470702e960e05ea7d244173a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cancellation filter that enables terminal cancellation only.  <br /></td></tr>
<tr class="separator:a8bbee6470702e960e05ea7d244173a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3cac58ab6a1f1fe34475f706d635e5" id="r_ade3cac58ab6a1f1fe34475f706d635e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; static_cast&lt; <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> &gt;(static_cast&lt; unsigned int &gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>)|static_cast&lt; unsigned int &gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a>))&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade3cac58ab6a1f1fe34475f706d635e5">enable_partial_cancellation</a></td></tr>
<tr class="separator:ade3cac58ab6a1f1fe34475f706d635e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5a2903e6e8f37c19f8fac0602ff52a" id="r_a9e5a2903e6e8f37c19f8fac0602ff52a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; static_cast&lt; <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> &gt;(static_cast&lt; unsigned int &gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>)|static_cast&lt; unsigned int &gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a>)|static_cast&lt; unsigned int &gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e">cancellation_type::total</a>))&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e5a2903e6e8f37c19f8fac0602ff52a">enable_total_cancellation</a></td></tr>
<tr class="separator:a9e5a2903e6e8f37c19f8fac0602ff52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d85a0e28424dfdf416a9a812841606b" id="r_a5d85a0e28424dfdf416a9a812841606b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d85a0e28424dfdf416a9a812841606b">cancellation_type_t</a></td></tr>
<tr class="separator:a5d85a0e28424dfdf416a9a812841606b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20e77355502b24334a3e9a37b76156a" id="r_ae20e77355502b24334a3e9a37b76156a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae20e77355502b24334a3e9a37b76156a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a> = typename <a class="el" href="structasio_1_1default__completion__token.html">default_completion_token</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ae20e77355502b24334a3e9a37b76156a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c2c0de78e09a17f9411347105fa468" id="r_a86c2c0de78e09a17f9411347105fa468"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86c2c0de78e09a17f9411347105fa468"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86c2c0de78e09a17f9411347105fa468">add_const_t</a> = typename std::add_const&lt;T&gt;::type</td></tr>
<tr class="separator:a86c2c0de78e09a17f9411347105fa468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3717b6d9f669e34ca90122df5cd7ae26" id="r_a3717b6d9f669e34ca90122df5cd7ae26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3717b6d9f669e34ca90122df5cd7ae26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3717b6d9f669e34ca90122df5cd7ae26">add_lvalue_reference_t</a> = typename std::add_lvalue_reference&lt;T&gt;::type</td></tr>
<tr class="separator:a3717b6d9f669e34ca90122df5cd7ae26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02032fa24e71a291e5ca0a4653bf0659" id="r_a02032fa24e71a291e5ca0a4653bf0659"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, std::size_t A&gt; </td></tr>
<tr class="memitem:a02032fa24e71a291e5ca0a4653bf0659"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02032fa24e71a291e5ca0a4653bf0659">aligned_storage_t</a> = typename <a class="el" href="structasio_1_1aligned__storage.html">aligned_storage</a>&lt;N, A&gt;::type</td></tr>
<tr class="separator:a02032fa24e71a291e5ca0a4653bf0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100ff23938cde2a03e28b4bde5321cc0" id="r_a100ff23938cde2a03e28b4bde5321cc0"><td class="memTemplParams" colspan="2">template&lt;bool C, typename T , typename U &gt; </td></tr>
<tr class="memitem:a100ff23938cde2a03e28b4bde5321cc0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a100ff23938cde2a03e28b4bde5321cc0">conditional_t</a> = typename std::conditional&lt;C, T, U&gt;::type</td></tr>
<tr class="separator:a100ff23938cde2a03e28b4bde5321cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961c7a660a10d1a9506ea4d6eb366023" id="r_a961c7a660a10d1a9506ea4d6eb366023"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a961c7a660a10d1a9506ea4d6eb366023"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a> = typename std::decay&lt;T&gt;::type</td></tr>
<tr class="separator:a961c7a660a10d1a9506ea4d6eb366023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cbae0cd49c139578f11530959497f2" id="r_a56cbae0cd49c139578f11530959497f2"><td class="memTemplParams" colspan="2">template&lt;bool C, typename T  = void&gt; </td></tr>
<tr class="memitem:a56cbae0cd49c139578f11530959497f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a> = typename std::enable_if&lt;C, T&gt;::type</td></tr>
<tr class="separator:a56cbae0cd49c139578f11530959497f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddbdaed94f37b8d9b05c25b7b47ec25" id="r_abddbdaed94f37b8d9b05c25b7b47ec25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abddbdaed94f37b8d9b05c25b7b47ec25"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abddbdaed94f37b8d9b05c25b7b47ec25">remove_cv_t</a> = typename std::remove_cv&lt;T&gt;::type</td></tr>
<tr class="separator:abddbdaed94f37b8d9b05c25b7b47ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8335631d5ec10332d2774eb5b261150" id="r_ab8335631d5ec10332d2774eb5b261150"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8335631d5ec10332d2774eb5b261150"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8335631d5ec10332d2774eb5b261150">remove_cvref_t</a> = typename <a class="el" href="structasio_1_1remove__cvref.html">remove_cvref</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ab8335631d5ec10332d2774eb5b261150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f4d18a492e1c2e7a4664d5775386fa" id="r_a56f4d18a492e1c2e7a4664d5775386fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56f4d18a492e1c2e7a4664d5775386fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56f4d18a492e1c2e7a4664d5775386fa">remove_pointer_t</a> = typename std::remove_pointer&lt;T&gt;::type</td></tr>
<tr class="separator:a56f4d18a492e1c2e7a4664d5775386fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f77cce220380ae23fa06dbf2181a30a" id="r_a8f77cce220380ae23fa06dbf2181a30a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f77cce220380ae23fa06dbf2181a30a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a> = typename std::remove_reference&lt;T&gt;::type</td></tr>
<tr class="separator:a8f77cce220380ae23fa06dbf2181a30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517ab729aaffa516bb92bdffe2a49cb9" id="r_a517ab729aaffa516bb92bdffe2a49cb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a517ab729aaffa516bb92bdffe2a49cb9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a> = typename std::result_of&lt;T&gt;::type</td></tr>
<tr class="separator:a517ab729aaffa516bb92bdffe2a49cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac489beb547551cf305c38d045907535e" id="r_ac489beb547551cf305c38d045907535e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac489beb547551cf305c38d045907535e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac489beb547551cf305c38d045907535e">void_t</a> = typename <a class="el" href="structasio_1_1void__type.html">void_type</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ac489beb547551cf305c38d045907535e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691b4f2369ad1304498c7244449fd47" id="r_a1691b4f2369ad1304498c7244449fd47"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename Type  = int&gt; </td></tr>
<tr class="memitem:a1691b4f2369ad1304498c7244449fd47"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a> = typename <a class="el" href="structasio_1_1constraint.html">constraint</a>&lt;Condition, Type&gt;::type</td></tr>
<tr class="separator:a1691b4f2369ad1304498c7244449fd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf2c6464b70e78b48be535c1dd8087f" id="r_a1bf2c6464b70e78b48be535c1dd8087f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1bf2c6464b70e78b48be535c1dd8087f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1bf2c6464b70e78b48be535c1dd8087f">type_identity_t</a> = typename <a class="el" href="structasio_1_1type__identity.html">type_identity</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a1bf2c6464b70e78b48be535c1dd8087f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae434d49ea968ad09c18f44d08c98aaa4" id="r_ae434d49ea968ad09c18f44d08c98aaa4"><td class="memItemLeft" align="right" valign="top">typedef std::error_category&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae434d49ea968ad09c18f44d08c98aaa4">error_category</a></td></tr>
<tr class="separator:ae434d49ea968ad09c18f44d08c98aaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8914468bc40252ae5e5c666adb951cf" id="r_ac8914468bc40252ae5e5c666adb951cf"><td class="memItemLeft" align="right" valign="top">typedef std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">error_code</a></td></tr>
<tr class="separator:ac8914468bc40252ae5e5c666adb951cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62851a86dfa77e72fd80d2e6ccab76f" id="r_ac62851a86dfa77e72fd80d2e6ccab76f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::high_resolution_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac62851a86dfa77e72fd80d2e6ccab76f">high_resolution_timer</a></td></tr>
<tr class="memdesc:ac62851a86dfa77e72fd80d2e6ccab76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the high resolution clock.  <br /></td></tr>
<tr class="separator:ac62851a86dfa77e72fd80d2e6ccab76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8904bd25ca421af4140ab7ac95b0b956" id="r_a8904bd25ca421af4140ab7ac95b0b956"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1io__context.html">io_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8904bd25ca421af4140ab7ac95b0b956">io_service</a></td></tr>
<tr class="memdesc:a8904bd25ca421af4140ab7ac95b0b956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for backwards compatibility.  <br /></td></tr>
<tr class="separator:a8904bd25ca421af4140ab7ac95b0b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55201409b23036671550beeb6cc3b94e" id="r_a55201409b23036671550beeb6cc3b94e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio__prefer__fn_1_1impl.html">asio_prefer_fn::impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55201409b23036671550beeb6cc3b94e">prefer_t</a></td></tr>
<tr class="separator:a55201409b23036671550beeb6cc3b94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865cee63c722452a345d68610bdde9d7" id="r_a865cee63c722452a345d68610bdde9d7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Properties&gt; </td></tr>
<tr class="memitem:a865cee63c722452a345d68610bdde9d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a865cee63c722452a345d68610bdde9d7">prefer_result_t</a> = typename <a class="el" href="structasio_1_1prefer__result.html">prefer_result</a>&lt;T, Properties...&gt;::type</td></tr>
<tr class="separator:a865cee63c722452a345d68610bdde9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecee0160ad9fd66180683316b4846d4b" id="r_aecee0160ad9fd66180683316b4846d4b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio__query__fn_1_1impl.html">asio_query_fn::impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecee0160ad9fd66180683316b4846d4b">query_t</a></td></tr>
<tr class="separator:aecee0160ad9fd66180683316b4846d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967850c35e079d3459920302a605ddcf" id="r_a967850c35e079d3459920302a605ddcf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Property &gt; </td></tr>
<tr class="memitem:a967850c35e079d3459920302a605ddcf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a967850c35e079d3459920302a605ddcf">query_result_t</a> = typename <a class="el" href="structasio_1_1query__result.html">query_result</a>&lt;T, Property&gt;::type</td></tr>
<tr class="separator:a967850c35e079d3459920302a605ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6bab0c8ad8c073a605675ec7232926" id="r_a0f6bab0c8ad8c073a605675ec7232926"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio__require__fn_1_1impl.html">asio_require_fn::impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f6bab0c8ad8c073a605675ec7232926">require_t</a></td></tr>
<tr class="separator:a0f6bab0c8ad8c073a605675ec7232926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d399d7528dab2f34840c084d1b16e2" id="r_a43d399d7528dab2f34840c084d1b16e2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Properties&gt; </td></tr>
<tr class="memitem:a43d399d7528dab2f34840c084d1b16e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43d399d7528dab2f34840c084d1b16e2">require_result_t</a> = typename <a class="el" href="structasio_1_1require__result.html">require_result</a>&lt;T, Properties...&gt;::type</td></tr>
<tr class="separator:a43d399d7528dab2f34840c084d1b16e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23510e91b2cc59d7d19e64f6a0f0b64f" id="r_a23510e91b2cc59d7d19e64f6a0f0b64f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio__require__concept__fn_1_1impl.html">asio_require_concept_fn::impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23510e91b2cc59d7d19e64f6a0f0b64f">require_concept_t</a></td></tr>
<tr class="separator:a23510e91b2cc59d7d19e64f6a0f0b64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb18173af7457adf90ce0f481f71370" id="r_abcb18173af7457adf90ce0f481f71370"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Property &gt; </td></tr>
<tr class="memitem:abcb18173af7457adf90ce0f481f71370"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abcb18173af7457adf90ce0f481f71370">require_concept_result_t</a></td></tr>
<tr class="separator:abcb18173af7457adf90ce0f481f71370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f135fc124cc60e4e00dc2dbb309f354" id="r_a4f135fc124cc60e4e00dc2dbb309f354"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f135fc124cc60e4e00dc2dbb309f354">signal_set</a></td></tr>
<tr class="memdesc:a4f135fc124cc60e4e00dc2dbb309f354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of a signal set.  <br /></td></tr>
<tr class="separator:a4f135fc124cc60e4e00dc2dbb309f354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b73624bafbe0c55f0da6b594cbc886" id="r_a09b73624bafbe0c55f0da6b594cbc886"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; <a class="el" href="classasio_1_1any__io__executor.html">any_io_executor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a></td></tr>
<tr class="separator:a09b73624bafbe0c55f0da6b594cbc886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97767413ad2526e9941d17f112b5018" id="r_af97767413ad2526e9941d17f112b5018"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1thread__pool.html">thread_pool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af97767413ad2526e9941d17f112b5018">static_thread_pool</a></td></tr>
<tr class="separator:af97767413ad2526e9941d17f112b5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627a7abd2bc87969838f17e46b8dc20d" id="r_a627a7abd2bc87969838f17e46b8dc20d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::steady_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a627a7abd2bc87969838f17e46b8dc20d">steady_timer</a></td></tr>
<tr class="memdesc:a627a7abd2bc87969838f17e46b8dc20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the steady clock.  <br /></td></tr>
<tr class="separator:a627a7abd2bc87969838f17e46b8dc20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7ba348943527312eeace3492bf32ee" id="r_a6a7ba348943527312eeace3492bf32ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a7ba348943527312eeace3492bf32ee">streambuf</a></td></tr>
<tr class="memdesc:a6a7ba348943527312eeace3492bf32ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a>.  <br /></td></tr>
<tr class="separator:a6a7ba348943527312eeace3492bf32ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e0b6db67d52eba50e168ae78c1a049" id="r_ac5e0b6db67d52eba50e168ae78c1a049"><td class="memItemLeft" align="right" valign="top">typedef std::system_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">system_error</a></td></tr>
<tr class="separator:ac5e0b6db67d52eba50e168ae78c1a049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afc37336b3232b8b291ab23e98a9201" id="r_a9afc37336b3232b8b291ab23e98a9201"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__system__executor.html">basic_system_executor</a>&lt; <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#a0ee9cc739b3b11aa5a584a4310a47e22">execution::blocking_t::possibly_t</a>, <a class="el" href="structasio_1_1execution_1_1detail_1_1relationship__t.html#ad59f7aede6089578c4505b171e27369b">execution::relationship_t::fork_t</a>, std::allocator&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9afc37336b3232b8b291ab23e98a9201">system_executor</a></td></tr>
<tr class="memdesc:a9afc37336b3232b8b291ab23e98a9201"><td class="mdescLeft">&#160;</td><td class="mdescRight">An executor that uses arbitrary threads.  <br /></td></tr>
<tr class="separator:a9afc37336b3232b8b291ab23e98a9201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d65c694154683a53496180854859975" id="r_a2d65c694154683a53496180854859975"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::system_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d65c694154683a53496180854859975">system_timer</a></td></tr>
<tr class="memdesc:a2d65c694154683a53496180854859975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the system clock.  <br /></td></tr>
<tr class="separator:a2d65c694154683a53496180854859975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae02aa651224af4b25dc476fc01ce29f6" id="r_ae02aa651224af4b25dc476fc01ce29f6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type</a> : unsigned int { <br />
&#160;&#160;<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">terminal</a> = 1
, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">partial</a> = 2
, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e">total</a> = 4
, <br />
&#160;&#160;<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aa181a603769c1f98ad927e7367c7aa51">all</a> = 0xFFFFFFFF
<br />
 }</td></tr>
<tr class="separator:ae02aa651224af4b25dc476fc01ce29f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9197ee6666dda52782ac7ad94cb85032" id="r_a9197ee6666dda52782ac7ad94cb85032"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename... Values&gt; </td></tr>
<tr class="memitem:a9197ee6666dda52782ac7ad94cb85032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> constexpr <a class="el" href="classasio_1_1append__t.html">append_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Values &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9197ee6666dda52782ac7ad94cb85032">append</a> (CompletionToken &amp;&amp;completion_token, Values &amp;&amp;... values)</td></tr>
<tr class="separator:a9197ee6666dda52782ac7ad94cb85032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811ede45b709fd7686e42bfee42c057d" id="r_a811ede45b709fd7686e42bfee42c057d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a811ede45b709fd7686e42bfee42c057d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a811ede45b709fd7686e42bfee42c057d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated allocator.  <br /></td></tr>
<tr class="separator:a811ede45b709fd7686e42bfee42c057d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c18a9b1d0d55eb89746a4c0e679345" id="r_a82c18a9b1d0d55eb89746a4c0e679345"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a82c18a9b1d0d55eb89746a4c0e679345"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82c18a9b1d0d55eb89746a4c0e679345">get_associated_allocator</a> (const T &amp;t, const Allocator &amp;<a class="el" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>) noexcept -&gt; decltype(<a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; T, Allocator &gt;::get(t, <a class="el" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>))</td></tr>
<tr class="memdesc:a82c18a9b1d0d55eb89746a4c0e679345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated allocator.  <br /></td></tr>
<tr class="separator:a82c18a9b1d0d55eb89746a4c0e679345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877d182f3515b5768c7bc6b8560c3345" id="r_a877d182f3515b5768c7bc6b8560c3345"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a877d182f3515b5768c7bc6b8560c3345"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a877d182f3515b5768c7bc6b8560c3345">get_associated_cancellation_slot</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a877d182f3515b5768c7bc6b8560c3345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a>.  <br /></td></tr>
<tr class="separator:a877d182f3515b5768c7bc6b8560c3345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ba7c6fbf3206e8f4fbc64bc69c5644" id="r_a69ba7c6fbf3206e8f4fbc64bc69c5644"><td class="memTemplParams" colspan="2">template&lt;typename T , typename CancellationSlot &gt; </td></tr>
<tr class="memitem:a69ba7c6fbf3206e8f4fbc64bc69c5644"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69ba7c6fbf3206e8f4fbc64bc69c5644">get_associated_cancellation_slot</a> (const T &amp;t, const CancellationSlot &amp;st) noexcept -&gt; decltype(<a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt; T, CancellationSlot &gt;::get(t, st))</td></tr>
<tr class="memdesc:a69ba7c6fbf3206e8f4fbc64bc69c5644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a>.  <br /></td></tr>
<tr class="separator:a69ba7c6fbf3206e8f4fbc64bc69c5644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3903c51139fd81095f65dde896a4342a" id="r_a3903c51139fd81095f65dde896a4342a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3903c51139fd81095f65dde896a4342a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3903c51139fd81095f65dde896a4342a">get_associated_executor</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a3903c51139fd81095f65dde896a4342a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <br /></td></tr>
<tr class="separator:a3903c51139fd81095f65dde896a4342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f3ac3ddba1f3274b26dcb8f4b8c6f6" id="r_ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0f3ac3ddba1f3274b26dcb8f4b8c6f6">get_associated_executor</a> (const T &amp;t, const Executor &amp;ex, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0) noexcept -&gt; decltype(<a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, Executor &gt;::get(t, ex))</td></tr>
<tr class="memdesc:ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <br /></td></tr>
<tr class="separator:ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69838843d4aeddd379614f0e6eb2c67" id="r_af69838843d4aeddd379614f0e6eb2c67"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:af69838843d4aeddd379614f0e6eb2c67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, typenameExecutionContext::executor_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af69838843d4aeddd379614f0e6eb2c67">get_associated_executor</a> (const T &amp;t, ExecutionContext &amp;ctx, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:af69838843d4aeddd379614f0e6eb2c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <br /></td></tr>
<tr class="separator:af69838843d4aeddd379614f0e6eb2c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754bcbf3e3c8b84637a949642a35e03b" id="r_a754bcbf3e3c8b84637a949642a35e03b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:a754bcbf3e3c8b84637a949642a35e03b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a754bcbf3e3c8b84637a949642a35e03b">get_associated_immediate_executor</a> (const T &amp;t, const Executor &amp;ex, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0) noexcept -&gt; decltype(<a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt; T, Executor &gt;::get(t, ex))</td></tr>
<tr class="memdesc:a754bcbf3e3c8b84637a949642a35e03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <br /></td></tr>
<tr class="separator:a754bcbf3e3c8b84637a949642a35e03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6affbf42afc0af12992946d9d5d4a6" id="r_adc6affbf42afc0af12992946d9d5d4a6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:adc6affbf42afc0af12992946d9d5d4a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt; T, typenameExecutionContext::executor_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc6affbf42afc0af12992946d9d5d4a6">get_associated_immediate_executor</a> (const T &amp;t, ExecutionContext &amp;ctx, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:adc6affbf42afc0af12992946d9d5d4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <br /></td></tr>
<tr class="separator:adc6affbf42afc0af12992946d9d5d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2209de8d875481208ea96c76c1c49e4" id="r_ab2209de8d875481208ea96c76c1c49e4"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , ASIO_COMPLETION_SIGNATURE... Signatures, typename Initiation , typename... Args&gt; </td></tr>
<tr class="memitem:ab2209de8d875481208ea96c76c1c49e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a> (Initiation &amp;&amp;initiation, <a class="el" href="#a1bf2c6464b70e78b48be535c1dd8087f">type_identity_t</a>&lt; CompletionToken &gt; &amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, Args &amp;&amp;... args) -&gt; decltype(<a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt; <a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt; <a class="el" href="structasio_1_1detail_1_1are__completion__signatures.html">detail::are_completion_signatures</a>&lt; Signatures... &gt;::value, <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures... &gt; &gt;::value, <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Signatures... &gt; &gt;::initiate(static_cast&lt; Initiation &amp;&amp; &gt;(initiation), static_cast&lt; CompletionToken &amp;&amp; &gt;(<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>), static_cast&lt; Args &amp;&amp; &gt;(args)...))</td></tr>
<tr class="separator:ab2209de8d875481208ea96c76c1c49e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9d86f999339de90ea243a750f1fff6" id="r_a4b9d86f999339de90ea243a750f1fff6"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_SIGNATURE... Signatures, typename CompletionToken , typename Initiation , typename... Args&gt; </td></tr>
<tr class="memitem:a4b9d86f999339de90ea243a750f1fff6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b9d86f999339de90ea243a750f1fff6">async_initiate</a> (Initiation &amp;&amp;initiation, CompletionToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, Args &amp;&amp;... args) -&gt; decltype(<a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt; <a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt; <a class="el" href="structasio_1_1detail_1_1are__completion__signatures.html">detail::are_completion_signatures</a>&lt; Signatures... &gt;::value, <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures... &gt; &gt;::value, <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Signatures... &gt; &gt;::initiate(static_cast&lt; Initiation &amp;&amp; &gt;(initiation), static_cast&lt; CompletionToken &amp;&amp; &gt;(<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>), static_cast&lt; Args &amp;&amp; &gt;(args)...))</td></tr>
<tr class="separator:a4b9d86f999339de90ea243a750f1fff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60102965258cfdce4bffa138efdd348e" id="r_a60102965258cfdce4bffa138efdd348e"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , ASIO_COMPLETION_SIGNATURE... Signatures, typename Initiation , typename... Args&gt; </td></tr>
<tr class="memitem:a60102965258cfdce4bffa138efdd348e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt;!<a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt; <a class="el" href="structasio_1_1detail_1_1are__completion__signatures.html">detail::are_completion_signatures</a>&lt; Signatures... &gt;::value, <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures... &gt; &gt;::value, <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Signatures... &gt; &gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60102965258cfdce4bffa138efdd348e">async_initiate</a> (Initiation &amp;&amp;initiation, <a class="el" href="#a1bf2c6464b70e78b48be535c1dd8087f">type_identity_t</a>&lt; CompletionToken &gt; &amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a60102965258cfdce4bffa138efdd348e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffaf73c9ee9ab21b6730aaf0839d73e" id="r_a8ffaf73c9ee9ab21b6730aaf0839d73e"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_SIGNATURE... Signatures, typename CompletionToken , typename Initiation , typename... Args&gt; </td></tr>
<tr class="memitem:a8ffaf73c9ee9ab21b6730aaf0839d73e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt;!<a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt; <a class="el" href="structasio_1_1detail_1_1are__completion__signatures.html">detail::are_completion_signatures</a>&lt; Signatures... &gt;::value, <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures... &gt; &gt;::value, <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Signatures... &gt; &gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ffaf73c9ee9ab21b6730aaf0839d73e">async_initiate</a> (Initiation &amp;&amp;initiation, CompletionToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a8ffaf73c9ee9ab21b6730aaf0839d73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eac0f8769eefb8a4e053af0331fdc2" id="r_a98eac0f8769eefb8a4e053af0331fdc2"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a98eac0f8769eefb8a4e053af0331fdc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__allocator__binder.html">partial_allocator_binder</a>&lt; Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a98eac0f8769eefb8a4e053af0331fdc2">bind_allocator</a> (const Allocator &amp;ex)</td></tr>
<tr class="memdesc:a98eac0f8769eefb8a4e053af0331fdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial completion token that associates an allocator.  <br /></td></tr>
<tr class="separator:a98eac0f8769eefb8a4e053af0331fdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6873210f37c06a1da52cf61bb8e0a5fd" id="r_a6873210f37c06a1da52cf61bb8e0a5fd"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename T &gt; </td></tr>
<tr class="memitem:a6873210f37c06a1da52cf61bb8e0a5fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1allocator__binder.html">allocator_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6873210f37c06a1da52cf61bb8e0a5fd">bind_allocator</a> (const Allocator &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, T &amp;&amp;t)</td></tr>
<tr class="separator:a6873210f37c06a1da52cf61bb8e0a5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea42498f5edae0a0794894ba2ed21943" id="r_aea42498f5edae0a0794894ba2ed21943"><td class="memTemplParams" colspan="2">template&lt;typename CancellationSlot &gt; </td></tr>
<tr class="memitem:aea42498f5edae0a0794894ba2ed21943"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__cancellation__slot__binder.html">partial_cancellation_slot_binder</a>&lt; CancellationSlot &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea42498f5edae0a0794894ba2ed21943">bind_cancellation_slot</a> (const CancellationSlot &amp;ex)</td></tr>
<tr class="memdesc:aea42498f5edae0a0794894ba2ed21943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial completion token that associates a cancellation slot.  <br /></td></tr>
<tr class="separator:aea42498f5edae0a0794894ba2ed21943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03eb972eeb2205c02024c6b1b6ec900" id="r_aa03eb972eeb2205c02024c6b1b6ec900"><td class="memTemplParams" colspan="2">template&lt;typename CancellationSlot , typename T &gt; </td></tr>
<tr class="memitem:aa03eb972eeb2205c02024c6b1b6ec900"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancellation__slot__binder.html">cancellation_slot_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, CancellationSlot &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa03eb972eeb2205c02024c6b1b6ec900">bind_cancellation_slot</a> (const CancellationSlot &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, T &amp;&amp;t)</td></tr>
<tr class="separator:aa03eb972eeb2205c02024c6b1b6ec900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a5bbf9f5cfd6b2487b24188ac267e1" id="r_af7a5bbf9f5cfd6b2487b24188ac267e1"><td class="memTemplParams" colspan="2">template&lt;typename Executor &gt; </td></tr>
<tr class="memitem:af7a5bbf9f5cfd6b2487b24188ac267e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__executor__binder.html">partial_executor_binder</a>&lt; Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7a5bbf9f5cfd6b2487b24188ac267e1">bind_executor</a> (const Executor &amp;ex, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:af7a5bbf9f5cfd6b2487b24188ac267e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial completion token that associates an executor.  <br /></td></tr>
<tr class="separator:af7a5bbf9f5cfd6b2487b24188ac267e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4753991b2abb85968b93d956cccdedb" id="r_af4753991b2abb85968b93d956cccdedb"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename T &gt; </td></tr>
<tr class="memitem:af4753991b2abb85968b93d956cccdedb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4753991b2abb85968b93d956cccdedb">bind_executor</a> (const Executor &amp;ex, T &amp;&amp;t, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:af4753991b2abb85968b93d956cccdedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an object of type <code>T</code> with an executor of type <code>Executor</code>.  <br /></td></tr>
<tr class="separator:af4753991b2abb85968b93d956cccdedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea54c730a26b96924b64fbb557282a3e" id="r_aea54c730a26b96924b64fbb557282a3e"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:aea54c730a26b96924b64fbb557282a3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__executor__binder.html">partial_executor_binder</a>&lt; typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea54c730a26b96924b64fbb557282a3e">bind_executor</a> (ExecutionContext &amp;ctx, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="separator:aea54c730a26b96924b64fbb557282a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842643dcfed065d8a99de34575e5a0e1" id="r_a842643dcfed065d8a99de34575e5a0e1"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename T &gt; </td></tr>
<tr class="memitem:a842643dcfed065d8a99de34575e5a0e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a842643dcfed065d8a99de34575e5a0e1">bind_executor</a> (ExecutionContext &amp;ctx, T &amp;&amp;t, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a842643dcfed065d8a99de34575e5a0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an object of type <code>T</code> with an execution context's executor.  <br /></td></tr>
<tr class="separator:a842643dcfed065d8a99de34575e5a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a16fd72a8c7adcb9f00666e1291b8cc" id="r_a6a16fd72a8c7adcb9f00666e1291b8cc"><td class="memTemplParams" colspan="2">template&lt;typename Executor &gt; </td></tr>
<tr class="memitem:a6a16fd72a8c7adcb9f00666e1291b8cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__immediate__executor__binder.html">partial_immediate_executor_binder</a>&lt; Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a16fd72a8c7adcb9f00666e1291b8cc">bind_immediate_executor</a> (const Executor &amp;ex)</td></tr>
<tr class="memdesc:a6a16fd72a8c7adcb9f00666e1291b8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial completion token that associates an executor.  <br /></td></tr>
<tr class="separator:a6a16fd72a8c7adcb9f00666e1291b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb335b2d8b9d84fb5f21ee1bca79287" id="r_afdb335b2d8b9d84fb5f21ee1bca79287"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename T &gt; </td></tr>
<tr class="memitem:afdb335b2d8b9d84fb5f21ee1bca79287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1immediate__executor__binder.html">immediate_executor_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdb335b2d8b9d84fb5f21ee1bca79287">bind_immediate_executor</a> (const Executor &amp;e, T &amp;&amp;t)</td></tr>
<tr class="separator:afdb335b2d8b9d84fb5f21ee1bca79287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e0bcfde373158541e95fc70d778a83" id="r_a17e0bcfde373158541e95fc70d778a83"><td class="memTemplParams" colspan="2">template&lt;typename MutableBuffer &gt; </td></tr>
<tr class="memitem:a17e0bcfde373158541e95fc70d778a83"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17e0bcfde373158541e95fc70d778a83">buffer_sequence_begin</a> (const MutableBuffer &amp;b, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; const MutableBuffer *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:a17e0bcfde373158541e95fc70d778a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <br /></td></tr>
<tr class="separator:a17e0bcfde373158541e95fc70d778a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5379d7d15e3bba2686bb4ae4501cf0" id="r_aba5379d7d15e3bba2686bb4ae4501cf0"><td class="memTemplParams" colspan="2">template&lt;typename ConstBuffer &gt; </td></tr>
<tr class="memitem:aba5379d7d15e3bba2686bb4ae4501cf0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba5379d7d15e3bba2686bb4ae4501cf0">buffer_sequence_begin</a> (const ConstBuffer &amp;b, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; const ConstBuffer *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:aba5379d7d15e3bba2686bb4ae4501cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <br /></td></tr>
<tr class="separator:aba5379d7d15e3bba2686bb4ae4501cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcd07567a0f9eeaacd8bd0b08689e80" id="r_afbcd07567a0f9eeaacd8bd0b08689e80"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:afbcd07567a0f9eeaacd8bd0b08689e80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbcd07567a0f9eeaacd8bd0b08689e80">buffer_sequence_begin</a> (C &amp;c, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:afbcd07567a0f9eeaacd8bd0b08689e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <br /></td></tr>
<tr class="separator:afbcd07567a0f9eeaacd8bd0b08689e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1288ea04d255a07a8050e8016b554d0b" id="r_a1288ea04d255a07a8050e8016b554d0b"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a1288ea04d255a07a8050e8016b554d0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1288ea04d255a07a8050e8016b554d0b">buffer_sequence_begin</a> (const C &amp;c, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:a1288ea04d255a07a8050e8016b554d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <br /></td></tr>
<tr class="separator:a1288ea04d255a07a8050e8016b554d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a21227870fa0ff7261f8c452dc83fd" id="r_a95a21227870fa0ff7261f8c452dc83fd"><td class="memTemplParams" colspan="2">template&lt;typename MutableBuffer &gt; </td></tr>
<tr class="memitem:a95a21227870fa0ff7261f8c452dc83fd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a95a21227870fa0ff7261f8c452dc83fd">buffer_sequence_end</a> (const MutableBuffer &amp;b, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; const MutableBuffer *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:a95a21227870fa0ff7261f8c452dc83fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <br /></td></tr>
<tr class="separator:a95a21227870fa0ff7261f8c452dc83fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6000fe4e6f28afe90848ce314b6f4ba9" id="r_a6000fe4e6f28afe90848ce314b6f4ba9"><td class="memTemplParams" colspan="2">template&lt;typename ConstBuffer &gt; </td></tr>
<tr class="memitem:a6000fe4e6f28afe90848ce314b6f4ba9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6000fe4e6f28afe90848ce314b6f4ba9">buffer_sequence_end</a> (const ConstBuffer &amp;b, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; const ConstBuffer *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:a6000fe4e6f28afe90848ce314b6f4ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <br /></td></tr>
<tr class="separator:a6000fe4e6f28afe90848ce314b6f4ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe41182ab29c34a81752396b25ba0d1a" id="r_afe41182ab29c34a81752396b25ba0d1a"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:afe41182ab29c34a81752396b25ba0d1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe41182ab29c34a81752396b25ba0d1a">buffer_sequence_end</a> (C &amp;c, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:afe41182ab29c34a81752396b25ba0d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <br /></td></tr>
<tr class="separator:afe41182ab29c34a81752396b25ba0d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a057966e62697d09cafab0009eda0e" id="r_ab7a057966e62697d09cafab0009eda0e"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ab7a057966e62697d09cafab0009eda0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7a057966e62697d09cafab0009eda0e">buffer_sequence_end</a> (const C &amp;c, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:ab7a057966e62697d09cafab0009eda0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <br /></td></tr>
<tr class="separator:ab7a057966e62697d09cafab0009eda0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ffb00a82a2cb0dcbb976e02d82cc79" id="r_a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32ffb00a82a2cb0dcbb976e02d82cc79">buffer_size</a> (const BufferSequence &amp;b) noexcept</td></tr>
<tr class="memdesc:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of bytes in a buffer sequence.  <br /></td></tr>
<tr class="separator:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8365a4bf9ba53918c758263fd3b0fb36" id="r_a8365a4bf9ba53918c758263fd3b0fb36"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType &gt; </td></tr>
<tr class="memitem:a8365a4bf9ba53918c758263fd3b0fb36"><td class="memTemplItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8365a4bf9ba53918c758263fd3b0fb36">buffer_cast</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a8365a4bf9ba53918c758263fd3b0fb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <br /></td></tr>
<tr class="separator:a8365a4bf9ba53918c758263fd3b0fb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240b9552e7e1deb855c98e11583b88a5" id="r_a240b9552e7e1deb855c98e11583b88a5"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType &gt; </td></tr>
<tr class="memitem:a240b9552e7e1deb855c98e11583b88a5"><td class="memTemplItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a240b9552e7e1deb855c98e11583b88a5">buffer_cast</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a240b9552e7e1deb855c98e11583b88a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <br /></td></tr>
<tr class="separator:a240b9552e7e1deb855c98e11583b88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af691d016b23fd6c2da9ac91ce00c2e7e" id="r_af691d016b23fd6c2da9ac91ce00c2e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af691d016b23fd6c2da9ac91ce00c2e7e">buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:af691d016b23fd6c2da9ac91ce00c2e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <br /></td></tr>
<tr class="separator:af691d016b23fd6c2da9ac91ce00c2e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4a73cd878cb3ce83da935fb9932f23" id="r_a2b4a73cd878cb3ce83da935fb9932f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b4a73cd878cb3ce83da935fb9932f23">buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a2b4a73cd878cb3ce83da935fb9932f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <br /></td></tr>
<tr class="separator:a2b4a73cd878cb3ce83da935fb9932f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2c9f5266bd40548109072a006bd4db" id="r_a3e2c9f5266bd40548109072a006bd4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2c9f5266bd40548109072a006bd4db">buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a3e2c9f5266bd40548109072a006bd4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <br /></td></tr>
<tr class="separator:a3e2c9f5266bd40548109072a006bd4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e22c4da973f9cec891970c007ea8a7b" id="r_a8e22c4da973f9cec891970c007ea8a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e22c4da973f9cec891970c007ea8a7b">buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a8e22c4da973f9cec891970c007ea8a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <br /></td></tr>
<tr class="separator:a8e22c4da973f9cec891970c007ea8a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390401d56dbdf838be8a09ec7ce4d4d4" id="r_a390401d56dbdf838be8a09ec7ce4d4d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a390401d56dbdf838be8a09ec7ce4d4d4">buffer</a> (void *data, std::size_t size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a390401d56dbdf838be8a09ec7ce4d4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <br /></td></tr>
<tr class="separator:a390401d56dbdf838be8a09ec7ce4d4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609e222330f06ff048c78d40431953e5" id="r_a609e222330f06ff048c78d40431953e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a609e222330f06ff048c78d40431953e5">buffer</a> (const void *data, std::size_t size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a609e222330f06ff048c78d40431953e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <br /></td></tr>
<tr class="separator:a609e222330f06ff048c78d40431953e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddf466e8044ce08813fc66d4097d213" id="r_a4ddf466e8044ce08813fc66d4097d213"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a4ddf466e8044ce08813fc66d4097d213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ddf466e8044ce08813fc66d4097d213">buffer</a> (PodType(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:a4ddf466e8044ce08813fc66d4097d213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:a4ddf466e8044ce08813fc66d4097d213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a0a6ae44a23ca25b1836da782cd616" id="r_a56a0a6ae44a23ca25b1836da782cd616"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a56a0a6ae44a23ca25b1836da782cd616"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56a0a6ae44a23ca25b1836da782cd616">buffer</a> (PodType(&amp;data)[N], std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a56a0a6ae44a23ca25b1836da782cd616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:a56a0a6ae44a23ca25b1836da782cd616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2b1693298fb564b28c7440eff1774e" id="r_a1f2b1693298fb564b28c7440eff1774e"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a1f2b1693298fb564b28c7440eff1774e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f2b1693298fb564b28c7440eff1774e">buffer</a> (const PodType(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:a1f2b1693298fb564b28c7440eff1774e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:a1f2b1693298fb564b28c7440eff1774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b5df59bccdd5b06f8d93416472105c" id="r_a66b5df59bccdd5b06f8d93416472105c"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a66b5df59bccdd5b06f8d93416472105c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66b5df59bccdd5b06f8d93416472105c">buffer</a> (const PodType(&amp;data)[N], std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a66b5df59bccdd5b06f8d93416472105c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:a66b5df59bccdd5b06f8d93416472105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a0ab72797048aa4629781e650d65e" id="r_a8e6a0ab72797048aa4629781e650d65e"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a8e6a0ab72797048aa4629781e650d65e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e6a0ab72797048aa4629781e650d65e">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a8e6a0ab72797048aa4629781e650d65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:a8e6a0ab72797048aa4629781e650d65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b80f670c5f74b5402342f87fd9d28" id="r_af92b80f670c5f74b5402342f87fd9d28"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:af92b80f670c5f74b5402342f87fd9d28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af92b80f670c5f74b5402342f87fd9d28">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:af92b80f670c5f74b5402342f87fd9d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:af92b80f670c5f74b5402342f87fd9d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2e76bbc8d686f8c816fe49873a4666" id="r_a0a2e76bbc8d686f8c816fe49873a4666"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a0a2e76bbc8d686f8c816fe49873a4666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a2e76bbc8d686f8c816fe49873a4666">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a0a2e76bbc8d686f8c816fe49873a4666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:a0a2e76bbc8d686f8c816fe49873a4666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c6a9bbe7e9cba49430d37caae476cd" id="r_a00c6a9bbe7e9cba49430d37caae476cd"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a00c6a9bbe7e9cba49430d37caae476cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00c6a9bbe7e9cba49430d37caae476cd">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a00c6a9bbe7e9cba49430d37caae476cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:a00c6a9bbe7e9cba49430d37caae476cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da2efeb42c04e368055e1b5f7780132" id="r_a5da2efeb42c04e368055e1b5f7780132"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a5da2efeb42c04e368055e1b5f7780132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5da2efeb42c04e368055e1b5f7780132">buffer</a> (std::array&lt; PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a5da2efeb42c04e368055e1b5f7780132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:a5da2efeb42c04e368055e1b5f7780132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff494b6b08d0ae82723ec370cd91d39a" id="r_aff494b6b08d0ae82723ec370cd91d39a"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:aff494b6b08d0ae82723ec370cd91d39a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff494b6b08d0ae82723ec370cd91d39a">buffer</a> (std::array&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:aff494b6b08d0ae82723ec370cd91d39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:aff494b6b08d0ae82723ec370cd91d39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa3e7d25d0f90000eebc400c02dfbf0" id="r_adfa3e7d25d0f90000eebc400c02dfbf0"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:adfa3e7d25d0f90000eebc400c02dfbf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfa3e7d25d0f90000eebc400c02dfbf0">buffer</a> (std::array&lt; const PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:adfa3e7d25d0f90000eebc400c02dfbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:adfa3e7d25d0f90000eebc400c02dfbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f602fab6a887916ee3aac0769dc46a" id="r_ae1f602fab6a887916ee3aac0769dc46a"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ae1f602fab6a887916ee3aac0769dc46a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae1f602fab6a887916ee3aac0769dc46a">buffer</a> (std::array&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ae1f602fab6a887916ee3aac0769dc46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="separator:ae1f602fab6a887916ee3aac0769dc46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84688fa20c384874e1eddf5c81d8c331" id="r_a84688fa20c384874e1eddf5c81d8c331"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:a84688fa20c384874e1eddf5c81d8c331"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a84688fa20c384874e1eddf5c81d8c331">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a84688fa20c384874e1eddf5c81d8c331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <br /></td></tr>
<tr class="separator:a84688fa20c384874e1eddf5c81d8c331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af717cc04e6415768402160b063ec6202" id="r_af717cc04e6415768402160b063ec6202"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:af717cc04e6415768402160b063ec6202"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af717cc04e6415768402160b063ec6202">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:af717cc04e6415768402160b063ec6202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <br /></td></tr>
<tr class="separator:af717cc04e6415768402160b063ec6202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d16f55d0457afe5971519eafa4f2b2" id="r_a32d16f55d0457afe5971519eafa4f2b2"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:a32d16f55d0457afe5971519eafa4f2b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32d16f55d0457afe5971519eafa4f2b2">buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a32d16f55d0457afe5971519eafa4f2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <br /></td></tr>
<tr class="separator:a32d16f55d0457afe5971519eafa4f2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8958d330420418a8ca049279026dc3f" id="r_aa8958d330420418a8ca049279026dc3f"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:aa8958d330420418a8ca049279026dc3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8958d330420418a8ca049279026dc3f">buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:aa8958d330420418a8ca049279026dc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <br /></td></tr>
<tr class="separator:aa8958d330420418a8ca049279026dc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691ba65873879c5541119faff29aa0f4" id="r_a691ba65873879c5541119faff29aa0f4"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a691ba65873879c5541119faff29aa0f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a691ba65873879c5541119faff29aa0f4">buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a691ba65873879c5541119faff29aa0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string.  <br /></td></tr>
<tr class="separator:a691ba65873879c5541119faff29aa0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc4d596625f545097450584d532a71e" id="r_a1dc4d596625f545097450584d532a71e"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a1dc4d596625f545097450584d532a71e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1dc4d596625f545097450584d532a71e">buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a1dc4d596625f545097450584d532a71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string.  <br /></td></tr>
<tr class="separator:a1dc4d596625f545097450584d532a71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28b3f525cd9132dde4eceff0d1c8611" id="r_ac28b3f525cd9132dde4eceff0d1c8611"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ac28b3f525cd9132dde4eceff0d1c8611"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac28b3f525cd9132dde4eceff0d1c8611">buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ac28b3f525cd9132dde4eceff0d1c8611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <br /></td></tr>
<tr class="separator:ac28b3f525cd9132dde4eceff0d1c8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ad05e2147e00fe0019da3b12caac1" id="r_aca8ad05e2147e00fe0019da3b12caac1"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aca8ad05e2147e00fe0019da3b12caac1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca8ad05e2147e00fe0019da3b12caac1">buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:aca8ad05e2147e00fe0019da3b12caac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <br /></td></tr>
<tr class="separator:aca8ad05e2147e00fe0019da3b12caac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3bc2e4b9e6bf8ff64eab08344002aa" id="r_aeb3bc2e4b9e6bf8ff64eab08344002aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb3bc2e4b9e6bf8ff64eab08344002aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb3bc2e4b9e6bf8ff64eab08344002aa">buffer</a> (T &amp;data, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_const&lt; <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:aeb3bc2e4b9e6bf8ff64eab08344002aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from a contiguous container.  <br /></td></tr>
<tr class="separator:aeb3bc2e4b9e6bf8ff64eab08344002aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230a757727dfa8eac34c54df06cf6fa0" id="r_a230a757727dfa8eac34c54df06cf6fa0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a230a757727dfa8eac34c54df06cf6fa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a230a757727dfa8eac34c54df06cf6fa0">buffer</a> (T &amp;data, std::size_t max_size_in_bytes, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_const&lt; <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a230a757727dfa8eac34c54df06cf6fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from a contiguous container.  <br /></td></tr>
<tr class="separator:a230a757727dfa8eac34c54df06cf6fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9025af2d8c7f20168a21c860ce06d2fd" id="r_a9025af2d8c7f20168a21c860ce06d2fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9025af2d8c7f20168a21c860ce06d2fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9025af2d8c7f20168a21c860ce06d2fd">buffer</a> (T &amp;data, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_const&lt; <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a9025af2d8c7f20168a21c860ce06d2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from a contiguous container.  <br /></td></tr>
<tr class="separator:a9025af2d8c7f20168a21c860ce06d2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52644e5a827859367e71ebeafe1a9fca" id="r_a52644e5a827859367e71ebeafe1a9fca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52644e5a827859367e71ebeafe1a9fca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52644e5a827859367e71ebeafe1a9fca">buffer</a> (T &amp;data, std::size_t max_size_in_bytes, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_const&lt; <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a52644e5a827859367e71ebeafe1a9fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from a contiguous container.  <br /></td></tr>
<tr class="separator:a52644e5a827859367e71ebeafe1a9fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df15a068b182e5dbc67e7a9831ac663" id="r_a7df15a068b182e5dbc67e7a9831ac663"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7df15a068b182e5dbc67e7a9831ac663"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7df15a068b182e5dbc67e7a9831ac663">buffer</a> (const T &amp;data, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::const_iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a7df15a068b182e5dbc67e7a9831ac663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from a contiguous container.  <br /></td></tr>
<tr class="separator:a7df15a068b182e5dbc67e7a9831ac663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1725cb81df773d48f415111dc9d66d07" id="r_a1725cb81df773d48f415111dc9d66d07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1725cb81df773d48f415111dc9d66d07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1725cb81df773d48f415111dc9d66d07">buffer</a> (const T &amp;data, std::size_t max_size_in_bytes, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::const_iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a1725cb81df773d48f415111dc9d66d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from a contiguous container.  <br /></td></tr>
<tr class="separator:a1725cb81df773d48f415111dc9d66d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af2c940f947441ddf9aabdc3f330d2" id="r_ae8af2c940f947441ddf9aabdc3f330d2"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ae8af2c940f947441ddf9aabdc3f330d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8af2c940f947441ddf9aabdc3f330d2">dynamic_buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ae8af2c940f947441ddf9aabdc3f330d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given string.  <br /></td></tr>
<tr class="separator:ae8af2c940f947441ddf9aabdc3f330d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa750035aeca47b2576366ce261172618" id="r_aa750035aeca47b2576366ce261172618"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aa750035aeca47b2576366ce261172618"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa750035aeca47b2576366ce261172618">dynamic_buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size) noexcept</td></tr>
<tr class="memdesc:aa750035aeca47b2576366ce261172618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given string.  <br /></td></tr>
<tr class="separator:aa750035aeca47b2576366ce261172618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2215113263af583c61ce8c28bb3b15e" id="r_ac2215113263af583c61ce8c28bb3b15e"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Allocator &gt; </td></tr>
<tr class="memitem:ac2215113263af583c61ce8c28bb3b15e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac2215113263af583c61ce8c28bb3b15e">dynamic_buffer</a> (std::vector&lt; Elem, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ac2215113263af583c61ce8c28bb3b15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given vector.  <br /></td></tr>
<tr class="separator:ac2215113263af583c61ce8c28bb3b15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1701decd6c6a2c330d6e85c7ce98bcce" id="r_a1701decd6c6a2c330d6e85c7ce98bcce"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Allocator &gt; </td></tr>
<tr class="memitem:a1701decd6c6a2c330d6e85c7ce98bcce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1701decd6c6a2c330d6e85c7ce98bcce">dynamic_buffer</a> (std::vector&lt; Elem, Allocator &gt; &amp;data, std::size_t max_size) noexcept</td></tr>
<tr class="memdesc:a1701decd6c6a2c330d6e85c7ce98bcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given vector.  <br /></td></tr>
<tr class="separator:a1701decd6c6a2c330d6e85c7ce98bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab876ca15e1fd4f5f12caa8e0cac327" id="r_a9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ab876ca15e1fd4f5f12caa8e0cac327">buffer_copy</a> (const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source) noexcept</td></tr>
<tr class="memdesc:a9ab876ca15e1fd4f5f12caa8e0cac327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer sequence to a target buffer sequence.  <br /></td></tr>
<tr class="separator:a9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f84f2c9b443140a1b8693c5491ffde4" id="r_a4f84f2c9b443140a1b8693c5491ffde4"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a4f84f2c9b443140a1b8693c5491ffde4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f84f2c9b443140a1b8693c5491ffde4">buffer_copy</a> (const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source, std::size_t max_bytes_to_copy) noexcept</td></tr>
<tr class="separator:a4f84f2c9b443140a1b8693c5491ffde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7c33f5b8301df64b83beeff3313d0f" id="r_a9c7c33f5b8301df64b83beeff3313d0f"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a9c7c33f5b8301df64b83beeff3313d0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c7c33f5b8301df64b83beeff3313d0f">register_buffers</a> (const Executor &amp;ex, const MutableBufferSequence &amp;buffer_sequence, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a9c7c33f5b8301df64b83beeff3313d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffers with an execution context.  <br /></td></tr>
<tr class="separator:a9c7c33f5b8301df64b83beeff3313d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2fee74d508667d6f19d7cb7ea7b8ab" id="r_aab2fee74d508667d6f19d7cb7ea7b8ab"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename MutableBufferSequence , typename Allocator &gt; </td></tr>
<tr class="memitem:aab2fee74d508667d6f19d7cb7ea7b8ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab2fee74d508667d6f19d7cb7ea7b8ab">register_buffers</a> (const Executor &amp;ex, const MutableBufferSequence &amp;buffer_sequence, const Allocator &amp;alloc, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:aab2fee74d508667d6f19d7cb7ea7b8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffers with an execution context.  <br /></td></tr>
<tr class="separator:aab2fee74d508667d6f19d7cb7ea7b8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eefb1ef980d2fd4ff57988ef1a20ac2" id="r_a1eefb1ef980d2fd4ff57988ef1a20ac2"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a1eefb1ef980d2fd4ff57988ef1a20ac2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1eefb1ef980d2fd4ff57988ef1a20ac2">register_buffers</a> (ExecutionContext &amp;ctx, const MutableBufferSequence &amp;buffer_sequence, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a1eefb1ef980d2fd4ff57988ef1a20ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffers with an execution context.  <br /></td></tr>
<tr class="separator:a1eefb1ef980d2fd4ff57988ef1a20ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2e57093cdd5fcf9aa90c234580b023" id="r_a9e2e57093cdd5fcf9aa90c234580b023"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename MutableBufferSequence , typename Allocator &gt; </td></tr>
<tr class="memitem:a9e2e57093cdd5fcf9aa90c234580b023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e2e57093cdd5fcf9aa90c234580b023">register_buffers</a> (ExecutionContext &amp;ctx, const MutableBufferSequence &amp;buffer_sequence, const Allocator &amp;alloc, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a9e2e57093cdd5fcf9aa90c234580b023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffers with an execution context.  <br /></td></tr>
<tr class="separator:a9e2e57093cdd5fcf9aa90c234580b023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e267c80155b2747d041d2932357762" id="r_a42e267c80155b2747d041d2932357762"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a42e267c80155b2747d041d2932357762"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42e267c80155b2747d041d2932357762">buffers_begin</a> (const BufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a42e267c80155b2747d041d2932357762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the beginning of the buffers' data.  <br /></td></tr>
<tr class="separator:a42e267c80155b2747d041d2932357762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c586f56452e13b3798ae1925bd35595" id="r_a1c586f56452e13b3798ae1925bd35595"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a1c586f56452e13b3798ae1925bd35595"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c586f56452e13b3798ae1925bd35595">buffers_end</a> (const BufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a1c586f56452e13b3798ae1925bd35595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the end of the buffers' data.  <br /></td></tr>
<tr class="separator:a1c586f56452e13b3798ae1925bd35595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49286c4e58bf3276fb1b5520c324a989" id="r_a49286c4e58bf3276fb1b5520c324a989"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a49286c4e58bf3276fb1b5520c324a989"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__cancel__after.html">partial_cancel_after</a>&lt; chrono::steady_clock &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49286c4e58bf3276fb1b5520c324a989">cancel_after</a> (const chrono::duration&lt; Rep, Period &gt; &amp;timeout, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> cancel_type=<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>)</td></tr>
<tr class="separator:a49286c4e58bf3276fb1b5520c324a989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d74bcfbaf070baec84be8495c338808" id="r_a3d74bcfbaf070baec84be8495c338808"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename WaitTraits , typename Executor , typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a3d74bcfbaf070baec84be8495c338808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__cancel__after__timer.html">partial_cancel_after_timer</a>&lt; Clock, WaitTraits, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d74bcfbaf070baec84be8495c338808">cancel_after</a> (<a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;<a class="el" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>, const chrono::duration&lt; Rep, Period &gt; &amp;timeout, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> cancel_type=<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>)</td></tr>
<tr class="separator:a3d74bcfbaf070baec84be8495c338808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724d3f5c4f9b3fb6c1cc993340b8eb4" id="r_a4724d3f5c4f9b3fb6c1cc993340b8eb4"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a4724d3f5c4f9b3fb6c1cc993340b8eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__after__t.html">cancel_after_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, chrono::steady_clock &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4724d3f5c4f9b3fb6c1cc993340b8eb4">cancel_after</a> (const chrono::duration&lt; Rep, Period &gt; &amp;timeout, CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:a4724d3f5c4f9b3fb6c1cc993340b8eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13770f033d42f095f9ea50974d8500ef" id="r_a13770f033d42f095f9ea50974d8500ef"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a13770f033d42f095f9ea50974d8500ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__after__t.html">cancel_after_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, chrono::steady_clock &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13770f033d42f095f9ea50974d8500ef">cancel_after</a> (const chrono::duration&lt; Rep, Period &gt; &amp;timeout, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> cancel_type, CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:a13770f033d42f095f9ea50974d8500ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712cef0b8cfcc8d2ddeeeb9caf450756" id="r_a712cef0b8cfcc8d2ddeeeb9caf450756"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename WaitTraits , typename Executor , typename Rep , typename Period , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a712cef0b8cfcc8d2ddeeeb9caf450756"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__after__timer.html">cancel_after_timer</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock, WaitTraits, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a712cef0b8cfcc8d2ddeeeb9caf450756">cancel_after</a> (<a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;<a class="el" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>, const chrono::duration&lt; Rep, Period &gt; &amp;timeout, CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:a712cef0b8cfcc8d2ddeeeb9caf450756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd64d454a700ebaf2e3700e78f78bbc" id="r_a4dd64d454a700ebaf2e3700e78f78bbc"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename WaitTraits , typename Executor , typename Rep , typename Period , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a4dd64d454a700ebaf2e3700e78f78bbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__after__timer.html">cancel_after_timer</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, chrono::steady_clock &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4dd64d454a700ebaf2e3700e78f78bbc">cancel_after</a> (<a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;<a class="el" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>, const chrono::duration&lt; Rep, Period &gt; &amp;timeout, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> cancel_type, CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:a4dd64d454a700ebaf2e3700e78f78bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeeba97e9f7bc2a799b364155e91489" id="r_aaeeeba97e9f7bc2a799b364155e91489"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:aaeeeba97e9f7bc2a799b364155e91489"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__cancel__at.html">partial_cancel_at</a>&lt; Clock &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaeeeba97e9f7bc2a799b364155e91489">cancel_at</a> (const chrono::time_point&lt; Clock, Duration &gt; &amp;expiry, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> cancel_type=<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>)</td></tr>
<tr class="separator:aaeeeba97e9f7bc2a799b364155e91489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea0d0ae1b733917509414f752ba6529" id="r_aaea0d0ae1b733917509414f752ba6529"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename WaitTraits , typename Executor , typename Duration &gt; </td></tr>
<tr class="memitem:aaea0d0ae1b733917509414f752ba6529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__cancel__at__timer.html">partial_cancel_at_timer</a>&lt; Clock, WaitTraits, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaea0d0ae1b733917509414f752ba6529">cancel_at</a> (<a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;<a class="el" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>, const chrono::time_point&lt; Clock, Duration &gt; &amp;expiry, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> cancel_type=<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>)</td></tr>
<tr class="separator:aaea0d0ae1b733917509414f752ba6529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44038279338e1f3adabe29a7e9ae278d" id="r_a44038279338e1f3adabe29a7e9ae278d"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:a44038279338e1f3adabe29a7e9ae278d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__at__t.html">cancel_at_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44038279338e1f3adabe29a7e9ae278d">cancel_at</a> (const chrono::time_point&lt; Clock, Duration &gt; &amp;expiry, CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:a44038279338e1f3adabe29a7e9ae278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92e3624896711511ba6af632d30d4c8" id="r_ae92e3624896711511ba6af632d30d4c8"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:ae92e3624896711511ba6af632d30d4c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__at__t.html">cancel_at_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae92e3624896711511ba6af632d30d4c8">cancel_at</a> (const chrono::time_point&lt; Clock, Duration &gt; &amp;expiry, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> cancel_type, CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:ae92e3624896711511ba6af632d30d4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74049aec78c3f878ae5d28ad3356ae0d" id="r_a74049aec78c3f878ae5d28ad3356ae0d"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename Clock , typename WaitTraits , typename Executor , typename Duration &gt; </td></tr>
<tr class="memitem:a74049aec78c3f878ae5d28ad3356ae0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__at__timer.html">cancel_at_timer</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock, WaitTraits, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74049aec78c3f878ae5d28ad3356ae0d">cancel_at</a> (<a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;<a class="el" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>, const chrono::time_point&lt; Clock, Duration &gt; &amp;expiry, CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:a74049aec78c3f878ae5d28ad3356ae0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7d481e9f19fb72ae68a0bf0f84ccc8" id="r_adb7d481e9f19fb72ae68a0bf0f84ccc8"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename Clock , typename WaitTraits , typename Executor , typename Duration &gt; </td></tr>
<tr class="memitem:adb7d481e9f19fb72ae68a0bf0f84ccc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__at__timer.html">cancel_at_timer</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock, WaitTraits, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb7d481e9f19fb72ae68a0bf0f84ccc8">cancel_at</a> (<a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;<a class="el" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>, const chrono::time_point&lt; Clock, Duration &gt; &amp;expiry, <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> cancel_type, CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:adb7d481e9f19fb72ae68a0bf0f84ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a82e92df79aa8401a8bc2117d4cf900" id="r_a4a82e92df79aa8401a8bc2117d4cf900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__all__t.html">detail::transfer_all_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a82e92df79aa8401a8bc2117d4cf900">transfer_all</a> ()</td></tr>
<tr class="separator:a4a82e92df79aa8401a8bc2117d4cf900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b10af704afcd6c7ed7f0d3b740033ef" id="r_a2b10af704afcd6c7ed7f0d3b740033ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__at__least__t.html">detail::transfer_at_least_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b10af704afcd6c7ed7f0d3b740033ef">transfer_at_least</a> (std::size_t minimum)</td></tr>
<tr class="separator:a2b10af704afcd6c7ed7f0d3b740033ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2ada9400d78a5df0e5f65dd2b9967e" id="r_adb2ada9400d78a5df0e5f65dd2b9967e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__exactly__t.html">detail::transfer_exactly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb2ada9400d78a5df0e5f65dd2b9967e">transfer_exactly</a> (std::size_t size)</td></tr>
<tr class="separator:adb2ada9400d78a5df0e5f65dd2b9967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af44fc4cb32c36cb4280d4f7322c5b" id="r_a23af44fc4cb32c36cb4280d4f7322c5b"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename Signature , typename Implementation , typename... IoObjectsOrExecutors&gt; </td></tr>
<tr class="memitem:a23af44fc4cb32c36cb4280d4f7322c5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23af44fc4cb32c36cb4280d4f7322c5b">async_compose</a> (Implementation &amp;&amp;implementation, <a class="el" href="#a1bf2c6464b70e78b48be535c1dd8087f">type_identity_t</a>&lt; CompletionToken &gt; &amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, IoObjectsOrExecutors &amp;&amp;... io_objects_or_executors) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; CompletionToken, Signature &gt;(<a class="el" href="#ac40ca2867bf91f9aa7a24230e422fc9b">composed</a>&lt; Signature &gt;(static_cast&lt; Implementation &amp;&amp; &gt;(implementation), static_cast&lt; IoObjectsOrExecutors &amp;&amp; &gt;(io_objects_or_executors)...), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a23af44fc4cb32c36cb4280d4f7322c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch an asynchronous operation with a stateful implementation.  <br /></td></tr>
<tr class="separator:a23af44fc4cb32c36cb4280d4f7322c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40ca2867bf91f9aa7a24230e422fc9b" id="r_ac40ca2867bf91f9aa7a24230e422fc9b"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_SIGNATURE... Signatures, typename Implementation , typename... IoObjectsOrExecutors&gt; </td></tr>
<tr class="memitem:ac40ca2867bf91f9aa7a24230e422fc9b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac40ca2867bf91f9aa7a24230e422fc9b">composed</a> (Implementation &amp;&amp;implementation, IoObjectsOrExecutors &amp;&amp;... io_objects_or_executors) -&gt; decltype(<a class="el" href="namespaceasio_1_1detail.html#ac086ff2f548545f78952448a038abbc8">detail::make_initiate_composed</a>&lt; Signatures... &gt;(static_cast&lt; Implementation &amp;&amp; &gt;(implementation), <a class="el" href="namespaceasio_1_1detail.html#aebfd213c14f7d960fd686315d844b471">detail::make_composed_io_executors</a>(<a class="el" href="namespaceasio_1_1detail.html#a390920449946d0e5b743593f9fa8ac27">detail::get_composed_io_executor</a>(static_cast&lt; IoObjectsOrExecutors &amp;&amp; &gt;(io_objects_or_executors))...)))</td></tr>
<tr class="separator:ac40ca2867bf91f9aa7a24230e422fc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9722498362a99a18c1daabb554ac3f7" id="r_ad9722498362a99a18c1daabb554ac3f7"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence &gt; </td></tr>
<tr class="memitem:ad9722498362a99a18c1daabb554ac3f7"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9722498362a99a18c1daabb554ac3f7">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad9722498362a99a18c1daabb554ac3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="separator:ad9722498362a99a18c1daabb554ac3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abd764e6b852835571e5cb4c930bd7e" id="r_a5abd764e6b852835571e5cb4c930bd7e"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence &gt; </td></tr>
<tr class="memitem:a5abd764e6b852835571e5cb4c930bd7e"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5abd764e6b852835571e5cb4c930bd7e">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5abd764e6b852835571e5cb4c930bd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="separator:a5abd764e6b852835571e5cb4c930bd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a264859b2129ad503e72850c37ae31" id="r_a43a264859b2129ad503e72850c37ae31"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator &gt; </td></tr>
<tr class="memitem:a43a264859b2129ad503e72850c37ae31"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43a264859b2129ad503e72850c37ae31">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0)</td></tr>
<tr class="separator:a43a264859b2129ad503e72850c37ae31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7e6e620a9da1d4d64236c162eed826" id="r_a1a7e6e620a9da1d4d64236c162eed826"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator &gt; </td></tr>
<tr class="memitem:a1a7e6e620a9da1d4d64236c162eed826"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a7e6e620a9da1d4d64236c162eed826">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0)</td></tr>
<tr class="separator:a1a7e6e620a9da1d4d64236c162eed826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c58255744686dfcd930523d98bc0c2" id="r_aa8c58255744686dfcd930523d98bc0c2"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator &gt; </td></tr>
<tr class="memitem:aa8c58255744686dfcd930523d98bc0c2"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8c58255744686dfcd930523d98bc0c2">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:aa8c58255744686dfcd930523d98bc0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="separator:aa8c58255744686dfcd930523d98bc0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be799cfeb2dc75e371ffba20d2e62db" id="r_a5be799cfeb2dc75e371ffba20d2e62db"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator &gt; </td></tr>
<tr class="memitem:a5be799cfeb2dc75e371ffba20d2e62db"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5be799cfeb2dc75e371ffba20d2e62db">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a5be799cfeb2dc75e371ffba20d2e62db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="separator:a5be799cfeb2dc75e371ffba20d2e62db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8432621bada84252d7ba046f7debb6bd" id="r_a8432621bada84252d7ba046f7debb6bd"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:a8432621bada84252d7ba046f7debb6bd"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8432621bada84252d7ba046f7debb6bd">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a8432621bada84252d7ba046f7debb6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="separator:a8432621bada84252d7ba046f7debb6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4646beddee1d8c46a01e9e9110ac51ce" id="r_a4646beddee1d8c46a01e9e9110ac51ce"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:a4646beddee1d8c46a01e9e9110ac51ce"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4646beddee1d8c46a01e9e9110ac51ce">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a4646beddee1d8c46a01e9e9110ac51ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="separator:a4646beddee1d8c46a01e9e9110ac51ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327861511f29f5caf62d92b4bd62b42f" id="r_a327861511f29f5caf62d92b4bd62b42f"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:a327861511f29f5caf62d92b4bd62b42f"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a327861511f29f5caf62d92b4bd62b42f">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, ConnectCondition connect_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;=0)</td></tr>
<tr class="separator:a327861511f29f5caf62d92b4bd62b42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b137487ce51957fc4e8adf77238f439" id="r_a6b137487ce51957fc4e8adf77238f439"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:a6b137487ce51957fc4e8adf77238f439"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b137487ce51957fc4e8adf77238f439">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, ConnectCondition connect_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;=0)</td></tr>
<tr class="separator:a6b137487ce51957fc4e8adf77238f439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1b8204e11c8f8470313127d6edf304" id="r_a2c1b8204e11c8f8470313127d6edf304"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:a2c1b8204e11c8f8470313127d6edf304"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c1b8204e11c8f8470313127d6edf304">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, ConnectCondition connect_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a2c1b8204e11c8f8470313127d6edf304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="separator:a2c1b8204e11c8f8470313127d6edf304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30facd82bc6bcefe12df7e1fee4a9ac" id="r_ae30facd82bc6bcefe12df7e1fee4a9ac"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ae30facd82bc6bcefe12df7e1fee4a9ac"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae30facd82bc6bcefe12df7e1fee4a9ac">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, ConnectCondition connect_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ae30facd82bc6bcefe12df7e1fee4a9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="separator:ae30facd82bc6bcefe12df7e1fee4a9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a844ab59bc144e7221613630c67936" id="r_a48a844ab59bc144e7221613630c67936"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)) RangeConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a48a844ab59bc144e7221613630c67936"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48a844ab59bc144e7221613630c67936">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, RangeConnectToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; RangeConnectToken, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; RangeConnectToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>&lt; Protocol, Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, endpoints, declval&lt; <a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a> &gt;()))</td></tr>
<tr class="separator:a48a844ab59bc144e7221613630c67936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cdf7b98b8069b934685f11d1c37219" id="r_a59cdf7b98b8069b934685f11d1c37219"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a59cdf7b98b8069b934685f11d1c37219"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59cdf7b98b8069b934685f11d1c37219">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, IteratorConnectToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_same&lt; Iterator, <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; IteratorConnectToken &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; IteratorConnectToken, Iterator &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; IteratorConnectToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt; Protocol, Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, Iterator(), declval&lt; <a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a> &gt;()))</td></tr>
<tr class="separator:a59cdf7b98b8069b934685f11d1c37219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e9be68ae873ab4447b573babc08abc" id="r_a08e9be68ae873ab4447b573babc08abc"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a08e9be68ae873ab4447b573babc08abc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08e9be68ae873ab4447b573babc08abc">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, IteratorConnectToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; IteratorConnectToken, Iterator &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; IteratorConnectToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt; Protocol, Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, end, declval&lt; <a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a> &gt;()))</td></tr>
<tr class="separator:a08e9be68ae873ab4447b573babc08abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae014833b1e58f57eeeadffb356fd61cc" id="r_ae014833b1e58f57eeeadffb356fd61cc"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)) RangeConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:ae014833b1e58f57eeeadffb356fd61cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae014833b1e58f57eeeadffb356fd61cc">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, RangeConnectToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; RangeConnectToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>&lt; Protocol, Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, endpoints, connect_condition))</td></tr>
<tr class="separator:ae014833b1e58f57eeeadffb356fd61cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18e1747520bfe97c456f5f3ea42dbb1" id="r_ab18e1747520bfe97c456f5f3ea42dbb1"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:ab18e1747520bfe97c456f5f3ea42dbb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab18e1747520bfe97c456f5f3ea42dbb1">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, ConnectCondition connect_condition, IteratorConnectToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; IteratorConnectToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt; Protocol, Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, Iterator(), connect_condition))</td></tr>
<tr class="separator:ab18e1747520bfe97c456f5f3ea42dbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e94bec2b227b6c91344b53cf60acf68" id="r_a4e94bec2b227b6c91344b53cf60acf68"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a4e94bec2b227b6c91344b53cf60acf68"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e94bec2b227b6c91344b53cf60acf68">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, ConnectCondition connect_condition, IteratorConnectToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; IteratorConnectToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt; Protocol, Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, end, connect_condition))</td></tr>
<tr class="separator:a4e94bec2b227b6c91344b53cf60acf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b89b67408806b08981fc972fd035d5" id="r_a05b89b67408806b08981fc972fd035d5"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename... Values&gt; </td></tr>
<tr class="memitem:a05b89b67408806b08981fc972fd035d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> constexpr <a class="el" href="classasio_1_1consign__t.html">consign_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Values &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05b89b67408806b08981fc972fd035d5">consign</a> (CompletionToken &amp;&amp;completion_token, Values &amp;&amp;... values)</td></tr>
<tr class="separator:a05b89b67408806b08981fc972fd035d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22593523345cc52158f906f33a38cb15" id="r_a22593523345cc52158f906f33a38cb15"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken&gt; </td></tr>
<tr class="memitem:a22593523345cc52158f906f33a38cb15"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22593523345cc52158f906f33a38cb15">defer</a> (NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__defer.html">detail::initiate_defer</a> &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a22593523345cc52158f906f33a38cb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:a22593523345cc52158f906f33a38cb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab024cd3bf6ed204f3db126141ac1f5c0" id="r_ab024cd3bf6ed204f3db126141ac1f5c0"><td class="memTemplParams" colspan="2">template&lt;typename Executor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:ab024cd3bf6ed204f3db126141ac1f5c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab024cd3bf6ed204f3db126141ac1f5c0">defer</a> (const Executor &amp;ex, NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__defer__with__executor.html">detail::initiate_defer_with_executor</a>&lt; Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:ab024cd3bf6ed204f3db126141ac1f5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:ab024cd3bf6ed204f3db126141ac1f5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710475c7cb3c1a1624cb78bf67c4997f" id="r_a710475c7cb3c1a1624cb78bf67c4997f"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a710475c7cb3c1a1624cb78bf67c4997f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a710475c7cb3c1a1624cb78bf67c4997f">defer</a> (ExecutionContext &amp;ctx, NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__defer__with__executor.html">detail::initiate_defer_with_executor</a>&lt; typename ExecutionContext::executor_type &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a710475c7cb3c1a1624cb78bf67c4997f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:a710475c7cb3c1a1624cb78bf67c4997f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1502dd4243e9745eaad2753e5ee24c" id="r_acb1502dd4243e9745eaad2753e5ee24c"><td class="memTemplParams" colspan="2">template&lt;typename Head , typename Tail &gt; </td></tr>
<tr class="memitem:acb1502dd4243e9745eaad2753e5ee24c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb1502dd4243e9745eaad2753e5ee24c">operator|</a> (Head head, Tail &amp;&amp;tail) -&gt; <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__deferred.html">is_deferred</a>&lt; Head &gt;::value, decltype(static_cast&lt; Head &amp;&amp; &gt;(head)(static_cast&lt; Tail &amp;&amp; &gt;(tail))) &gt;</td></tr>
<tr class="memdesc:acb1502dd4243e9745eaad2753e5ee24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe operator used to chain deferred operations.  <br /></td></tr>
<tr class="separator:acb1502dd4243e9745eaad2753e5ee24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367ab9910ca8144f6df7a4df7bd295d0" id="r_a367ab9910ca8144f6df7a4df7bd295d0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a367ab9910ca8144f6df7a4df7bd295d0">aligned_new</a> (std::size_t align, std::size_t size)</td></tr>
<tr class="separator:a367ab9910ca8144f6df7a4df7bd295d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9671ab1d43c6f6ec3daff4f3416b8afc" id="r_a9671ab1d43c6f6ec3daff4f3416b8afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9671ab1d43c6f6ec3daff4f3416b8afc">aligned_delete</a> (void *ptr)</td></tr>
<tr class="separator:a9671ab1d43c6f6ec3daff4f3416b8afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b53f4ff238fefdfbaf52153b89e6abd" id="r_a0b53f4ff238fefdfbaf52153b89e6abd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken&gt; </td></tr>
<tr class="memitem:a0b53f4ff238fefdfbaf52153b89e6abd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b53f4ff238fefdfbaf52153b89e6abd">dispatch</a> (NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__dispatch.html">detail::initiate_dispatch</a> &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a0b53f4ff238fefdfbaf52153b89e6abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:a0b53f4ff238fefdfbaf52153b89e6abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b55c8f57836701c5d8cdb06cec3f30a" id="r_a3b55c8f57836701c5d8cdb06cec3f30a"><td class="memTemplParams" colspan="2">template&lt;typename Executor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a3b55c8f57836701c5d8cdb06cec3f30a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b55c8f57836701c5d8cdb06cec3f30a">dispatch</a> (const Executor &amp;ex, NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__dispatch__with__executor.html">detail::initiate_dispatch_with_executor</a>&lt; Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a3b55c8f57836701c5d8cdb06cec3f30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:a3b55c8f57836701c5d8cdb06cec3f30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493afa7d5a111aea6b0bb9ddb2dca5ab" id="r_a493afa7d5a111aea6b0bb9ddb2dca5ab"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a493afa7d5a111aea6b0bb9ddb2dca5ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a493afa7d5a111aea6b0bb9ddb2dca5ab">dispatch</a> (ExecutionContext &amp;ctx, NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__dispatch__with__executor.html">detail::initiate_dispatch_with_executor</a>&lt; typename ExecutionContext::executor_type &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a493afa7d5a111aea6b0bb9ddb2dca5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:a493afa7d5a111aea6b0bb9ddb2dca5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4859eacaf587bf46901d9597e139f6c" id="r_ac4859eacaf587bf46901d9597e139f6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> const <a class="el" href="#ae434d49ea968ad09c18f44d08c98aaa4">error_category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4859eacaf587bf46901d9597e139f6c">system_category</a> ()</td></tr>
<tr class="memdesc:ac4859eacaf587bf46901d9597e139f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error category used for the system errors produced by asio.  <br /></td></tr>
<tr class="separator:ac4859eacaf587bf46901d9597e139f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1810b2cc34a2ed373b761420a3d3a729" id="r_a1810b2cc34a2ed373b761420a3d3a729"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a1810b2cc34a2ed373b761420a3d3a729"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1810b2cc34a2ed373b761420a3d3a729">use_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;)</td></tr>
<tr class="separator:a1810b2cc34a2ed373b761420a3d3a729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d34f8c7897fc264ad87590429a7429a" id="r_a0d34f8c7897fc264ad87590429a7429a"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a0d34f8c7897fc264ad87590429a7429a"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d34f8c7897fc264ad87590429a7429a">use_service</a> (<a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;)</td></tr>
<tr class="separator:a0d34f8c7897fc264ad87590429a7429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf08702b1a8a7a6af573ca3ff6c402be" id="r_adf08702b1a8a7a6af573ca3ff6c402be"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:adf08702b1a8a7a6af573ca3ff6c402be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf08702b1a8a7a6af573ca3ff6c402be">add_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;, Service *)</td></tr>
<tr class="separator:adf08702b1a8a7a6af573ca3ff6c402be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34e09c0ef0fc9a740fc96a62c4d2d5" id="r_a2e34e09c0ef0fc9a740fc96a62c4d2d5"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a2e34e09c0ef0fc9a740fc96a62c4d2d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e34e09c0ef0fc9a740fc96a62c4d2d5">has_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;)</td></tr>
<tr class="separator:a2e34e09c0ef0fc9a740fc96a62c4d2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5433b8ec69df1bcf0d8cd5e1c46f67c3" id="r_a5433b8ec69df1bcf0d8cd5e1c46f67c3"><td class="memTemplParams" colspan="2">template&lt;typename Executor &gt; </td></tr>
<tr class="memitem:a5433b8ec69df1bcf0d8cd5e1c46f67c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5433b8ec69df1bcf0d8cd5e1c46f67c3">make_work_guard</a> (const Executor &amp;ex, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5433b8ec69df1bcf0d8cd5e1c46f67c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="separator:a5433b8ec69df1bcf0d8cd5e1c46f67c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99d916ce3bce6e49e0f941c63732645" id="r_ac99d916ce3bce6e49e0f941c63732645"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ac99d916ce3bce6e49e0f941c63732645"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac99d916ce3bce6e49e0f941c63732645">make_work_guard</a> (ExecutionContext &amp;ctx, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ac99d916ce3bce6e49e0f941c63732645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="separator:ac99d916ce3bce6e49e0f941c63732645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f613167bcdab70b6f15e066895852c" id="r_ab4f613167bcdab70b6f15e066895852c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4f613167bcdab70b6f15e066895852c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; T &gt;::value &amp;&amp;!is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value, <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4f613167bcdab70b6f15e066895852c">make_work_guard</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ab4f613167bcdab70b6f15e066895852c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="separator:ab4f613167bcdab70b6f15e066895852c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22761a1a102b7be5645be991f2c2194" id="r_ad22761a1a102b7be5645be991f2c2194"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:ad22761a1a102b7be5645be991f2c2194"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; <a class="el" href="#a0c819bb7b358898e38408c978e6c93f2">associated_executor_t</a>&lt; T, Executor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad22761a1a102b7be5645be991f2c2194">make_work_guard</a> (const T &amp;t, const Executor &amp;ex, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad22761a1a102b7be5645be991f2c2194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="separator:ad22761a1a102b7be5645be991f2c2194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad852081c67675531caa1024485970f63" id="r_ad852081c67675531caa1024485970f63"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ad852081c67675531caa1024485970f63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; <a class="el" href="#a0c819bb7b358898e38408c978e6c93f2">associated_executor_t</a>&lt; T, typename ExecutionContext::executor_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad852081c67675531caa1024485970f63">make_work_guard</a> (const T &amp;t, ExecutionContext &amp;ctx, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; T &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad852081c67675531caa1024485970f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="separator:ad852081c67675531caa1024485970f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7613e3b437b2491c154e056f1a26668f" id="r_a7613e3b437b2491c154e056f1a26668f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a> (...)</td></tr>
<tr class="memdesc:a7613e3b437b2491c154e056f1a26668f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default continuation function for handlers.  <br /></td></tr>
<tr class="separator:a7613e3b437b2491c154e056f1a26668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92acb7b19bae50850ec54e342707f06" id="r_ac92acb7b19bae50850ec54e342707f06"><td class="memTemplParams" colspan="2">template&lt;typename Executor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:ac92acb7b19bae50850ec54e342707f06"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac92acb7b19bae50850ec54e342707f06">async_immediate</a> (const Executor &amp;ex, NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__immediate.html">detail::initiate_immediate</a>&lt; Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:ac92acb7b19bae50850ec54e342707f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch a trivial asynchronous operation that completes immediately.  <br /></td></tr>
<tr class="separator:ac92acb7b19bae50850ec54e342707f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ca1e173361cca3b31df400eb3510b4" id="r_ab2ca1e173361cca3b31df400eb3510b4"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </td></tr>
<tr class="memitem:ab2ca1e173361cca3b31df400eb3510b4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2ca1e173361cca3b31df400eb3510b4">async_immediate</a> (ExecutionContext &amp;ctx, NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__immediate.html">detail::initiate_immediate</a>&lt; typename ExecutionContext::executor_type &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:ab2ca1e173361cca3b31df400eb3510b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch a trivial asynchronous operation that completes immediately.  <br /></td></tr>
<tr class="separator:ab2ca1e173361cca3b31df400eb3510b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d72619732becbd6a8aa9a1a831ca2" id="r_a7c0d72619732becbd6a8aa9a1a831ca2"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename T , typename AwaitableExecutor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(std::exception_ptr, T)) CompletionToken&gt; </td></tr>
<tr class="memitem:a7c0d72619732becbd6a8aa9a1a831ca2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c0d72619732becbd6a8aa9a1a831ca2">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, void(std::exception_ptr, T)) co_spawn(const Executor &amp;ex</td></tr>
<tr class="separator:a7c0d72619732becbd6a8aa9a1a831ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcd6e783eb9d5fd4691c2cfa3e40f43" id="r_a5bcd6e783eb9d5fd4691c2cfa3e40f43"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename AwaitableExecutor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(std::exception_ptr)) CompletionToken&gt; </td></tr>
<tr class="memitem:a5bcd6e783eb9d5fd4691c2cfa3e40f43"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5bcd6e783eb9d5fd4691c2cfa3e40f43">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, void(std::exception_ptr)) co_spawn(const Executor &amp;ex</td></tr>
<tr class="separator:a5bcd6e783eb9d5fd4691c2cfa3e40f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f009a2ed747dd31a7d6aa7391890f0" id="r_ad6f009a2ed747dd31a7d6aa7391890f0"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename F , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(typename detail::awaitable_signature&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F()&gt; &gt;::type) CompletionToken&gt; </td></tr>
<tr class="memitem:ad6f009a2ed747dd31a7d6aa7391890f0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6f009a2ed747dd31a7d6aa7391890f0">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, typename detail::awaitable_signature&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F()&gt; &gt;::type) co_spawn(const Executor &amp;ex</td></tr>
<tr class="separator:ad6f009a2ed747dd31a7d6aa7391890f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a1fc7487a02a33c700f0a42e55774" id="r_ab15a1fc7487a02a33c700f0a42e55774"><td class="memTemplParams" colspan="2">template&lt;typename Service , typename... Args&gt; </td></tr>
<tr class="memitem:ab15a1fc7487a02a33c700f0a42e55774"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab15a1fc7487a02a33c700f0a42e55774">make_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab15a1fc7487a02a33c700f0a42e55774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764e1235aa162478633294d9b20ef3e3" id="r_a764e1235aa162478633294d9b20ef3e3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a764e1235aa162478633294d9b20ef3e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceasio_1_1detail.html#a31c14df804409e01448213346a224e80">detail::io_context_impl</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a764e1235aa162478633294d9b20ef3e3">use_service&lt; detail::io_context_impl &gt;</a> (<a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;ioc)</td></tr>
<tr class="separator:a764e1235aa162478633294d9b20ef3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4be0038c7c334d9f3a52d3b569275c" id="r_a6b4be0038c7c334d9f3a52d3b569275c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a6b4be0038c7c334d9f3a52d3b569275c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b4be0038c7c334d9f3a52d3b569275c">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a6b4be0038c7c334d9f3a52d3b569275c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a6b4be0038c7c334d9f3a52d3b569275c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1b66b2a02d69ef013a6c4624ac1b33" id="r_a5a1b66b2a02d69ef013a6c4624ac1b33"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a5a1b66b2a02d69ef013a6c4624ac1b33"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a1b66b2a02d69ef013a6c4624ac1b33">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5a1b66b2a02d69ef013a6c4624ac1b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a5a1b66b2a02d69ef013a6c4624ac1b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d5cec2634f5f444db542d796627711" id="r_a32d5cec2634f5f444db542d796627711"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a32d5cec2634f5f444db542d796627711"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32d5cec2634f5f444db542d796627711">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a32d5cec2634f5f444db542d796627711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a32d5cec2634f5f444db542d796627711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610eadff7bf636a2b3b1d46ef93afeed" id="r_a610eadff7bf636a2b3b1d46ef93afeed"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a610eadff7bf636a2b3b1d46ef93afeed"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a610eadff7bf636a2b3b1d46ef93afeed">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a610eadff7bf636a2b3b1d46ef93afeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a610eadff7bf636a2b3b1d46ef93afeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173b6d6f8e45f47505abf845bd090604" id="r_a173b6d6f8e45f47505abf845bd090604"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a173b6d6f8e45f47505abf845bd090604"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a173b6d6f8e45f47505abf845bd090604">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a173b6d6f8e45f47505abf845bd090604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a173b6d6f8e45f47505abf845bd090604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63cdc4a188b5ee7270c030ab39182d5" id="r_ae63cdc4a188b5ee7270c030ab39182d5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:ae63cdc4a188b5ee7270c030ab39182d5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae63cdc4a188b5ee7270c030ab39182d5">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ae63cdc4a188b5ee7270c030ab39182d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:ae63cdc4a188b5ee7270c030ab39182d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5c5badc73ea0bd9cd960bf9149d0ea" id="r_a5e5c5badc73ea0bd9cd960bf9149d0ea"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:a5e5c5badc73ea0bd9cd960bf9149d0ea"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e5c5badc73ea0bd9cd960bf9149d0ea">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5e5c5badc73ea0bd9cd960bf9149d0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a5e5c5badc73ea0bd9cd960bf9149d0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adc8b332a4551e12a9c62e3824af22d" id="r_a1adc8b332a4551e12a9c62e3824af22d"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a1adc8b332a4551e12a9c62e3824af22d"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1adc8b332a4551e12a9c62e3824af22d">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a1adc8b332a4551e12a9c62e3824af22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a1adc8b332a4551e12a9c62e3824af22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace05ca9407b860d216912f3d1b523740" id="r_ace05ca9407b860d216912f3d1b523740"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ace05ca9407b860d216912f3d1b523740"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace05ca9407b860d216912f3d1b523740">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ace05ca9407b860d216912f3d1b523740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:ace05ca9407b860d216912f3d1b523740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeda9d140628ff399cbe4a076cb15cee" id="r_aaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:aaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaeda9d140628ff399cbe4a076cb15cee">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:aaeda9d140628ff399cbe4a076cb15cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:aaeda9d140628ff399cbe4a076cb15cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0bc3183df1291c7b2a35ec30d5428c" id="r_abc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:abc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc0bc3183df1291c7b2a35ec30d5428c">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:abc0bc3183df1291c7b2a35ec30d5428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:abc0bc3183df1291c7b2a35ec30d5428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74efe4ab9a1e1ab911451678a99e9416" id="r_a74efe4ab9a1e1ab911451678a99e9416"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a74efe4ab9a1e1ab911451678a99e9416"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74efe4ab9a1e1ab911451678a99e9416">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a74efe4ab9a1e1ab911451678a99e9416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a74efe4ab9a1e1ab911451678a99e9416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f3630d17b3fa0cc9386a35314770be" id="r_ab2f3630d17b3fa0cc9386a35314770be"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ab2f3630d17b3fa0cc9386a35314770be"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2f3630d17b3fa0cc9386a35314770be">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ab2f3630d17b3fa0cc9386a35314770be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:ab2f3630d17b3fa0cc9386a35314770be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e9ea0f6b103926654caf7acf87578" id="r_ae71e9ea0f6b103926654caf7acf87578"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:ae71e9ea0f6b103926654caf7acf87578"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae71e9ea0f6b103926654caf7acf87578">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ae71e9ea0f6b103926654caf7acf87578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:ae71e9ea0f6b103926654caf7acf87578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc36adb5f0d169ee071a8b975f31a91" id="r_a6cc36adb5f0d169ee071a8b975f31a91"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:a6cc36adb5f0d169ee071a8b975f31a91"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6cc36adb5f0d169ee071a8b975f31a91">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a6cc36adb5f0d169ee071a8b975f31a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:a6cc36adb5f0d169ee071a8b975f31a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72519ed41d6309161d04e5612f9cce4" id="r_aa72519ed41d6309161d04e5612f9cce4"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:aa72519ed41d6309161d04e5612f9cce4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa72519ed41d6309161d04e5612f9cce4">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:aa72519ed41d6309161d04e5612f9cce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="separator:aa72519ed41d6309161d04e5612f9cce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb46469ca33aac1a846c0ee80fb37a1" id="r_a4eb46469ca33aac1a846c0ee80fb37a1"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a4eb46469ca33aac1a846c0ee80fb37a1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4eb46469ca33aac1a846c0ee80fb37a1">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;)</td></tr>
<tr class="separator:a4eb46469ca33aac1a846c0ee80fb37a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7a26ff401494d673ad462a3f3f5c0" id="r_a4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ef7a26ff401494d673ad462a3f3f5c0">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers)</td></tr>
<tr class="separator:a4ef7a26ff401494d673ad462a3f3f5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587e766e26325457154a5dac2a0b785" id="r_a6587e766e26325457154a5dac2a0b785"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a6587e766e26325457154a5dac2a0b785"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6587e766e26325457154a5dac2a0b785">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a6587e766e26325457154a5dac2a0b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768142a9f1b61d423db9c9e7796edced" id="r_a768142a9f1b61d423db9c9e7796edced"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a768142a9f1b61d423db9c9e7796edced"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a768142a9f1b61d423db9c9e7796edced">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;)</td></tr>
<tr class="separator:a768142a9f1b61d423db9c9e7796edced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6714ec6c4c8411e0337a5020f34788a2" id="r_a6714ec6c4c8411e0337a5020f34788a2"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a6714ec6c4c8411e0337a5020f34788a2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6714ec6c4c8411e0337a5020f34788a2">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;)</td></tr>
<tr class="separator:a6714ec6c4c8411e0337a5020f34788a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301406c670bc22190df6e8628cbf0037" id="r_a301406c670bc22190df6e8628cbf0037"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:a301406c670bc22190df6e8628cbf0037"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a301406c670bc22190df6e8628cbf0037">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="separator:a301406c670bc22190df6e8628cbf0037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4511bad893697fc58d379d6e00aa84ff" id="r_a4511bad893697fc58d379d6e00aa84ff"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:a4511bad893697fc58d379d6e00aa84ff"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4511bad893697fc58d379d6e00aa84ff">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a4511bad893697fc58d379d6e00aa84ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cb906daf2dc90517c0ae95cbe71507" id="r_a13cb906daf2dc90517c0ae95cbe71507"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a13cb906daf2dc90517c0ae95cbe71507"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13cb906daf2dc90517c0ae95cbe71507">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;)</td></tr>
<tr class="separator:a13cb906daf2dc90517c0ae95cbe71507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b92bb6fafc1878dfaad835ed99bdf87" id="r_a2b92bb6fafc1878dfaad835ed99bdf87"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:a2b92bb6fafc1878dfaad835ed99bdf87"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b92bb6fafc1878dfaad835ed99bdf87">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, char delim, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;)</td></tr>
<tr class="separator:a2b92bb6fafc1878dfaad835ed99bdf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5efc2077fba4bcbd64343b35235e822" id="r_ab5efc2077fba4bcbd64343b35235e822"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:ab5efc2077fba4bcbd64343b35235e822"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5efc2077fba4bcbd64343b35235e822">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, char delim, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;)</td></tr>
<tr class="separator:ab5efc2077fba4bcbd64343b35235e822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d6987da09298caf984161767c717b0" id="r_ab9d6987da09298caf984161767c717b0"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:ab9d6987da09298caf984161767c717b0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9d6987da09298caf984161767c717b0">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;)</td></tr>
<tr class="separator:ab9d6987da09298caf984161767c717b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ac3f1bd64b19dbb8abce621fd4d787" id="r_ab5ac3f1bd64b19dbb8abce621fd4d787"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:ab5ac3f1bd64b19dbb8abce621fd4d787"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5ac3f1bd64b19dbb8abce621fd4d787">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;)</td></tr>
<tr class="separator:ab5ac3f1bd64b19dbb8abce621fd4d787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0721392f813226742ab9d5f61ab50222" id="r_a0721392f813226742ab9d5f61ab50222"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition &gt; </td></tr>
<tr class="memitem:a0721392f813226742ab9d5f61ab50222"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0721392f813226742ab9d5f61ab50222">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, MatchCondition match_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;)</td></tr>
<tr class="separator:a0721392f813226742ab9d5f61ab50222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64f933f108873c05208b585d4030dda" id="r_ac64f933f108873c05208b585d4030dda"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ac64f933f108873c05208b585d4030dda"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac64f933f108873c05208b585d4030dda">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, MatchCondition match_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;)</td></tr>
<tr class="separator:ac64f933f108873c05208b585d4030dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aae2baa82596a6a9ad320e80b016006" id="r_a1aae2baa82596a6a9ad320e80b016006"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:a1aae2baa82596a6a9ad320e80b016006"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1aae2baa82596a6a9ad320e80b016006">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim)</td></tr>
<tr class="memdesc:a1aae2baa82596a6a9ad320e80b016006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <br /></td></tr>
<tr class="separator:a1aae2baa82596a6a9ad320e80b016006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d265cc5b757caf9c9a602da2d6a3e5" id="r_ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9d265cc5b757caf9c9a602da2d6a3e5">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <br /></td></tr>
<tr class="separator:ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a433d903eae4dd097bc2c55efbf1ee" id="r_a03a433d903eae4dd097bc2c55efbf1ee"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:a03a433d903eae4dd097bc2c55efbf1ee"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03a433d903eae4dd097bc2c55efbf1ee">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim)</td></tr>
<tr class="memdesc:a03a433d903eae4dd097bc2c55efbf1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <br /></td></tr>
<tr class="separator:a03a433d903eae4dd097bc2c55efbf1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78faf8cf08d47515162de95b18b0a860" id="r_a78faf8cf08d47515162de95b18b0a860"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:a78faf8cf08d47515162de95b18b0a860"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78faf8cf08d47515162de95b18b0a860">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a78faf8cf08d47515162de95b18b0a860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <br /></td></tr>
<tr class="separator:a78faf8cf08d47515162de95b18b0a860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8372fc4edf57763c49ed1f8cf42e6a4f" id="r_a8372fc4edf57763c49ed1f8cf42e6a4f"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:a8372fc4edf57763c49ed1f8cf42e6a4f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8372fc4edf57763c49ed1f8cf42e6a4f">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a8372fc4edf57763c49ed1f8cf42e6a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <br /></td></tr>
<tr class="separator:a8372fc4edf57763c49ed1f8cf42e6a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02f689946ae31e0c60cdaa926419f43" id="r_ab02f689946ae31e0c60cdaa926419f43"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ab02f689946ae31e0c60cdaa926419f43"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab02f689946ae31e0c60cdaa926419f43">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ab02f689946ae31e0c60cdaa926419f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <br /></td></tr>
<tr class="separator:ab02f689946ae31e0c60cdaa926419f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab935fe986ec9477db62af1e7d514e6ed" id="r_ab935fe986ec9477db62af1e7d514e6ed"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:ab935fe986ec9477db62af1e7d514e6ed"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab935fe986ec9477db62af1e7d514e6ed">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, char delim, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:ab935fe986ec9477db62af1e7d514e6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cb7c507ff2509dc675e040ebce3338" id="r_ae9cb7c507ff2509dc675e040ebce3338"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:ae9cb7c507ff2509dc675e040ebce3338"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9cb7c507ff2509dc675e040ebce3338">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, char delim, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:ae9cb7c507ff2509dc675e040ebce3338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc4d5ec4ec23d9aec3cdf8ae4e76872" id="r_a0bc4d5ec4ec23d9aec3cdf8ae4e76872"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:a0bc4d5ec4ec23d9aec3cdf8ae4e76872"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bc4d5ec4ec23d9aec3cdf8ae4e76872">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:a0bc4d5ec4ec23d9aec3cdf8ae4e76872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7a79fc07a0a5dcbb8ac5c4e9658466" id="r_a9d7a79fc07a0a5dcbb8ac5c4e9658466"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:a9d7a79fc07a0a5dcbb8ac5c4e9658466"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d7a79fc07a0a5dcbb8ac5c4e9658466">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:a9d7a79fc07a0a5dcbb8ac5c4e9658466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c499c6a5bf36dfe4eae35c9afdb76a2" id="r_a8c499c6a5bf36dfe4eae35c9afdb76a2"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition &gt; </td></tr>
<tr class="memitem:a8c499c6a5bf36dfe4eae35c9afdb76a2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c499c6a5bf36dfe4eae35c9afdb76a2">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, MatchCondition match_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:a8c499c6a5bf36dfe4eae35c9afdb76a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d2663e7af5457346f4463d16e4237a" id="r_a57d2663e7af5457346f4463d16e4237a"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition &gt; </td></tr>
<tr class="memitem:a57d2663e7af5457346f4463d16e4237a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57d2663e7af5457346f4463d16e4237a">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, MatchCondition match_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:a57d2663e7af5457346f4463d16e4237a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546edfac9aee7ffe3500b6e4fbe020fa" id="r_a546edfac9aee7ffe3500b6e4fbe020fa"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename F , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt; &gt;::type) CompletionToken&gt; </td></tr>
<tr class="memitem:a546edfac9aee7ffe3500b6e4fbe020fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a546edfac9aee7ffe3500b6e4fbe020fa">spawn</a> (const Executor &amp;ex, F &amp;&amp;function, CompletionToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype( <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt; &gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td></tr>
<tr class="memdesc:a546edfac9aee7ffe3500b6e4fbe020fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given executor.  <br /></td></tr>
<tr class="separator:a546edfac9aee7ffe3500b6e4fbe020fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adceeed5aaac4506fb950c60a8465975e" id="r_adceeed5aaac4506fb950c60a8465975e"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename F , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; typename ExecutionContext::executor_type &gt;)&gt; &gt;::type) CompletionToken&gt; </td></tr>
<tr class="memitem:adceeed5aaac4506fb950c60a8465975e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adceeed5aaac4506fb950c60a8465975e">spawn</a> (ExecutionContext &amp;ctx, F &amp;&amp;function, CompletionToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype( <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; typename ExecutionContext::executor_type &gt;)&gt; &gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; typename ExecutionContext::executor_type &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td></tr>
<tr class="memdesc:adceeed5aaac4506fb950c60a8465975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given execution context.  <br /></td></tr>
<tr class="separator:adceeed5aaac4506fb950c60a8465975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d7d7c26ad60f669c579ab03c129e02" id="r_a04d7d7c26ad60f669c579ab03c129e02"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename F , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt; &gt;::type) CompletionToken&gt; </td></tr>
<tr class="memitem:a04d7d7c26ad60f669c579ab03c129e02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04d7d7c26ad60f669c579ab03c129e02">spawn</a> (const <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt; &amp;ctx, F &amp;&amp;function, CompletionToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype( <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt; &gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td></tr>
<tr class="memdesc:a04d7d7c26ad60f669c579ab03c129e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine, inheriting the executor of another.  <br /></td></tr>
<tr class="separator:a04d7d7c26ad60f669c579ab03c129e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831273634fcb7d19b6c8a2f56c00d7f5" id="r_a831273634fcb7d19b6c8a2f56c00d7f5"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a831273634fcb7d19b6c8a2f56c00d7f5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a831273634fcb7d19b6c8a2f56c00d7f5">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a831273634fcb7d19b6c8a2f56c00d7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="separator:a831273634fcb7d19b6c8a2f56c00d7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c18920cf77046e1a78823245148256e" id="r_a0c18920cf77046e1a78823245148256e"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a0c18920cf77046e1a78823245148256e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c18920cf77046e1a78823245148256e">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a0c18920cf77046e1a78823245148256e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="separator:a0c18920cf77046e1a78823245148256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86befc1c843c2b0a1dae51cb7696a23" id="r_ae86befc1c843c2b0a1dae51cb7696a23"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ae86befc1c843c2b0a1dae51cb7696a23"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae86befc1c843c2b0a1dae51cb7696a23">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ae86befc1c843c2b0a1dae51cb7696a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="separator:ae86befc1c843c2b0a1dae51cb7696a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04492a713027cad28491d62420af55e2" id="r_a04492a713027cad28491d62420af55e2"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a04492a713027cad28491d62420af55e2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04492a713027cad28491d62420af55e2">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a04492a713027cad28491d62420af55e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="separator:a04492a713027cad28491d62420af55e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a7528f07309a5531a6d9e6610eae75" id="r_a03a7528f07309a5531a6d9e6610eae75"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a03a7528f07309a5531a6d9e6610eae75"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03a7528f07309a5531a6d9e6610eae75">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a03a7528f07309a5531a6d9e6610eae75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="separator:a03a7528f07309a5531a6d9e6610eae75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43cd7d671f4ac42f5d2c702d92db29c" id="r_ad43cd7d671f4ac42f5d2c702d92db29c"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:ad43cd7d671f4ac42f5d2c702d92db29c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad43cd7d671f4ac42f5d2c702d92db29c">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad43cd7d671f4ac42f5d2c702d92db29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="separator:ad43cd7d671f4ac42f5d2c702d92db29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6487c8fe492bf17fc7e08b61d960f17" id="r_aa6487c8fe492bf17fc7e08b61d960f17"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:aa6487c8fe492bf17fc7e08b61d960f17"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6487c8fe492bf17fc7e08b61d960f17">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:aa6487c8fe492bf17fc7e08b61d960f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="separator:aa6487c8fe492bf17fc7e08b61d960f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041edf0d14932a201d095d8d17687a35" id="r_a041edf0d14932a201d095d8d17687a35"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a041edf0d14932a201d095d8d17687a35"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a041edf0d14932a201d095d8d17687a35">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a041edf0d14932a201d095d8d17687a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="separator:a041edf0d14932a201d095d8d17687a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8f8a9367c07e485e1b626b863591a9" id="r_abf8f8a9367c07e485e1b626b863591a9"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:abf8f8a9367c07e485e1b626b863591a9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf8f8a9367c07e485e1b626b863591a9">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:abf8f8a9367c07e485e1b626b863591a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="separator:abf8f8a9367c07e485e1b626b863591a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85807d13da87adf48b62979f65f41152" id="r_a85807d13da87adf48b62979f65f41152"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator &gt; </td></tr>
<tr class="memitem:a85807d13da87adf48b62979f65f41152"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85807d13da87adf48b62979f65f41152">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:a85807d13da87adf48b62979f65f41152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="separator:a85807d13da87adf48b62979f65f41152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72f7eddd7d4629ea2e2b7f5b7f355bc" id="r_af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator &gt; </td></tr>
<tr class="memitem:af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af72f7eddd7d4629ea2e2b7f5b7f355bc">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="separator:af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4139d4d096173216b89c46333099038" id="r_ad4139d4d096173216b89c46333099038"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ad4139d4d096173216b89c46333099038"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4139d4d096173216b89c46333099038">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad4139d4d096173216b89c46333099038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="separator:ad4139d4d096173216b89c46333099038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae460d619d1642598e71e32b0dc382398" id="r_ae460d619d1642598e71e32b0dc382398"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ae460d619d1642598e71e32b0dc382398"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae460d619d1642598e71e32b0dc382398">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ae460d619d1642598e71e32b0dc382398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="separator:ae460d619d1642598e71e32b0dc382398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982fe40762c23e1eb4ea166b4019208" id="r_af982fe40762c23e1eb4ea166b4019208"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:af982fe40762c23e1eb4ea166b4019208"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af982fe40762c23e1eb4ea166b4019208">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:af982fe40762c23e1eb4ea166b4019208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="separator:af982fe40762c23e1eb4ea166b4019208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eabfb4da832af9df0f85696c8022727" id="r_a5eabfb4da832af9df0f85696c8022727"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:a5eabfb4da832af9df0f85696c8022727"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5eabfb4da832af9df0f85696c8022727">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5eabfb4da832af9df0f85696c8022727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="separator:a5eabfb4da832af9df0f85696c8022727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae9a65aa623c0bfc52366134d665f92" id="r_aeae9a65aa623c0bfc52366134d665f92"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:aeae9a65aa623c0bfc52366134d665f92"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeae9a65aa623c0bfc52366134d665f92">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:aeae9a65aa623c0bfc52366134d665f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="separator:aeae9a65aa623c0bfc52366134d665f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d06a113e19b6fa1d67145d13afc4416" id="r_a8d06a113e19b6fa1d67145d13afc4416"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a8d06a113e19b6fa1d67145d13afc4416"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d06a113e19b6fa1d67145d13afc4416">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a8d06a113e19b6fa1d67145d13afc4416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <br /></td></tr>
<tr class="separator:a8d06a113e19b6fa1d67145d13afc4416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67a05a29d183782491d14aceec7d41" id="r_add67a05a29d183782491d14aceec7d41"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:add67a05a29d183782491d14aceec7d41"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add67a05a29d183782491d14aceec7d41">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:add67a05a29d183782491d14aceec7d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <br /></td></tr>
<tr class="separator:add67a05a29d183782491d14aceec7d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1abcb5870505ea2a0c524a59638da0" id="r_a8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c1abcb5870505ea2a0c524a59638da0">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a8c1abcb5870505ea2a0c524a59638da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <br /></td></tr>
<tr class="separator:a8c1abcb5870505ea2a0c524a59638da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24be5a5c262ce6245d836011e0421752" id="r_a24be5a5c262ce6245d836011e0421752"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a24be5a5c262ce6245d836011e0421752"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24be5a5c262ce6245d836011e0421752">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a24be5a5c262ce6245d836011e0421752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <br /></td></tr>
<tr class="separator:a24be5a5c262ce6245d836011e0421752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dff7a50c833dbd9683952d4d179551" id="r_a49dff7a50c833dbd9683952d4d179551"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a49dff7a50c833dbd9683952d4d179551"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49dff7a50c833dbd9683952d4d179551">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a49dff7a50c833dbd9683952d4d179551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <br /></td></tr>
<tr class="separator:a49dff7a50c833dbd9683952d4d179551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db1f75a907c17918092b41f2f242104" id="r_a1db1f75a907c17918092b41f2f242104"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:a1db1f75a907c17918092b41f2f242104"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1db1f75a907c17918092b41f2f242104">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:a1db1f75a907c17918092b41f2f242104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <br /></td></tr>
<tr class="separator:a1db1f75a907c17918092b41f2f242104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f42435acf937c35ee4c81af44ee6ce" id="r_aa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:aa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6f42435acf937c35ee4c81af44ee6ce">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aa6f42435acf937c35ee4c81af44ee6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <br /></td></tr>
<tr class="separator:aa6f42435acf937c35ee4c81af44ee6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29270019add1d462dea4f5a8f76db22" id="r_ac29270019add1d462dea4f5a8f76db22"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ac29270019add1d462dea4f5a8f76db22"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac29270019add1d462dea4f5a8f76db22">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ac29270019add1d462dea4f5a8f76db22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <br /></td></tr>
<tr class="separator:ac29270019add1d462dea4f5a8f76db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96ddebcabf9c7f1524f803bc063a62b" id="r_ab96ddebcabf9c7f1524f803bc063a62b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken&gt; </td></tr>
<tr class="memitem:ab96ddebcabf9c7f1524f803bc063a62b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b">post</a> (NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__post.html">detail::initiate_post</a> &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:ab96ddebcabf9c7f1524f803bc063a62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:ab96ddebcabf9c7f1524f803bc063a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da1abe028648eee310abc4e6954afbe" id="r_a5da1abe028648eee310abc4e6954afbe"><td class="memTemplParams" colspan="2">template&lt;typename Executor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a5da1abe028648eee310abc4e6954afbe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5da1abe028648eee310abc4e6954afbe">post</a> (const Executor &amp;ex, NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__post__with__executor.html">detail::initiate_post_with_executor</a>&lt; Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a5da1abe028648eee310abc4e6954afbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:a5da1abe028648eee310abc4e6954afbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd1c5c73685cdaf49fc3f2cb770a5c8" id="r_a9bd1c5c73685cdaf49fc3f2cb770a5c8"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a9bd1c5c73685cdaf49fc3f2cb770a5c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9bd1c5c73685cdaf49fc3f2cb770a5c8">post</a> (ExecutionContext &amp;ctx, NullaryToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; NullaryToken, void()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__post__with__executor.html">detail::initiate_post_with_executor</a>&lt; typename ExecutionContext::executor_type &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a9bd1c5c73685cdaf49fc3f2cb770a5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="separator:a9bd1c5c73685cdaf49fc3f2cb770a5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ef4e735fba9b7b6f18061d85135718" id="r_a69ef4e735fba9b7b6f18061d85135718"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename... Values&gt; </td></tr>
<tr class="memitem:a69ef4e735fba9b7b6f18061d85135718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> constexpr <a class="el" href="classasio_1_1prepend__t.html">prepend_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Values &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69ef4e735fba9b7b6f18061d85135718">prepend</a> (CompletionToken &amp;&amp;completion_token, Values &amp;&amp;... values)</td></tr>
<tr class="separator:a69ef4e735fba9b7b6f18061d85135718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd75bd16e41e5b4d383cf8a07d3ca14b" id="r_afd75bd16e41e5b4d383cf8a07d3ca14b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:afd75bd16e41e5b4d383cf8a07d3ca14b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd75bd16e41e5b4d383cf8a07d3ca14b">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read.html">detail::initiate_async_read</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:afd75bd16e41e5b4d383cf8a07d3ca14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacc013eaeeb6d5038da0e9998f2a0dc" id="r_aaacc013eaeeb6d5038da0e9998f2a0dc"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:aaacc013eaeeb6d5038da0e9998f2a0dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaacc013eaeeb6d5038da0e9998f2a0dc">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read.html">detail::initiate_async_read</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:aaacc013eaeeb6d5038da0e9998f2a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcc4c1550a60d467df0328bd089bda6" id="r_a7fcc4c1550a60d467df0328bd089bda6"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a7fcc4c1550a60d467df0328bd089bda6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7fcc4c1550a60d467df0328bd089bda6">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a7fcc4c1550a60d467df0328bd089bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3bf347532ce7e48ba6400dd965d1d4" id="r_a3c3bf347532ce7e48ba6400dd965d1d4"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a3c3bf347532ce7e48ba6400dd965d1d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c3bf347532ce7e48ba6400dd965d1d4">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a3c3bf347532ce7e48ba6400dd965d1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3441781514562a429bcccb3a337c13" id="r_a3a3441781514562a429bcccb3a337c13"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a3a3441781514562a429bcccb3a337c13"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a3441781514562a429bcccb3a337c13">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a3a3441781514562a429bcccb3a337c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8176a7863ba2f232a203488278128d3" id="r_af8176a7863ba2f232a203488278128d3"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:af8176a7863ba2f232a203488278128d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8176a7863ba2f232a203488278128d3">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:af8176a7863ba2f232a203488278128d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89986f4ea15b664a5600747f80da12c" id="r_aa89986f4ea15b664a5600747f80da12c"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:aa89986f4ea15b664a5600747f80da12c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa89986f4ea15b664a5600747f80da12c">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:aa89986f4ea15b664a5600747f80da12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1731046973de30c9624f646b647ec3b" id="r_ad1731046973de30c9624f646b647ec3b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:ad1731046973de30c9624f646b647ec3b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1731046973de30c9624f646b647ec3b">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:ad1731046973de30c9624f646b647ec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430692bc6188b0a1a153a6c674b906a6" id="r_a430692bc6188b0a1a153a6c674b906a6"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncRandomAccessReadDevice::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a430692bc6188b0a1a153a6c674b906a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a430692bc6188b0a1a153a6c674b906a6">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncRandomAccessReadDevice::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at.html">detail::initiate_async_read_at</a>&lt; AsyncRandomAccessReadDevice &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a430692bc6188b0a1a153a6c674b906a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e97b034de0664fd029f0a4d2eeadd4" id="r_a72e97b034de0664fd029f0a4d2eeadd4"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncRandomAccessReadDevice::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a72e97b034de0664fd029f0a4d2eeadd4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72e97b034de0664fd029f0a4d2eeadd4">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncRandomAccessReadDevice::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at.html">detail::initiate_async_read_at</a>&lt; AsyncRandomAccessReadDevice &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a72e97b034de0664fd029f0a4d2eeadd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910031a87e4cd31c3e9b6b30d3f40376" id="r_a910031a87e4cd31c3e9b6b30d3f40376"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncRandomAccessReadDevice::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a910031a87e4cd31c3e9b6b30d3f40376"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a910031a87e4cd31c3e9b6b30d3f40376">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncRandomAccessReadDevice::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at__streambuf.html">detail::initiate_async_read_at_streambuf</a>&lt; AsyncRandomAccessReadDevice &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a910031a87e4cd31c3e9b6b30d3f40376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f825a5675cff97dd99b0d8648351c61" id="r_a8f825a5675cff97dd99b0d8648351c61"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncRandomAccessReadDevice::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a8f825a5675cff97dd99b0d8648351c61"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f825a5675cff97dd99b0d8648351c61">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncRandomAccessReadDevice::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at__streambuf.html">detail::initiate_async_read_at_streambuf</a>&lt; AsyncRandomAccessReadDevice &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a8f825a5675cff97dd99b0d8648351c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59786d012e76a0fa1eac177837b3433" id="r_ad59786d012e76a0fa1eac177837b3433"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:ad59786d012e76a0fa1eac177837b3433"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad59786d012e76a0fa1eac177837b3433">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, char delim, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v1.html">detail::initiate_async_read_until_delim_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), delim))</td></tr>
<tr class="separator:ad59786d012e76a0fa1eac177837b3433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f4777d439e2f06e5fb672174a91fbd" id="r_ad6f4777d439e2f06e5fb672174a91fbd"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:ad6f4777d439e2f06e5fb672174a91fbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6f4777d439e2f06e5fb672174a91fbd">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v1.html">detail::initiate_async_read_until_delim_string_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; std::string &gt;(delim)))</td></tr>
<tr class="separator:ad6f4777d439e2f06e5fb672174a91fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c3116ca59cbf749a21c68cb01b8b75" id="r_a89c3116ca59cbf749a21c68cb01b8b75"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a89c3116ca59cbf749a21c68cb01b8b75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89c3116ca59cbf749a21c68cb01b8b75">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, MatchCondition match_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v1.html">detail::initiate_async_read_until_match_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), match_condition))</td></tr>
<tr class="separator:a89c3116ca59cbf749a21c68cb01b8b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e014d9650dad2f7675b83af0cdf211" id="r_a19e014d9650dad2f7675b83af0cdf211"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a19e014d9650dad2f7675b83af0cdf211"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19e014d9650dad2f7675b83af0cdf211">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;()) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v1.html">detail::initiate_async_read_until_delim_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), delim))</td></tr>
<tr class="separator:a19e014d9650dad2f7675b83af0cdf211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaed75bf0fd3a9b11d12c10076ae4ecd" id="r_aaaed75bf0fd3a9b11d12c10076ae4ecd"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:aaaed75bf0fd3a9b11d12c10076ae4ecd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaaed75bf0fd3a9b11d12c10076ae4ecd">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;()) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v1.html">detail::initiate_async_read_until_delim_string_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; std::string &gt;(delim)))</td></tr>
<tr class="separator:aaaed75bf0fd3a9b11d12c10076ae4ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f36fca2afc5ab50b0279f4c41d7b89" id="r_a72f36fca2afc5ab50b0279f4c41d7b89"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename MatchCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a72f36fca2afc5ab50b0279f4c41d7b89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72f36fca2afc5ab50b0279f4c41d7b89">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v1.html">detail::initiate_async_read_until_match_v1</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), match_condition))</td></tr>
<tr class="separator:a72f36fca2afc5ab50b0279f4c41d7b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078a2e41de987ab22655278489aab1ff" id="r_a078a2e41de987ab22655278489aab1ff"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a078a2e41de987ab22655278489aab1ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a078a2e41de987ab22655278489aab1ff">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, char delim, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v2.html">detail::initiate_async_read_until_delim_v2</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), delim))</td></tr>
<tr class="separator:a078a2e41de987ab22655278489aab1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eaef18725de397c4608e18ddaa66fb" id="r_a89eaef18725de397c4608e18ddaa66fb"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a89eaef18725de397c4608e18ddaa66fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89eaef18725de397c4608e18ddaa66fb">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v2.html">detail::initiate_async_read_until_delim_string_v2</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; std::string &gt;(delim)))</td></tr>
<tr class="separator:a89eaef18725de397c4608e18ddaa66fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8002fac0002df210a130a197955de8" id="r_aca8002fac0002df210a130a197955de8"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:aca8002fac0002df210a130a197955de8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca8002fac0002df210a130a197955de8">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, MatchCondition match_condition, ReadToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncReadStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; ReadToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v2.html">detail::initiate_async_read_until_match_v2</a>&lt; AsyncReadStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), match_condition))</td></tr>
<tr class="separator:aca8002fac0002df210a130a197955de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589081fc458bda3b74d839c1f48124cd" id="r_a589081fc458bda3b74d839c1f48124cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__redirect__error.html">partial_redirect_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a589081fc458bda3b74d839c1f48124cd">redirect_error</a> (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a589081fc458bda3b74d839c1f48124cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057ab21c3bde13bdeb5e6769c69e3e09" id="r_a057ab21c3bde13bdeb5e6769c69e3e09"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a057ab21c3bde13bdeb5e6769c69e3e09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a057ab21c3bde13bdeb5e6769c69e3e09">redirect_error</a> (CompletionToken &amp;&amp;completion_token, <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a057ab21c3bde13bdeb5e6769c69e3e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a completion_token to capture error_code values to a variable.  <br /></td></tr>
<tr class="separator:a057ab21c3bde13bdeb5e6769c69e3e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efef73a4b2f1f8de3e2ea5573316333" id="r_a9efef73a4b2f1f8de3e2ea5573316333"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9efef73a4b2f1f8de3e2ea5573316333">buffer_sequence_begin</a> (const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a9efef73a4b2f1f8de3e2ea5573316333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <br /></td></tr>
<tr class="separator:a9efef73a4b2f1f8de3e2ea5573316333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c94685a98b1d93e7f90b1168e3c3eb" id="r_a95c94685a98b1d93e7f90b1168e3c3eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95c94685a98b1d93e7f90b1168e3c3eb">buffer_sequence_begin</a> (const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a95c94685a98b1d93e7f90b1168e3c3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <br /></td></tr>
<tr class="separator:a95c94685a98b1d93e7f90b1168e3c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133bf449a986c6c427b7c865e8a944eb" id="r_a133bf449a986c6c427b7c865e8a944eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a133bf449a986c6c427b7c865e8a944eb">buffer_sequence_end</a> (const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a133bf449a986c6c427b7c865e8a944eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <br /></td></tr>
<tr class="separator:a133bf449a986c6c427b7c865e8a944eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5bbedd70cf1b2a0f6b9e1a86ab0533" id="r_a3f5bbedd70cf1b2a0f6b9e1a86ab0533"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f5bbedd70cf1b2a0f6b9e1a86ab0533">buffer_sequence_end</a> (const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a3f5bbedd70cf1b2a0f6b9e1a86ab0533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <br /></td></tr>
<tr class="separator:a3f5bbedd70cf1b2a0f6b9e1a86ab0533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe13ad24e316f94e7ff8a197ac2a40be" id="r_afe13ad24e316f94e7ff8a197ac2a40be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe13ad24e316f94e7ff8a197ac2a40be">buffer</a> (const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:afe13ad24e316f94e7ff8a197ac2a40be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer representing the entire registered buffer.  <br /></td></tr>
<tr class="separator:afe13ad24e316f94e7ff8a197ac2a40be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bc6057a4682b36c1180b56107ff160" id="r_a83bc6057a4682b36c1180b56107ff160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83bc6057a4682b36c1180b56107ff160">buffer</a> (const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a83bc6057a4682b36c1180b56107ff160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer representing the entire registered buffer.  <br /></td></tr>
<tr class="separator:a83bc6057a4682b36c1180b56107ff160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacafdf44af129753e05ba770785b4acc" id="r_aacafdf44af129753e05ba770785b4acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacafdf44af129753e05ba770785b4acc">buffer</a> (const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;b, std::size_t n) noexcept</td></tr>
<tr class="memdesc:aacafdf44af129753e05ba770785b4acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer representing part of a registered buffer.  <br /></td></tr>
<tr class="separator:aacafdf44af129753e05ba770785b4acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa87a00e12c0e47cf34203dfb2c3ef1" id="r_aaaa87a00e12c0e47cf34203dfb2c3ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa87a00e12c0e47cf34203dfb2c3ef1">buffer</a> (const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;b, std::size_t n) noexcept</td></tr>
<tr class="memdesc:aaaa87a00e12c0e47cf34203dfb2c3ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer representing part of a registered buffer.  <br /></td></tr>
<tr class="separator:aaaa87a00e12c0e47cf34203dfb2c3ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca177b6e4828630b6433a536de7c5c26" id="r_aca177b6e4828630b6433a536de7c5c26"><td class="memTemplParams" colspan="2">template&lt;typename Executor &gt; </td></tr>
<tr class="memitem:aca177b6e4828630b6433a536de7c5c26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca177b6e4828630b6433a536de7c5c26">make_strand</a> (const Executor &amp;ex, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:aca177b6e4828630b6433a536de7c5c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an executor.  <br /></td></tr>
<tr class="separator:aca177b6e4828630b6433a536de7c5c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7096c735b433a3ac870f0e9ace0e0b1a" id="r_a7096c735b433a3ac870f0e9ace0e0b1a"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a7096c735b433a3ac870f0e9ace0e0b1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7096c735b433a3ac870f0e9ace0e0b1a">make_strand</a> (ExecutionContext &amp;ctx, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a7096c735b433a3ac870f0e9ace0e0b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an execution context.  <br /></td></tr>
<tr class="separator:a7096c735b433a3ac870f0e9ace0e0b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533d82c389058d9f3c70e6ba04fa5e78" id="r_a533d82c389058d9f3c70e6ba04fa5e78"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename ConstBufferSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a533d82c389058d9f3c70e6ba04fa5e78"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a533d82c389058d9f3c70e6ba04fa5e78">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncWriteStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; WriteToken &gt; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write.html">detail::initiate_async_write</a>&lt; AsyncWriteStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a533d82c389058d9f3c70e6ba04fa5e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089960c923e61aee5d92f1ace654fb3f" id="r_a089960c923e61aee5d92f1ace654fb3f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename ConstBufferSequence , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a089960c923e61aee5d92f1ace654fb3f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a089960c923e61aee5d92f1ace654fb3f">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncWriteStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write.html">detail::initiate_async_write</a>&lt; AsyncWriteStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a089960c923e61aee5d92f1ace654fb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2d0559eb8932481693248bc681e9b2" id="r_a6d2d0559eb8932481693248bc681e9b2"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer_v1 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a6d2d0559eb8932481693248bc681e9b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d2d0559eb8932481693248bc681e9b2">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncWriteStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; WriteToken &gt; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a6d2d0559eb8932481693248bc681e9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d434b0260a68500361316b2bd888177" id="r_a7d434b0260a68500361316b2bd888177"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a7d434b0260a68500361316b2bd888177"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d434b0260a68500361316b2bd888177">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncWriteStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a7d434b0260a68500361316b2bd888177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7409312aefe6e03ea88376620972d23b" id="r_a7409312aefe6e03ea88376620972d23b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a7409312aefe6e03ea88376620972d23b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7409312aefe6e03ea88376620972d23b">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncWriteStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; WriteToken &gt; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a7409312aefe6e03ea88376620972d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd2755ce3755858e8911da8aa6b948e" id="r_aefd2755ce3755858e8911da8aa6b948e"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename Allocator , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:aefd2755ce3755858e8911da8aa6b948e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefd2755ce3755858e8911da8aa6b948e">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncWriteStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:aefd2755ce3755858e8911da8aa6b948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf955b3f12a92f598f023b26bfd797c" id="r_adbf955b3f12a92f598f023b26bfd797c"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer_v2 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:adbf955b3f12a92f598f023b26bfd797c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbf955b3f12a92f598f023b26bfd797c">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncWriteStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; WriteToken &gt; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v2.html">detail::initiate_async_write_dynbuf_v2</a>&lt; AsyncWriteStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:adbf955b3f12a92f598f023b26bfd797c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed3cbf3f061ea5409ef0a2927a79cc3" id="r_a7ed3cbf3f061ea5409ef0a2927a79cc3"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a7ed3cbf3f061ea5409ef0a2927a79cc3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ed3cbf3f061ea5409ef0a2927a79cc3">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncWriteStream::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0, <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v2.html">detail::initiate_async_write_dynbuf_v2</a>&lt; AsyncWriteStream &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a7ed3cbf3f061ea5409ef0a2927a79cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244cc7d7d962349e73370d38bfc55d95" id="r_a244cc7d7d962349e73370d38bfc55d95"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;        typename AsyncRandomAccessWriteDevice::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a244cc7d7d962349e73370d38bfc55d95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a244cc7d7d962349e73370d38bfc55d95">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncRandomAccessWriteDevice::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; WriteToken &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at.html">detail::initiate_async_write_at</a>&lt; AsyncRandomAccessWriteDevice &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a244cc7d7d962349e73370d38bfc55d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27189f7643805cd852d5904efa46a577" id="r_a27189f7643805cd852d5904efa46a577"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;        typename AsyncRandomAccessWriteDevice::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a27189f7643805cd852d5904efa46a577"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a27189f7643805cd852d5904efa46a577">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncRandomAccessWriteDevice::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at.html">detail::initiate_async_write_at</a>&lt; AsyncRandomAccessWriteDevice &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a27189f7643805cd852d5904efa46a577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7276889f384d00307567904eb7a9cbd6" id="r_a7276889f384d00307567904eb7a9cbd6"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;        typename AsyncRandomAccessWriteDevice::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a7276889f384d00307567904eb7a9cbd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7276889f384d00307567904eb7a9cbd6">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncRandomAccessWriteDevice::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; WriteToken &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at__streambuf.html">detail::initiate_async_write_at_streambuf</a>&lt; AsyncRandomAccessWriteDevice &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a7276889f384d00307567904eb7a9cbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2303f42308ad87e66258ac91f054b802" id="r_a2303f42308ad87e66258ac91f054b802"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;        typename AsyncRandomAccessWriteDevice::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a2303f42308ad87e66258ac91f054b802"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2303f42308ad87e66258ac91f054b802">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt; typename AsyncRandomAccessWriteDevice::executor_type &gt;(), <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; WriteToken, void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at__streambuf.html">detail::initiate_async_write_at_streambuf</a>&lt; AsyncRandomAccessWriteDevice &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a2303f42308ad87e66258ac91f054b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0ff4c1c8e98b8cefd3d532bd417989f3" id="r_a0ff4c1c8e98b8cefd3d532bd417989f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="structasio_1_1partial__as__tuple.html">partial_as_tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ff4c1c8e98b8cefd3d532bd417989f3">as_tuple</a></td></tr>
<tr class="separator:a0ff4c1c8e98b8cefd3d532bd417989f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359cf8fa7c4df1b720eaea875a50f069" id="r_a359cf8fa7c4df1b720eaea875a50f069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="classasio_1_1deferred__t.html">deferred_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a359cf8fa7c4df1b720eaea875a50f069">deferred</a></td></tr>
<tr class="separator:a359cf8fa7c4df1b720eaea875a50f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea4315d6a817e4253248982b5f8b2c3" id="r_aaea4315d6a817e4253248982b5f8b2c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="classasio_1_1detached__t.html">detached_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaea4315d6a817e4253248982b5f8b2c3">detached</a></td></tr>
<tr class="separator:aaea4315d6a817e4253248982b5f8b2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80c4033469ae5aaa092c0d49852403c" id="r_aa80c4033469ae5aaa092c0d49852403c"><td class="memItemLeft" align="right" valign="top">awaitable&lt; T, AwaitableExecutor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa80c4033469ae5aaa092c0d49852403c">a</a></td></tr>
<tr class="separator:aa80c4033469ae5aaa092c0d49852403c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff1e9f7bb336026f18afa2221c9df07" id="r_adff1e9f7bb336026f18afa2221c9df07"><td class="memItemLeft" align="right" valign="top">awaitable&lt; T, AwaitableExecutor &gt; CompletionToken &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a></td></tr>
<tr class="separator:adff1e9f7bb336026f18afa2221c9df07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac172b717c13db01d7f99af7e42edcb68" id="r_ac172b717c13db01d7f99af7e42edcb68"><td class="memItemLeft" align="right" valign="top">F &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac172b717c13db01d7f99af7e42edcb68">f</a></td></tr>
<tr class="separator:ac172b717c13db01d7f99af7e42edcb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9b2d20d2003d88a06a522445f0bd37" id="r_afa9b2d20d2003d88a06a522445f0bd37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa9b2d20d2003d88a06a522445f0bd37">executor_arg</a></td></tr>
<tr class="separator:afa9b2d20d2003d88a06a522445f0bd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a86c2c0de78e09a17f9411347105fa468" name="a86c2c0de78e09a17f9411347105fa468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c2c0de78e09a17f9411347105fa468">&#9670;&#160;</a></span>add_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a86c2c0de78e09a17f9411347105fa468">asio::add_const_t</a> = typename std::add_const&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3717b6d9f669e34ca90122df5cd7ae26" name="a3717b6d9f669e34ca90122df5cd7ae26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3717b6d9f669e34ca90122df5cd7ae26">&#9670;&#160;</a></span>add_lvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3717b6d9f669e34ca90122df5cd7ae26">asio::add_lvalue_reference_t</a> = typename std::add_lvalue_reference&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02032fa24e71a291e5ca0a4653bf0659" name="a02032fa24e71a291e5ca0a4653bf0659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02032fa24e71a291e5ca0a4653bf0659">&#9670;&#160;</a></span>aligned_storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, std::size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a02032fa24e71a291e5ca0a4653bf0659">asio::aligned_storage_t</a> = typename <a class="el" href="structasio_1_1aligned__storage.html">aligned_storage</a>&lt;N, A&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affc78250721f13a1263cfd53002d6bd0" name="affc78250721f13a1263cfd53002d6bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc78250721f13a1263cfd53002d6bd0">&#9670;&#160;</a></span>associated_allocator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#affc78250721f13a1263cfd53002d6bd0">asio::associated_allocator_t</a> = typename <a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt;T, Allocator&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af61679c8b9f47d8af2c022e82c02a633" name="af61679c8b9f47d8af2c022e82c02a633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61679c8b9f47d8af2c022e82c02a633">&#9670;&#160;</a></span>associated_cancellation_slot_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CancellationSlot  = cancellation_slot&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af61679c8b9f47d8af2c022e82c02a633">asio::associated_cancellation_slot_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">  <span class="keyword">typename</span> associated_cancellation_slot&lt;T, CancellationSlot&gt;::type</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c819bb7b358898e38408c978e6c93f2" name="a0c819bb7b358898e38408c978e6c93f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c819bb7b358898e38408c978e6c93f2">&#9670;&#160;</a></span>associated_executor_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor  = system_executor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0c819bb7b358898e38408c978e6c93f2">asio::associated_executor_t</a> = typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, Executor&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98749f025f2ea9356fbffe308e3e4afb" name="a98749f025f2ea9356fbffe308e3e4afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98749f025f2ea9356fbffe308e3e4afb">&#9670;&#160;</a></span>associated_immediate_executor_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a98749f025f2ea9356fbffe308e3e4afb">asio::associated_immediate_executor_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">  <span class="keyword">typename</span> associated_immediate_executor&lt;T, Executor&gt;::type</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d85a0e28424dfdf416a9a812841606b" name="a5d85a0e28424dfdf416a9a812841606b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d85a0e28424dfdf416a9a812841606b">&#9670;&#160;</a></span>cancellation_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type</a> <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6e56380c6e0bff931bfc27cb24546b5" name="aa6e56380c6e0bff931bfc27cb24546b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e56380c6e0bff931bfc27cb24546b5">&#9670;&#160;</a></span>completion_signature_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa6e56380c6e0bff931bfc27cb24546b5">asio::completion_signature_of_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">  <span class="keyword">typename</span> completion_signature_of&lt;T, Args...&gt;::type</div>
</div><!-- fragment -->
</div>
</div>
<a id="a100ff23938cde2a03e28b4bde5321cc0" name="a100ff23938cde2a03e28b4bde5321cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100ff23938cde2a03e28b4bde5321cc0">&#9670;&#160;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool C, typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a100ff23938cde2a03e28b4bde5321cc0">asio::conditional_t</a> = typename std::conditional&lt;C, T, U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1691b4f2369ad1304498c7244449fd47" name="a1691b4f2369ad1304498c7244449fd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1691b4f2369ad1304498c7244449fd47">&#9670;&#160;</a></span>constraint_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Condition, typename Type  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">F CompletionToken <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">asio::constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt; = typename <a class="el" href="structasio_1_1constraint.html">constraint</a>&lt;Condition, Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a961c7a660a10d1a9506ea4d6eb366023" name="a961c7a660a10d1a9506ea4d6eb366023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961c7a660a10d1a9506ea4d6eb366023">&#9670;&#160;</a></span>decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">asio::decay_t</a> = typename std::decay&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae20e77355502b24334a3e9a37b76156a" name="ae20e77355502b24334a3e9a37b76156a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20e77355502b24334a3e9a37b76156a">&#9670;&#160;</a></span>default_completion_token_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae20e77355502b24334a3e9a37b76156a">asio::default_completion_token_t</a> = typename <a class="el" href="structasio_1_1default__completion__token.html">default_completion_token</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c7be67c717fae6f2e1b186573b74b44" name="a8c7be67c717fae6f2e1b186573b74b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7be67c717fae6f2e1b186573b74b44">&#9670;&#160;</a></span>disable_cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt;<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8">cancellation_type::none</a>&gt; <a class="el" href="#a8c7be67c717fae6f2e1b186573b74b44">asio::disable_cancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cancellation filter that disables cancellation. </p>

</div>
</div>
<a id="a56cbae0cd49c139578f11530959497f2" name="a56cbae0cd49c139578f11530959497f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cbae0cd49c139578f11530959497f2">&#9670;&#160;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool C, typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a56cbae0cd49c139578f11530959497f2">asio::enable_if_t</a> = typename std::enable_if&lt;C, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade3cac58ab6a1f1fe34475f706d635e5" name="ade3cac58ab6a1f1fe34475f706d635e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3cac58ab6a1f1fe34475f706d635e5">&#9670;&#160;</a></span>enable_partial_cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; static_cast&lt;<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a>&gt;( static_cast&lt;unsigned int&gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>) | static_cast&lt;unsigned int&gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a>))&gt; <a class="el" href="#ade3cac58ab6a1f1fe34475f706d635e5">asio::enable_partial_cancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bbee6470702e960e05ea7d244173a53" name="a8bbee6470702e960e05ea7d244173a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbee6470702e960e05ea7d244173a53">&#9670;&#160;</a></span>enable_terminal_cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt;<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>&gt; <a class="el" href="#a8bbee6470702e960e05ea7d244173a53">asio::enable_terminal_cancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cancellation filter that enables terminal cancellation only. </p>

</div>
</div>
<a id="a9e5a2903e6e8f37c19f8fac0602ff52a" name="a9e5a2903e6e8f37c19f8fac0602ff52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5a2903e6e8f37c19f8fac0602ff52a">&#9670;&#160;</a></span>enable_total_cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; static_cast&lt;<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a>&gt;( static_cast&lt;unsigned int&gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>) | static_cast&lt;unsigned int&gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a>) | static_cast&lt;unsigned int&gt;(<a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e">cancellation_type::total</a>))&gt; <a class="el" href="#a9e5a2903e6e8f37c19f8fac0602ff52a">asio::enable_total_cancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae434d49ea968ad09c18f44d08c98aaa4" name="ae434d49ea968ad09c18f44d08c98aaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae434d49ea968ad09c18f44d08c98aaa4">&#9670;&#160;</a></span>error_category</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::error_category <a class="el" href="#ae434d49ea968ad09c18f44d08c98aaa4">asio::error_category</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8914468bc40252ae5e5c666adb951cf" name="ac8914468bc40252ae5e5c666adb951cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8914468bc40252ae5e5c666adb951cf">&#9670;&#160;</a></span>error_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::error_code <a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac62851a86dfa77e72fd80d2e6ccab76f" name="ac62851a86dfa77e72fd80d2e6ccab76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62851a86dfa77e72fd80d2e6ccab76f">&#9670;&#160;</a></span>high_resolution_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::high_resolution_clock &gt; <a class="el" href="#ac62851a86dfa77e72fd80d2e6ccab76f">asio::high_resolution_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the high resolution clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer&lt;boost::chrono::high_resolution_clock&gt;</a> <a class="code hl_typedef" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>;</div>
<div class="ttc" id="abind__allocator_8cpp_html_af1abddd6ed87a43a672d1f851b84a694"><div class="ttname"><a href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a></div><div class="ttdeci">steady_timer timer</div><div class="ttdef"><b>Definition</b> bind_allocator.cpp:26</div></div>
<div class="ttc" id="aclassasio_1_1basic__waitable__timer_html"><div class="ttname"><a href="classasio_1_1basic__waitable__timer.html">asio::basic_waitable_timer</a></div><div class="ttdoc">Provides waitable timer functionality.</div><div class="ttdef"><b>Definition</b> basic_waitable_timer.hpp:140</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8904bd25ca421af4140ab7ac95b0b956" name="a8904bd25ca421af4140ab7ac95b0b956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8904bd25ca421af4140ab7ac95b0b956">&#9670;&#160;</a></span>io_service</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1io__context.html">io_context</a> <a class="el" href="#a8904bd25ca421af4140ab7ac95b0b956">asio::io_service</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for backwards compatibility. </p>

</div>
</div>
<a id="a865cee63c722452a345d68610bdde9d7" name="a865cee63c722452a345d68610bdde9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865cee63c722452a345d68610bdde9d7">&#9670;&#160;</a></span>prefer_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Properties&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a865cee63c722452a345d68610bdde9d7">asio::prefer_result_t</a> = typename <a class="el" href="structasio_1_1prefer__result.html">prefer_result</a>&lt;T, Properties...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55201409b23036671550beeb6cc3b94e" name="a55201409b23036671550beeb6cc3b94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55201409b23036671550beeb6cc3b94e">&#9670;&#160;</a></span>prefer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio__prefer__fn_1_1impl.html">asio_prefer_fn::impl</a> <a class="el" href="#a55201409b23036671550beeb6cc3b94e">asio::prefer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a967850c35e079d3459920302a605ddcf" name="a967850c35e079d3459920302a605ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967850c35e079d3459920302a605ddcf">&#9670;&#160;</a></span>query_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Property &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a967850c35e079d3459920302a605ddcf">asio::query_result_t</a> = typename <a class="el" href="structasio_1_1query__result.html">query_result</a>&lt;T, Property&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aecee0160ad9fd66180683316b4846d4b" name="aecee0160ad9fd66180683316b4846d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecee0160ad9fd66180683316b4846d4b">&#9670;&#160;</a></span>query_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio__query__fn_1_1impl.html">asio_query_fn::impl</a> <a class="el" href="#aecee0160ad9fd66180683316b4846d4b">asio::query_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abddbdaed94f37b8d9b05c25b7b47ec25" name="abddbdaed94f37b8d9b05c25b7b47ec25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddbdaed94f37b8d9b05c25b7b47ec25">&#9670;&#160;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abddbdaed94f37b8d9b05c25b7b47ec25">asio::remove_cv_t</a> = typename std::remove_cv&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8335631d5ec10332d2774eb5b261150" name="ab8335631d5ec10332d2774eb5b261150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8335631d5ec10332d2774eb5b261150">&#9670;&#160;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab8335631d5ec10332d2774eb5b261150">asio::remove_cvref_t</a> = typename <a class="el" href="structasio_1_1remove__cvref.html">remove_cvref</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56f4d18a492e1c2e7a4664d5775386fa" name="a56f4d18a492e1c2e7a4664d5775386fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f4d18a492e1c2e7a4664d5775386fa">&#9670;&#160;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a56f4d18a492e1c2e7a4664d5775386fa">asio::remove_pointer_t</a> = typename std::remove_pointer&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f77cce220380ae23fa06dbf2181a30a" name="a8f77cce220380ae23fa06dbf2181a30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f77cce220380ae23fa06dbf2181a30a">&#9670;&#160;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">asio::remove_reference_t</a> = typename std::remove_reference&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcb18173af7457adf90ce0f481f71370" name="abcb18173af7457adf90ce0f481f71370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb18173af7457adf90ce0f481f71370">&#9670;&#160;</a></span>require_concept_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Property &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abcb18173af7457adf90ce0f481f71370">asio::require_concept_result_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">  <span class="keyword">typename</span> require_concept_result&lt;T, Property&gt;::type</div>
</div><!-- fragment -->
</div>
</div>
<a id="a23510e91b2cc59d7d19e64f6a0f0b64f" name="a23510e91b2cc59d7d19e64f6a0f0b64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23510e91b2cc59d7d19e64f6a0f0b64f">&#9670;&#160;</a></span>require_concept_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio__require__concept__fn_1_1impl.html">asio_require_concept_fn::impl</a> <a class="el" href="#a23510e91b2cc59d7d19e64f6a0f0b64f">asio::require_concept_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43d399d7528dab2f34840c084d1b16e2" name="a43d399d7528dab2f34840c084d1b16e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d399d7528dab2f34840c084d1b16e2">&#9670;&#160;</a></span>require_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Properties&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a43d399d7528dab2f34840c084d1b16e2">asio::require_result_t</a> = typename <a class="el" href="structasio_1_1require__result.html">require_result</a>&lt;T, Properties...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f6bab0c8ad8c073a605675ec7232926" name="a0f6bab0c8ad8c073a605675ec7232926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6bab0c8ad8c073a605675ec7232926">&#9670;&#160;</a></span>require_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio__require__fn_1_1impl.html">asio_require_fn::impl</a> <a class="el" href="#a0f6bab0c8ad8c073a605675ec7232926">asio::require_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a517ab729aaffa516bb92bdffe2a49cb9" name="a517ab729aaffa516bb92bdffe2a49cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517ab729aaffa516bb92bdffe2a49cb9">&#9670;&#160;</a></span>result_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">asio::result_of_t</a> = typename std::result_of&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f135fc124cc60e4e00dc2dbb309f354" name="a4f135fc124cc60e4e00dc2dbb309f354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f135fc124cc60e4e00dc2dbb309f354">&#9670;&#160;</a></span>signal_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a> <a class="el" href="#a4f135fc124cc60e4e00dc2dbb309f354">asio::signal_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of a signal set. </p>

</div>
</div>
<a id="af97767413ad2526e9941d17f112b5018" name="af97767413ad2526e9941d17f112b5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97767413ad2526e9941d17f112b5018">&#9670;&#160;</a></span>static_thread_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1thread__pool.html">thread_pool</a> <a class="el" href="#af97767413ad2526e9941d17f112b5018">asio::static_thread_pool</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a627a7abd2bc87969838f17e46b8dc20d" name="a627a7abd2bc87969838f17e46b8dc20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627a7abd2bc87969838f17e46b8dc20d">&#9670;&#160;</a></span>steady_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::steady_clock &gt; <a class="el" href="#a627a7abd2bc87969838f17e46b8dc20d">asio::steady_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the steady clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer&lt;boost::chrono::steady_clock&gt;</a> <a class="code hl_typedef" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6a7ba348943527312eeace3492bf32ee" name="a6a7ba348943527312eeace3492bf32ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7ba348943527312eeace3492bf32ee">&#9670;&#160;</a></span>streambuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a> <a class="el" href="#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a>. </p>

</div>
</div>
<a id="ac5e0b6db67d52eba50e168ae78c1a049" name="ac5e0b6db67d52eba50e168ae78c1a049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e0b6db67d52eba50e168ae78c1a049">&#9670;&#160;</a></span>system_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::system_error <a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9afc37336b3232b8b291ab23e98a9201" name="a9afc37336b3232b8b291ab23e98a9201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afc37336b3232b8b291ab23e98a9201">&#9670;&#160;</a></span>system_executor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__system__executor.html">basic_system_executor</a>&lt;<a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#a0ee9cc739b3b11aa5a584a4310a47e22">execution::blocking_t::possibly_t</a>, <a class="el" href="structasio_1_1execution_1_1detail_1_1relationship__t.html#ad59f7aede6089578c4505b171e27369b">execution::relationship_t::fork_t</a>, std::allocator&lt;void&gt; &gt; <a class="el" href="#a9afc37336b3232b8b291ab23e98a9201">asio::system_executor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An executor that uses arbitrary threads. </p>
<p>The system executor represents an execution context where functions are permitted to run on arbitrary threads. When the blocking.never property is established, the system executor will schedule the function to run on an unspecified system thread pool. When either blocking.possibly or blocking.always is established, the executor invokes the function immediately. </p>

</div>
</div>
<a id="a2d65c694154683a53496180854859975" name="a2d65c694154683a53496180854859975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d65c694154683a53496180854859975">&#9670;&#160;</a></span>system_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::system_clock &gt; <a class="el" href="#a2d65c694154683a53496180854859975">asio::system_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the system clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer&lt;boost::chrono::system_clock&gt;</a> <a class="code hl_typedef" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1bf2c6464b70e78b48be535c1dd8087f" name="a1bf2c6464b70e78b48be535c1dd8087f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf2c6464b70e78b48be535c1dd8087f">&#9670;&#160;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1bf2c6464b70e78b48be535c1dd8087f">asio::type_identity_t</a> = typename <a class="el" href="structasio_1_1type__identity.html">type_identity</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac489beb547551cf305c38d045907535e" name="ac489beb547551cf305c38d045907535e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac489beb547551cf305c38d045907535e">&#9670;&#160;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac489beb547551cf305c38d045907535e">asio::void_t</a> = typename <a class="el" href="structasio_1_1void__type.html">void_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09b73624bafbe0c55f0da6b594cbc886" name="a09b73624bafbe0c55f0da6b594cbc886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b73624bafbe0c55f0da6b594cbc886">&#9670;&#160;</a></span>yield_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt;<a class="el" href="classasio_1_1any__io__executor.html">any_io_executor</a>&gt; <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">asio::yield_context</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A completion_token object that represents the currently executing coroutine. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae02aa651224af4b25dc476fc01ce29f6" name="ae02aa651224af4b25dc476fc01ce29f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02aa651224af4b25dc476fc01ce29f6">&#9670;&#160;</a></span>cancellation_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> : unsigned int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8" name="ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb" name="ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb"></a>terminal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f" name="ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f"></a>partial&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e" name="ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e"></a>total&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6aa181a603769c1f98ad927e7367c7aa51" name="ae02aa651224af4b25dc476fc01ce29f6aa181a603769c1f98ad927e7367c7aa51"></a>all&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adf08702b1a8a7a6af573ca3ff6c402be" name="adf08702b1a8a7a6af573ca3ff6c402be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf08702b1a8a7a6af573ca3ff6c402be">&#9670;&#160;</a></span>add_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::add_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Service *</td>          <td class="paramname"><span class="paramname"><em>svc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use <a class="el" href="#ab15a1fc7487a02a33c700f0a42e55774">make_service()</a>.) Add a service object to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>. This function is used to add a service to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
    <tr><td class="paramname">svc</td><td>The service object. On success, ownership of the service object is transferred to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>. When the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object is destroyed, it will destroy the service object by performing: <div class="fragment"><div class="line"><span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classasio_1_1execution__context_1_1service.html">execution_context::service</a>*<span class="keyword">&gt;</span>(svc) </div>
<div class="ttc" id="aclassasio_1_1execution__context_1_1service_html"><div class="ttname"><a href="classasio_1_1execution__context_1_1service.html">asio::execution_context::service</a></div><div class="ttdoc">Base class for all io_context services.</div><div class="ttdef"><b>Definition</b> execution_context.hpp:293</div></div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1service__already__exists.html">asio::service_already_exists</a></td><td>Thrown if a service of the given type is already present in the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>.</td></tr>
    <tr><td class="paramname"><a class="el" href="classasio_1_1invalid__service__owner.html">asio::invalid_service_owner</a></td><td>Thrown if the service's owning <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> is not the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object specified by the <code>e</code> parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9671ab1d43c6f6ec3daff4f3416b8afc" name="a9671ab1d43c6f6ec3daff4f3416b8afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9671ab1d43c6f6ec3daff4f3416b8afc">&#9670;&#160;</a></span>aligned_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::aligned_delete </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a367ab9910ca8144f6df7a4df7bd295d0" name="a367ab9910ca8144f6df7a4df7bd295d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367ab9910ca8144f6df7a4df7bd295d0">&#9670;&#160;</a></span>aligned_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * asio::aligned_new </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>align</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9197ee6666dda52782ac7ad94cb85032" name="a9197ee6666dda52782ac7ad94cb85032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9197ee6666dda52782ac7ad94cb85032">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename... Values&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> constexpr <a class="el" href="classasio_1_1append__t.html">append_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Values &gt;... &gt; asio::append </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completion token type used to specify that the completion handler arguments should be passed additional values after the results of the operation. </p>

</div>
</div>
<a id="a7613e3b437b2491c154e056f1a26668f" name="a7613e3b437b2491c154e056f1a26668f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7613e3b437b2491c154e056f1a26668f">&#9670;&#160;</a></span>asio_handler_is_continuation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::asio_handler_is_continuation </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default continuation function for handlers. </p>
<p>Asynchronous operations may represent a continuation of the asynchronous control flow associated with the current handler. The implementation can use this knowledge to optimise scheduling of the handler.</p>
<p>Implement asio_handler_is_continuation for your own handlers to indicate when a handler represents a continuation.</p>
<p>The default implementation of the continuation hook returns <code>false</code>.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">class </span>my_handler;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a>(my_handler* context)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceasio_html_a7613e3b437b2491c154e056f1a26668f"><div class="ttname"><a href="#a7613e3b437b2491c154e056f1a26668f">asio::asio_handler_is_continuation</a></div><div class="ttdeci">bool asio_handler_is_continuation(...)</div><div class="ttdoc">Default continuation function for handlers.</div><div class="ttdef"><b>Definition</b> handler_continuation_hook.hpp:45</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad6f009a2ed747dd31a7d6aa7391890f0" name="ad6f009a2ed747dd31a7d6aa7391890f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f009a2ed747dd31a7d6aa7391890f0">&#9670;&#160;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename F , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(typename detail::awaitable_signature&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F()&gt; &gt;::type) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::awaitable_signature&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F()&gt; &gt;::type</td>          <td class="paramname"><span class="paramname"></span>&#160;) const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bcd6e783eb9d5fd4691c2cfa3e40f43" name="a5bcd6e783eb9d5fd4691c2cfa3e40f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcd6e783eb9d5fd4691c2cfa3e40f43">&#9670;&#160;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename AwaitableExecutor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(std::exception_ptr)) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(std::exception_ptr)</td>          <td class="paramname"><span class="paramname"></span>&#160;) const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c0d72619732becbd6a8aa9a1a831ca2" name="a7c0d72619732becbd6a8aa9a1a831ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0d72619732becbd6a8aa9a1a831ca2">&#9670;&#160;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename T , typename AwaitableExecutor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(std::exception_ptr, T)) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(std::exception_ptr, T)</td>          <td class="paramname"><span class="paramname"></span>&#160;) const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23af44fc4cb32c36cb4280d4f7322c5b" name="a23af44fc4cb32c36cb4280d4f7322c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23af44fc4cb32c36cb4280d4f7322c5b">&#9670;&#160;</a></span>async_compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename Signature , typename Implementation , typename... IoObjectsOrExecutors&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_compose </td>
          <td>(</td>
          <td class="paramtype">Implementation &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>implementation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1bf2c6464b70e78b48be535c1dd8087f">type_identity_t</a>&lt; CompletionToken &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IoObjectsOrExecutors &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>io_objects_or_executors</em></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;CompletionToken, Signature&gt;(
      <a class="el" href="#ac40ca2867bf91f9aa7a24230e422fc9b">composed</a>&lt;Signature&gt;(static_cast&lt;Implementation&amp;&amp;&gt;(implementation),
        static_cast&lt;IoObjectsOrExecutors&amp;&amp;&gt;(io_objects_or_executors)...),
      <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch an asynchronous operation with a stateful implementation. </p>
<p>The async_compose function simplifies the implementation of composed asynchronous operations automatically wrapping a stateful function object with a conforming intermediate completion handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">implementation</td><td>A function object that contains the implementation of the composed asynchronous operation. The first argument to the function object is a non-const reference to the enclosing intermediate completion handler. The remaining arguments are any arguments that originate from the completion handlers of any asynchronous operations performed by the implementation.</td></tr>
    <tr><td class="paramname">token</td><td>The completion token.</td></tr>
    <tr><td class="paramname">io_objects_or_executors</td><td>Zero or more I/O objects or I/O executors for which outstanding work must be maintained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>By default, terminal per-operation cancellation is enabled for composed operations that are implemented using <code>async_compose</code>. To disable cancellation for the composed operation, or to alter its supported cancellation types, call the <code>self</code> object's <code>reset_cancellation_state</code> function.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">struct </span>async_echo_implementation</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; socket_;</div>
<div class="line">  <a class="code hl_class" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> buffer_;</div>
<div class="line">  <span class="keyword">enum</span> { starting, reading, writing } state_;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Self&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(Self&amp; self,</div>
<div class="line">      <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> error = {},</div>
<div class="line">      std::size_t n = 0)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">switch</span> (state_)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> starting:</div>
<div class="line">      state_ = reading;</div>
<div class="line">      socket_.async_read_some(</div>
<div class="line">          buffer_, std::move(self));</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> reading:</div>
<div class="line">      <span class="keywordflow">if</span> (error)</div>
<div class="line">      {</div>
<div class="line">        self.complete(error, 0);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        state_ = writing;</div>
<div class="line">        <a class="code hl_function" href="#a533d82c389058d9f3c70e6ba04fa5e78">asio::async_write</a>(socket_, buffer_,</div>
<div class="line">            <a class="code hl_function" href="#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a>(n),</div>
<div class="line">            std::move(self));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> writing:</div>
<div class="line">      self.complete(error, n);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionToken&gt;</div>
<div class="line"><span class="keyword">auto</span> async_echo(tcp::socket&amp; socket,</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> buffer,</div>
<div class="line">    CompletionToken&amp;&amp; <a class="code hl_variable" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>)</div>
<div class="line">  -&gt; <span class="keyword">decltype</span>(</div>
<div class="line">    <a class="code hl_function" href="#a23af44fc4cb32c36cb4280d4f7322c5b">asio::async_compose</a>&lt;CompletionToken,</div>
<div class="line">      <a class="code hl_variable" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(</div>
<div class="line">        std::declval&lt;async_echo_implementation&gt;(),</div>
<div class="line">        <a class="code hl_variable" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="code hl_function" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="#a23af44fc4cb32c36cb4280d4f7322c5b">asio::async_compose</a>&lt;CompletionToken,</div>
<div class="line">    <a class="code hl_variable" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(</div>
<div class="line">      async_echo_implementation{<a class="code hl_function" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">buffer</a>,</div>
<div class="line">        async_echo_implementation::starting},</div>
<div class="line">      <a class="code hl_variable" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="code hl_function" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>);</div>
<div class="line">} </div>
<div class="ttc" id="aclassasio_1_1mutable__buffer_html"><div class="ttname"><a href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a></div><div class="ttdoc">Holds a buffer that can be modified.</div><div class="ttdef"><b>Definition</b> buffer.hpp:79</div></div>
<div class="ttc" id="anamespaceasio_1_1detail_1_1socket__ops_html_a90aa9a854148c26da8232e25988623d8"><div class="ttname"><a href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">asio::detail::socket_ops::socket</a></div><div class="ttdeci">ASIO_DECL socket_type socket(int af, int type, int protocol, asio::error_code &amp;ec)</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_ac04f505f291ec3b9eb3018fea6835fea"><div class="ttname"><a href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">asio::experimental::void</a></div><div class="ttdeci">void</div><div class="ttdef"><b>Definition</b> co_spawn.hpp:131</div></div>
<div class="ttc" id="anamespaceasio_html_a23af44fc4cb32c36cb4280d4f7322c5b"><div class="ttname"><a href="#a23af44fc4cb32c36cb4280d4f7322c5b">asio::async_compose</a></div><div class="ttdeci">auto async_compose(Implementation &amp;&amp;implementation, type_identity_t&lt; CompletionToken &gt; &amp;token, IoObjectsOrExecutors &amp;&amp;... io_objects_or_executors) -&gt; decltype(async_initiate&lt; CompletionToken, Signature &gt;(composed&lt; Signature &gt;(static_cast&lt; Implementation &amp;&amp; &gt;(implementation), static_cast&lt; IoObjectsOrExecutors &amp;&amp; &gt;(io_objects_or_executors)...), token))</div><div class="ttdoc">Launch an asynchronous operation with a stateful implementation.</div><div class="ttdef"><b>Definition</b> compose.hpp:109</div></div>
<div class="ttc" id="anamespaceasio_html_a533d82c389058d9f3c70e6ba04fa5e78"><div class="ttname"><a href="#a533d82c389058d9f3c70e6ba04fa5e78">asio::async_write</a></div><div class="ttdeci">auto async_write(AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, WriteToken &amp;&amp;token=default_completion_token_t&lt; typename AsyncWriteStream::executor_type &gt;(), constraint_t&lt; is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;=0, constraint_t&lt; !is_completion_condition&lt; decay_t&lt; WriteToken &gt; &gt;::value &gt;=0) -&gt; decltype(async_initiate&lt; WriteToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_write&lt; AsyncWriteStream &gt; &gt;(), token, buffers, transfer_all()))</div><div class="ttdef"><b>Definition</b> write.hpp:818</div></div>
<div class="ttc" id="anamespaceasio_html_ac8914468bc40252ae5e5c666adb951cf"><div class="ttname"><a href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a></div><div class="ttdeci">std::error_code error_code</div><div class="ttdef"><b>Definition</b> error_code.hpp:26</div></div>
<div class="ttc" id="anamespaceasio_html_adb2ada9400d78a5df0e5f65dd2b9967e"><div class="ttname"><a href="#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a></div><div class="ttdeci">detail::transfer_exactly_t transfer_exactly(std::size_t size)</div><div class="ttdef"><b>Definition</b> completion_condition.hpp:255</div></div>
<div class="ttc" id="anamespaceasio_html_adff1e9f7bb336026f18afa2221c9df07"><div class="ttname"><a href="#adff1e9f7bb336026f18afa2221c9df07">asio::token</a></div><div class="ttdeci">awaitable&lt; T, AwaitableExecutor &gt; CompletionToken &amp;&amp; token</div><div class="ttdef"><b>Definition</b> co_spawn.hpp:359</div></div>
<div class="ttc" id="anamespaceasio_html_af691d016b23fd6c2da9ac91ce00c2e7e"><div class="ttname"><a href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a></div><div class="ttdeci">ASIO_NODISCARD ASIO_MUTABLE_BUFFER buffer(const mutable_buffer &amp;b) noexcept</div><div class="ttdoc">Create a new modifiable buffer from an existing buffer.</div><div class="ttdef"><b>Definition</b> buffer.hpp:862</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae014833b1e58f57eeeadffb356fd61cc" name="ae014833b1e58f57eeeadffb356fd61cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae014833b1e58f57eeeadffb356fd61cc">&#9670;&#160;</a></span>async_connect() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)) RangeConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeConnectToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value</td>          <td class="paramname"><span class="paramname"></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;RangeConnectToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, endpoints, connect_condition))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, <span class="keyword">typename</span> Protocol::endpoint) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::results_type results)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_function" href="#a48a844ab59bc144e7221613630c67936">asio::async_connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, results,</div>
<div class="line">        my_connect_condition(),</div>
<div class="line">        <a class="code hl_function" href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    <span class="keyword">const</span> tcp::endpoint&amp; endpoint)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// An error occurred.</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; endpoint &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} </div>
<div class="ttc" id="ablocking_8cpp_html_a0337bda4434eac48c7c441ec80725e39"><div class="ttname"><a href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a></div><div class="ttdeci">exec::blocking_t s</div><div class="ttdef"><b>Definition</b> blocking.cpp:26</div></div>
<div class="ttc" id="anamespaceasio_html_a48a844ab59bc144e7221613630c67936"><div class="ttname"><a href="#a48a844ab59bc144e7221613630c67936">asio::async_connect</a></div><div class="ttdeci">auto async_connect(basic_socket&lt; Protocol, Executor &gt; &amp;s, const EndpointSequence &amp;endpoints, RangeConnectToken &amp;&amp;token=default_completion_token_t&lt; Executor &gt;(), constraint_t&lt; is_endpoint_sequence&lt; EndpointSequence &gt;::value &gt;=0, constraint_t&lt; !is_connect_condition&lt; RangeConnectToken, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value &gt;=0) -&gt; decltype(async_initiate&lt; RangeConnectToken, void(asio::error_code, typename Protocol::endpoint)&gt;(declval&lt; detail::initiate_async_range_connect&lt; Protocol, Executor &gt; &gt;(), token, endpoints, declval&lt; detail::default_connect_condition &gt;()))</div><div class="ttdef"><b>Definition</b> connect.hpp:787</div></div>
<div class="ttc" id="aservices_2daytime__client_8cpp_html_aabdaf73cc003280ddecc73a18a0f7925"><div class="ttname"><a href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a></div><div class="ttdeci">void connect_handler(const asio::error_code &amp;e, tcp::socket *s)</div><div class="ttdef"><b>Definition</b> daytime_client.cpp:43</div></div>
<div class="ttc" id="astructasio_1_1execution_1_1detail_1_1blocking__t_html"><div class="ttname"><a href="structasio_1_1execution_1_1detail_1_1blocking__t.html">asio::execution::detail::blocking_t</a></div><div class="ttdef"><b>Definition</b> blocking.hpp:200</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="a48a844ab59bc144e7221613630c67936" name="a48a844ab59bc144e7221613630c67936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a844ab59bc144e7221613630c67936">&#9670;&#160;</a></span>async_connect() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)) RangeConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeConnectToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; RangeConnectToken, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value</td>          <td class="paramname"><span class="paramname"></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;RangeConnectToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, endpoints, declval&lt;<a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a>&gt;()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, the successfully connected endpoint.</span></div>
<div class="line">  <span class="comment">// Otherwise, a default-constructed endpoint.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; endpoint</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, <span class="keyword">typename</span> Protocol::endpoint) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::results_type results)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_function" href="#a48a844ab59bc144e7221613630c67936">asio::async_connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, results, <a class="code hl_function" href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    <span class="keyword">const</span> tcp::endpoint&amp; endpoint)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="ab18e1747520bfe97c456f5f3ea42dbb1" name="ab18e1747520bfe97c456f5f3ea42dbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18e1747520bfe97c456f5f3ea42dbb1">&#9670;&#160;</a></span>async_connect() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;IteratorConnectToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, Iterator(), connect_condition))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="a4e94bec2b227b6c91344b53cf60acf68" name="a4e94bec2b227b6c91344b53cf60acf68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e94bec2b227b6c91344b53cf60acf68">&#9670;&#160;</a></span>async_connect() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;IteratorConnectToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, end, connect_condition))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::iterator i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    tcp::resolver::iterator end;</div>
<div class="line">    <a class="code hl_function" href="#a48a844ab59bc144e7221613630c67936">asio::async_connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, i, end,</div>
<div class="line">        my_connect_condition(),</div>
<div class="line">        <a class="code hl_function" href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::iterator i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// An error occurred.</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="a08e9be68ae873ab4447b573babc08abc" name="a08e9be68ae873ab4447b573babc08abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e9be68ae873ab4447b573babc08abc">&#9670;&#160;</a></span>async_connect() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; IteratorConnectToken, Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;IteratorConnectToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, end, declval&lt;<a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a>&gt;()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> std::vector&lt;tcp::endpoint&gt; endpoints = ...;</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code hl_function" href="#a48a844ab59bc144e7221613630c67936">asio::async_connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    endpoints.begin(), endpoints.end(),</div>
<div class="line">    <a class="code hl_function" href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    std::vector&lt;tcp::endpoint&gt;::iterator i)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="a59cdf7b98b8069b934685f11d1c37219" name="a59cdf7b98b8069b934685f11d1c37219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cdf7b98b8069b934685f11d1c37219">&#9670;&#160;</a></span>async_connect() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_same&lt; Iterator, <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; IteratorConnectToken &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; IteratorConnectToken, Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;IteratorConnectToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, Iterator(),
        declval&lt;<a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a>&gt;()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="ac92acb7b19bae50850ec54e342707f06" name="ac92acb7b19bae50850ec54e342707f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92acb7b19bae50850ec54e342707f06">&#9670;&#160;</a></span>async_immediate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_immediate </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__immediate.html">detail::initiate_immediate</a>&lt;Executor&gt;&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch a trivial asynchronous operation that completes immediately. </p>
<p>The async_immediate function is intended for use by composed operations, which can delegate to this operation in order to implement the correct semantics for immediate completion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The asynchronous operation's I/O executor.</td></tr>
    <tr><td class="paramname">token</td><td>The completion token.</td></tr>
  </table>
  </dd>
</dl>
<p>The completion handler is immediately submitted for execution by calling <a class="el" href="#a0b53f4ff238fefdfbaf52153b89e6abd" title="Submits a completion token or function object for execution.">asio::dispatch()</a> on the handler's associated immediate executor.</p>
<p>If the completion handler does not have a customised associated immediate executor, then the handler is submitted as if by calling <a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a> on the supplied I/O executor.</p>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab2ca1e173361cca3b31df400eb3510b4" name="ab2ca1e173361cca3b31df400eb3510b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ca1e173361cca3b31df400eb3510b4">&#9670;&#160;</a></span>async_immediate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_immediate </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;ExecutionContext::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__immediate.html">detail::initiate_immediate</a>&lt;
        typename ExecutionContext::executor_type&gt;&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch a trivial asynchronous operation that completes immediately. </p>
<p>The async_immediate function is intended for use by composed operations, which can delegate to this operation in order to implement the correct semantics for immediate completion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The execution context used to obtain the asynchronous operation's I/O executor.</td></tr>
    <tr><td class="paramname">token</td><td>The completion token.</td></tr>
  </table>
  </dd>
</dl>
<p>The completion handler is immediately submitted for execution by calling <a class="el" href="#a0b53f4ff238fefdfbaf52153b89e6abd" title="Submits a completion token or function object for execution.">asio::dispatch()</a> on the handler's associated immediate executor.</p>
<p>If the completion handler does not have a customised associated immediate executor, then the handler is submitted as if by calling <a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a> on the I/O executor obtained from the supplied execution context.</p>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8ffaf73c9ee9ab21b6730aaf0839d73e" name="a8ffaf73c9ee9ab21b6730aaf0839d73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffaf73c9ee9ab21b6730aaf0839d73e">&#9670;&#160;</a></span>async_initiate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ASIO_COMPLETION_SIGNATURE... Signatures, typename CompletionToken , typename Initiation , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt;!<a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt; <a class="el" href="structasio_1_1detail_1_1are__completion__signatures.html">detail::are_completion_signatures</a>&lt; Signatures... &gt;::value, <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures... &gt; &gt;::value, <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Signatures... &gt; &gt;::return_type asio::async_initiate </td>
          <td>(</td>
          <td class="paramtype">Initiation &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>initiation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b9d86f999339de90ea243a750f1fff6" name="a4b9d86f999339de90ea243a750f1fff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9d86f999339de90ea243a750f1fff6">&#9670;&#160;</a></span>async_initiate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ASIO_COMPLETION_SIGNATURE... Signatures, typename CompletionToken , typename Initiation , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_initiate </td>
          <td>(</td>
          <td class="paramtype">Initiation &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>initiation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; decltype(<a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt;
    <a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt;
      <a class="el" href="structasio_1_1detail_1_1are__completion__signatures.html">detail::are_completion_signatures</a>&lt;Signatures...&gt;::value,
      <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt;
        CompletionToken, Signatures...&gt;&gt;::value,
    <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt;<a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt;CompletionToken&gt;, Signatures...&gt;&gt;::initiate(
      static_cast&lt;Initiation&amp;&amp;&gt;(initiation),
      static_cast&lt;CompletionToken&amp;&amp;&gt;(<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>),
      static_cast&lt;Args&amp;&amp;&gt;(args)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60102965258cfdce4bffa138efdd348e" name="a60102965258cfdce4bffa138efdd348e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60102965258cfdce4bffa138efdd348e">&#9670;&#160;</a></span>async_initiate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , ASIO_COMPLETION_SIGNATURE... Signatures, typename Initiation , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt;!<a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt; <a class="el" href="structasio_1_1detail_1_1are__completion__signatures.html">detail::are_completion_signatures</a>&lt; Signatures... &gt;::value, <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures... &gt; &gt;::value, <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Signatures... &gt; &gt;::return_type asio::async_initiate </td>
          <td>(</td>
          <td class="paramtype">Initiation &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>initiation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1bf2c6464b70e78b48be535c1dd8087f">type_identity_t</a>&lt; CompletionToken &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2209de8d875481208ea96c76c1c49e4" name="ab2209de8d875481208ea96c76c1c49e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2209de8d875481208ea96c76c1c49e4">&#9670;&#160;</a></span>async_initiate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , ASIO_COMPLETION_SIGNATURE... Signatures, typename Initiation , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_initiate </td>
          <td>(</td>
          <td class="paramtype">Initiation &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>initiation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1bf2c6464b70e78b48be535c1dd8087f">type_identity_t</a>&lt; CompletionToken &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; decltype(<a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt;
    <a class="el" href="#a56cbae0cd49c139578f11530959497f2">enable_if_t</a>&lt;
      <a class="el" href="structasio_1_1detail_1_1are__completion__signatures.html">detail::are_completion_signatures</a>&lt;Signatures...&gt;::value,
      <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt;
        CompletionToken, Signatures...&gt;&gt;::value,
    <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt;<a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt;CompletionToken&gt;, Signatures...&gt;&gt;::initiate(
      static_cast&lt;Initiation&amp;&amp;&gt;(initiation),
      static_cast&lt;CompletionToken&amp;&amp;&gt;(<a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>),
      static_cast&lt;Args&amp;&amp;&gt;(args)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8176a7863ba2f232a203488278128d3" name="af8176a7863ba2f232a203488278128d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8176a7863ba2f232a203488278128d3">&#9670;&#160;</a></span>async_read() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt;Allocator&gt;(b),
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a3a3441781514562a429bcccb3a337c13" name="a3a3441781514562a429bcccb3a337c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3441781514562a429bcccb3a337c13">&#9670;&#160;</a></span>async_read() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt;Allocator&gt;(b), <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#afd75bd16e41e5b4d383cf8a07d3ca14b">asio::async_read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a4a82e92df79aa8401a8bc2117d4cf900"><div class="ttname"><a href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a></div><div class="ttdeci">detail::transfer_all_t transfer_all()</div><div class="ttdef"><b>Definition</b> completion_condition.hpp:187</div></div>
<div class="ttc" id="anamespaceasio_html_afd75bd16e41e5b4d383cf8a07d3ca14b"><div class="ttname"><a href="#afd75bd16e41e5b4d383cf8a07d3ca14b">asio::async_read</a></div><div class="ttdeci">auto async_read(AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, ReadToken &amp;&amp;token=default_completion_token_t&lt; typename AsyncReadStream::executor_type &gt;(), constraint_t&lt; is_mutable_buffer_sequence&lt; MutableBufferSequence &gt;::value &gt;=0, constraint_t&lt; !is_completion_condition&lt; ReadToken &gt;::value &gt;=0) -&gt; decltype(async_initiate&lt; ReadToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_read&lt; AsyncReadStream &gt; &gt;(), token, buffers, transfer_all()))</div><div class="ttdef"><b>Definition</b> read.hpp:824</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="aaacc013eaeeb6d5038da0e9998f2a0dc" name="aaacc013eaeeb6d5038da0e9998f2a0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacc013eaeeb6d5038da0e9998f2a0dc">&#9670;&#160;</a></span>async_read() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read.html">detail::initiate_async_read</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers,
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#afd75bd16e41e5b4d383cf8a07d3ca14b">asio::async_read</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">   <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a2b10af704afcd6c7ed7f0d3b740033ef"><div class="ttname"><a href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a></div><div class="ttdeci">detail::transfer_at_least_t transfer_at_least(std::size_t minimum)</div><div class="ttdef"><b>Definition</b> completion_condition.hpp:221</div></div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="afd75bd16e41e5b4d383cf8a07d3ca14b" name="afd75bd16e41e5b4d383cf8a07d3ca14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd75bd16e41e5b4d383cf8a07d3ca14b">&#9670;&#160;</a></span>async_read() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename MutableBufferSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read.html">detail::initiate_async_read</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#afd75bd16e41e5b4d383cf8a07d3ca14b">asio::async_read</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#afd75bd16e41e5b4d383cf8a07d3ca14b">asio::async_read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a3c3bf347532ce7e48ba6400dd965d1d4" name="a3c3bf347532ce7e48ba6400dd965d1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3bf347532ce7e48ba6400dd965d1d4">&#9670;&#160;</a></span>async_read() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v1&amp;&amp;&gt;(buffers),
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a7fcc4c1550a60d467df0328bd089bda6" name="a7fcc4c1550a60d467df0328bd089bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcc4c1550a60d467df0328bd089bda6">&#9670;&#160;</a></span>async_read() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v1&amp;&amp;&gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#afd75bd16e41e5b4d383cf8a07d3ca14b">asio::async_read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="ad1731046973de30c9624f646b647ec3b" name="ad1731046973de30c9624f646b647ec3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1731046973de30c9624f646b647ec3b">&#9670;&#160;</a></span>async_read() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v2&amp;&amp;&gt;(buffers),
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="aa89986f4ea15b664a5600747f80da12c" name="aa89986f4ea15b664a5600747f80da12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89986f4ea15b664a5600747f80da12c">&#9670;&#160;</a></span>async_read() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v2&amp;&amp;&gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#afd75bd16e41e5b4d383cf8a07d3ca14b">asio::async_read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a8f825a5675cff97dd99b0d8648351c61" name="a8f825a5675cff97dd99b0d8648351c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f825a5675cff97dd99b0d8648351c61">&#9670;&#160;</a></span>async_read_at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncRandomAccessReadDevice::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessReadDevice::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__at__streambuf.html">detail::initiate_async_read_at_streambuf</a>&lt;
          AsyncRandomAccessReadDevice&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b,
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async_read_some_at function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessReadDevice</code> type's async_read_some_at operation. </p>

</div>
</div>
<a id="a910031a87e4cd31c3e9b6b30d3f40376" name="a910031a87e4cd31c3e9b6b30d3f40376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910031a87e4cd31c3e9b6b30d3f40376">&#9670;&#160;</a></span>async_read_at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncRandomAccessReadDevice::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessReadDevice::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__at__streambuf.html">detail::initiate_async_read_at_streambuf</a>&lt;
          AsyncRandomAccessReadDevice&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a430692bc6188b0a1a153a6c674b906a6">asio::async_read_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a430692bc6188b0a1a153a6c674b906a6"><div class="ttname"><a href="#a430692bc6188b0a1a153a6c674b906a6">asio::async_read_at</a></div><div class="ttdeci">auto async_read_at(AsyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, ReadToken &amp;&amp;token=default_completion_token_t&lt; typename AsyncRandomAccessReadDevice::executor_type &gt;(), constraint_t&lt; !is_completion_condition&lt; ReadToken &gt;::value &gt;=0) -&gt; decltype(async_initiate&lt; ReadToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_read_at&lt; AsyncRandomAccessReadDevice &gt; &gt;(), token, offset, buffers, transfer_all()))</div><div class="ttdef"><b>Definition</b> read_at.hpp:503</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessReadDevice</code> type's async_read_some_at operation. </p>

</div>
</div>
<a id="a72e97b034de0664fd029f0a4d2eeadd4" name="a72e97b034de0664fd029f0a4d2eeadd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e97b034de0664fd029f0a4d2eeadd4">&#9670;&#160;</a></span>async_read_at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncRandomAccessReadDevice::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessReadDevice::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__at.html">detail::initiate_async_read_at</a>&lt;AsyncRandomAccessReadDevice&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers,
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async_read_some_at function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a430692bc6188b0a1a153a6c674b906a6">asio::async_read_at</a>(d, 42,</div>
<div class="line">   <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessReadDevice</code> type's async_read_some_at operation. </p>

</div>
</div>
<a id="a430692bc6188b0a1a153a6c674b906a6" name="a430692bc6188b0a1a153a6c674b906a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430692bc6188b0a1a153a6c674b906a6">&#9670;&#160;</a></span>async_read_at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncRandomAccessReadDevice::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessReadDevice::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; ReadToken &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__at.html">detail::initiate_async_read_at</a>&lt;AsyncRandomAccessReadDevice&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a430692bc6188b0a1a153a6c674b906a6">asio::async_read_at</a>(d, 42, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a430692bc6188b0a1a153a6c674b906a6">asio::async_read_at</a>(</div>
<div class="line">   d, 42, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessReadDevice</code> type's async_read_some_at operation. </p>

</div>
</div>
<a id="aaaed75bf0fd3a9b11d12c10076ae4ecd" name="aaaed75bf0fd3a9b11d12c10076ae4ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaed75bf0fd3a9b11d12c10076ae4ecd">&#9670;&#160;</a></span>async_read_until() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v1.html">detail::initiate_async_read_until_delim_string_v1</a>&lt;
          AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt;Allocator&gt;(b),
        static_cast&lt;std::string&gt;(delim)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code hl_class" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::istream is(&amp;b);</div>
<div class="line">    std::string line;</div>
<div class="line">    std::getline(is, line);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
<div class="ttc" id="aclassasio_1_1basic__streambuf_html"><div class="ttname"><a href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a></div><div class="ttdoc">Automatically resizable buffer class based on std::streambuf.</div><div class="ttdef"><b>Definition</b> basic_streambuf.hpp:113</div></div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a19e014d9650dad2f7675b83af0cdf211" name="a19e014d9650dad2f7675b83af0cdf211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e014d9650dad2f7675b83af0cdf211">&#9670;&#160;</a></span>async_read_until() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v1.html">detail::initiate_async_read_until_delim_v1</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt;Allocator&gt;(b), delim))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code hl_class" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::istream is(&amp;b);</div>
<div class="line">    std::string line;</div>
<div class="line">    std::getline(is, line);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a72f36fca2afc5ab50b0279f4c41d7b89" name="a72f36fca2afc5ab50b0279f4c41d7b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f36fca2afc5ab50b0279f4c41d7b89">&#9670;&#160;</a></span>async_read_until() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename MatchCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v1.html">detail::initiate_async_read_until_match_v1</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt;Allocator&gt;(b), match_condition))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a streambuf until a function object indicates a match. This function is used to asynchronously read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type</a>&gt;</div>
<div class="ttc" id="aclassasio_1_1buffers__iterator_html"><div class="ttname"><a href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a></div><div class="ttdoc">A random access iterator over the bytes in a buffer sequence.</div><div class="ttdef"><b>Definition</b> buffers_iterator.hpp:111</div></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area that have been fully consumed by the</span></div>
<div class="line">  <span class="comment">// match function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::streambuf::const_buffers_type</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">asio::streambuf b;</div>
<div class="line"><a class="code hl_function" href="#ad59786d012e76a0fa1eac177837b3433">asio::async_read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, match_whitespace, handler);</div>
<div class="ttc" id="aclassasio_1_1basic__streambuf_html_a9e2ffddcb9e89d68048254ea787c2258"><div class="ttname"><a href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::basic_streambuf::const_buffers_type</a></div><div class="ttdeci">ASIO_CONST_BUFFER const_buffers_type</div><div class="ttdef"><b>Definition</b> basic_streambuf.hpp:122</div></div>
<div class="ttc" id="anamespaceasio_html_ad59786d012e76a0fa1eac177837b3433"><div class="ttname"><a href="#ad59786d012e76a0fa1eac177837b3433">asio::async_read_until</a></div><div class="ttdeci">auto async_read_until(AsyncReadStream &amp;s, DynamicBuffer_v1 &amp;&amp;buffers, char delim, ReadToken &amp;&amp;token=default_completion_token_t&lt; typename AsyncReadStream::executor_type &gt;(), constraint_t&lt; is_dynamic_buffer_v1&lt; decay_t&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0, constraint_t&lt; !is_dynamic_buffer_v2&lt; decay_t&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;=0) -&gt; decltype(async_initiate&lt; ReadToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_read_until_delim_v1&lt; AsyncReadStream &gt; &gt;(), token, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), delim))</div><div class="ttdef"><b>Definition</b> read_until.hpp:1658</div></div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code hl_class" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> c) : c_(c) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code hl_class" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">asio::streambuf b;</div>
<div class="line"><a class="code hl_function" href="#ad59786d012e76a0fa1eac177837b3433">asio::async_read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
<div class="ttc" id="aclassmatch__char_html"><div class="ttname"><a href="classmatch__char.html">match_char</a></div><div class="ttdef"><b>Definition</b> read_until.cpp:457</div></div>
<div class="ttc" id="anamespaceasio_html"><div class="ttname"><a href="namespaceasio.html">asio</a></div><div class="ttdef"><b>Definition</b> any_completion_executor.hpp:27</div></div>
</div><!-- fragment --><dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="ad6f4777d439e2f06e5fb672174a91fbd" name="ad6f4777d439e2f06e5fb672174a91fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f4777d439e2f06e5fb672174a91fbd">&#9670;&#160;</a></span>async_read_until() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v1.html">detail::initiate_async_read_until_delim_string_v1</a>&lt;
          AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v1&amp;&amp;&gt;(buffers),
        static_cast&lt;std::string&gt;(delim)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = data.substr(0, n);</div>
<div class="line">    data.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the string <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="ad59786d012e76a0fa1eac177837b3433" name="ad59786d012e76a0fa1eac177837b3433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59786d012e76a0fa1eac177837b3433">&#9670;&#160;</a></span>async_read_until() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v1.html">detail::initiate_async_read_until_delim_v1</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v1&amp;&amp;&gt;(buffers), delim))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = data.substr(0, n);</div>
<div class="line">    data.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a89c3116ca59cbf749a21c68cb01b8b75" name="a89c3116ca59cbf749a21c68cb01b8b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c3116ca59cbf749a21c68cb01b8b75">&#9670;&#160;</a></span>async_read_until() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v1.html">detail::initiate_async_read_until_match_v1</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v1&amp;&amp;&gt;(buffers),
        match_condition))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;typename DynamicBuffer_v1::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area that have been fully consumed by the match</span></div>
<div class="line">  <span class="comment">// function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a <code>std::string</code> until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code hl_function" href="#ad59786d012e76a0fa1eac177837b3433">asio::async_read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, match_whitespace, handler);</div>
<div class="ttc" id="aclassasio_1_1const__buffers__1_html"><div class="ttname"><a href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a></div><div class="ttdef"><b>Definition</b> buffer.hpp:294</div></div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code hl_class" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> c) : c_(c) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code hl_class" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code hl_function" href="#ad59786d012e76a0fa1eac177837b3433">asio::async_read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
</div><!-- fragment --><dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a89eaef18725de397c4608e18ddaa66fb" name="a89eaef18725de397c4608e18ddaa66fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89eaef18725de397c4608e18ddaa66fb">&#9670;&#160;</a></span>async_read_until() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v2.html">detail::initiate_async_read_until_delim_string_v2</a>&lt;
          AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v2&amp;&amp;&gt;(buffers),
        static_cast&lt;std::string&gt;(delim)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = data.substr(0, n);</div>
<div class="line">    data.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the string <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a078a2e41de987ab22655278489aab1ff" name="a078a2e41de987ab22655278489aab1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078a2e41de987ab22655278489aab1ff">&#9670;&#160;</a></span>async_read_until() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v2.html">detail::initiate_async_read_until_delim_v2</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v2&amp;&amp;&gt;(buffers), delim))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = data.substr(0, n);</div>
<div class="line">    data.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="aca8002fac0002df210a130a197955de8" name="aca8002fac0002df210a130a197955de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8002fac0002df210a130a197955de8">&#9670;&#160;</a></span>async_read_until() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) ReadToken = default_completion_token_t&lt;        typename AsyncReadStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;ReadToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v2.html">detail::initiate_async_read_until_match_v2</a>&lt;AsyncReadStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v2&amp;&amp;&gt;(buffers), match_condition))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;typename DynamicBuffer_v2::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area that have been fully consumed by the match</span></div>
<div class="line">  <span class="comment">// function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a <code>std::string</code> until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code hl_function" href="#ad59786d012e76a0fa1eac177837b3433">asio::async_read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, match_whitespace, handler);</div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code hl_class" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> c) : c_(c) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code hl_class" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code hl_function" href="#ad59786d012e76a0fa1eac177837b3433">asio::async_read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
</div><!-- fragment --><dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="aefd2755ce3755858e8911da8aa6b948e" name="aefd2755ce3755858e8911da8aa6b948e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd2755ce3755858e8911da8aa6b948e">&#9670;&#160;</a></span>async_write() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename Allocator , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;AsyncWriteStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt;AsyncWriteStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt;Allocator&gt;(b),
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a7409312aefe6e03ea88376620972d23b" name="a7409312aefe6e03ea88376620972d23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7409312aefe6e03ea88376620972d23b">&#9670;&#160;</a></span>async_write() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;AsyncWriteStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; WriteToken &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt;AsyncWriteStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt;Allocator&gt;(b), <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a089960c923e61aee5d92f1ace654fb3f" name="a089960c923e61aee5d92f1ace654fb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089960c923e61aee5d92f1ace654fb3f">&#9670;&#160;</a></span>async_write() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename ConstBufferSequence , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;AsyncWriteStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write.html">detail::initiate_async_write</a>&lt;AsyncWriteStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers,
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a533d82c389058d9f3c70e6ba04fa5e78">asio::async_write</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">   <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a533d82c389058d9f3c70e6ba04fa5e78" name="a533d82c389058d9f3c70e6ba04fa5e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533d82c389058d9f3c70e6ba04fa5e78">&#9670;&#160;</a></span>async_write() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename ConstBufferSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;AsyncWriteStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; WriteToken &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write.html">detail::initiate_async_write</a>&lt;AsyncWriteStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a533d82c389058d9f3c70e6ba04fa5e78">asio::async_write</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a7d434b0260a68500361316b2bd888177" name="a7d434b0260a68500361316b2bd888177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d434b0260a68500361316b2bd888177">&#9670;&#160;</a></span>async_write() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;AsyncWriteStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt;AsyncWriteStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v1&amp;&amp;&gt;(buffers),
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a6d2d0559eb8932481693248bc681e9b2" name="a6d2d0559eb8932481693248bc681e9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2d0559eb8932481693248bc681e9b2">&#9670;&#160;</a></span>async_write() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename DynamicBuffer_v1 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;AsyncWriteStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; WriteToken &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt;AsyncWriteStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v1&amp;&amp;&gt;(buffers),
        <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a7ed3cbf3f061ea5409ef0a2927a79cc3" name="a7ed3cbf3f061ea5409ef0a2927a79cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed3cbf3f061ea5409ef0a2927a79cc3">&#9670;&#160;</a></span>async_write() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;AsyncWriteStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v2.html">detail::initiate_async_write_dynbuf_v2</a>&lt;AsyncWriteStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v2&amp;&amp;&gt;(buffers),
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="adbf955b3f12a92f598f023b26bfd797c" name="adbf955b3f12a92f598f023b26bfd797c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf955b3f12a92f598f023b26bfd797c">&#9670;&#160;</a></span>async_write() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename DynamicBuffer_v2 , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;typename AsyncWriteStream::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;AsyncWriteStream::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; WriteToken &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v2.html">detail::initiate_async_write_dynbuf_v2</a>&lt;AsyncWriteStream&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;DynamicBuffer_v2&amp;&amp;&gt;(buffers),
        <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a2303f42308ad87e66258ac91f054b802" name="a2303f42308ad87e66258ac91f054b802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2303f42308ad87e66258ac91f054b802">&#9670;&#160;</a></span>async_write_at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;        typename AsyncRandomAccessWriteDevice::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessWriteDevice::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__at__streambuf.html">detail::initiate_async_write_at_streambuf</a>&lt;
          AsyncRandomAccessWriteDevice&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b,
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async_write_some_at function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessWriteDevice</code> type's async_write_some_at operation. </p>

</div>
</div>
<a id="a7276889f384d00307567904eb7a9cbd6" name="a7276889f384d00307567904eb7a9cbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7276889f384d00307567904eb7a9cbd6">&#9670;&#160;</a></span>async_write_at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;        typename AsyncRandomAccessWriteDevice::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessWriteDevice::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; WriteToken &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__at__streambuf.html">detail::initiate_async_write_at_streambuf</a>&lt;
          AsyncRandomAccessWriteDevice&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessWriteDevice</code> type's async_write_some_at operation. </p>

</div>
</div>
<a id="a27189f7643805cd852d5904efa46a577" name="a27189f7643805cd852d5904efa46a577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27189f7643805cd852d5904efa46a577">&#9670;&#160;</a></span>async_write_at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;        typename AsyncRandomAccessWriteDevice::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessWriteDevice::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__at.html">detail::initiate_async_write_at</a>&lt;
          AsyncRandomAccessWriteDevice&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers,
        static_cast&lt;CompletionCondition&amp;&amp;&gt;(completion_condition)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async_write_some_at function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a244cc7d7d962349e73370d38bfc55d95">asio::async_write_at</a>(d, 42,</div>
<div class="line">   <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a244cc7d7d962349e73370d38bfc55d95"><div class="ttname"><a href="#a244cc7d7d962349e73370d38bfc55d95">asio::async_write_at</a></div><div class="ttdeci">auto async_write_at(AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, WriteToken &amp;&amp;token=default_completion_token_t&lt; typename AsyncRandomAccessWriteDevice::executor_type &gt;(), constraint_t&lt; !is_completion_condition&lt; WriteToken &gt;::value &gt;=0) -&gt; decltype(async_initiate&lt; WriteToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_write_at&lt; AsyncRandomAccessWriteDevice &gt; &gt;(), token, offset, buffers, transfer_all()))</div><div class="ttdef"><b>Definition</b> write_at.hpp:500</div></div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessWriteDevice</code> type's async_write_some_at operation. </p>

</div>
</div>
<a id="a244cc7d7d962349e73370d38bfc55d95" name="a244cc7d7d962349e73370d38bfc55d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244cc7d7d962349e73370d38bfc55d95">&#9670;&#160;</a></span>async_write_at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void(<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)) WriteToken = default_completion_token_t&lt;        typename AsyncRandomAccessWriteDevice::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessWriteDevice::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; WriteToken &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;WriteToken,
      void (<a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__write__at.html">detail::initiate_async_write_at</a>&lt;
          AsyncRandomAccessWriteDevice&gt;&gt;(),
        <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="#ac92acb7b19bae50850ec54e342707f06" title="Launch a trivial asynchronous operation that completes immediately.">asio::async_immediate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a244cc7d7d962349e73370d38bfc55d95">asio::async_write_at</a>(d, 42, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessWriteDevice</code> type's async_write_some_at operation. </p>

</div>
</div>
<a id="a98eac0f8769eefb8a4e053af0331fdc2" name="a98eac0f8769eefb8a4e053af0331fdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98eac0f8769eefb8a4e053af0331fdc2">&#9670;&#160;</a></span>bind_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__allocator__binder.html">partial_allocator_binder</a>&lt; Allocator &gt; asio::bind_allocator </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a partial completion token that associates an allocator. </p>

</div>
</div>
<a id="a6873210f37c06a1da52cf61bb8e0a5fd" name="a6873210f37c06a1da52cf61bb8e0a5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6873210f37c06a1da52cf61bb8e0a5fd">&#9670;&#160;</a></span>bind_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1allocator__binder.html">allocator_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, Allocator &gt; asio::bind_allocator </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associate an object of type <code>T</code> with an allocator of type <code>Allocator</code>. </p>

</div>
</div>
<a id="aea42498f5edae0a0794894ba2ed21943" name="aea42498f5edae0a0794894ba2ed21943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea42498f5edae0a0794894ba2ed21943">&#9670;&#160;</a></span>bind_cancellation_slot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CancellationSlot &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__cancellation__slot__binder.html">partial_cancellation_slot_binder</a>&lt; CancellationSlot &gt; asio::bind_cancellation_slot </td>
          <td>(</td>
          <td class="paramtype">const CancellationSlot &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a partial completion token that associates a cancellation slot. </p>

</div>
</div>
<a id="aa03eb972eeb2205c02024c6b1b6ec900" name="aa03eb972eeb2205c02024c6b1b6ec900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03eb972eeb2205c02024c6b1b6ec900">&#9670;&#160;</a></span>bind_cancellation_slot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CancellationSlot , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancellation__slot__binder.html">cancellation_slot_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, CancellationSlot &gt; asio::bind_cancellation_slot </td>
          <td>(</td>
          <td class="paramtype">const CancellationSlot &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associate an object of type <code>T</code> with a cancellation slot of type <code>CancellationSlot</code>. </p>

</div>
</div>
<a id="af7a5bbf9f5cfd6b2487b24188ac267e1" name="af7a5bbf9f5cfd6b2487b24188ac267e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a5bbf9f5cfd6b2487b24188ac267e1">&#9670;&#160;</a></span>bind_executor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__executor__binder.html">partial_executor_binder</a>&lt; Executor &gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a partial completion token that associates an executor. </p>

</div>
</div>
<a id="af4753991b2abb85968b93d956cccdedb" name="af4753991b2abb85968b93d956cccdedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4753991b2abb85968b93d956cccdedb">&#9670;&#160;</a></span>bind_executor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, Executor &gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate an object of type <code>T</code> with an executor of type <code>Executor</code>. </p>

</div>
</div>
<a id="aea54c730a26b96924b64fbb557282a3e" name="aea54c730a26b96924b64fbb557282a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea54c730a26b96924b64fbb557282a3e">&#9670;&#160;</a></span>bind_executor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__executor__binder.html">partial_executor_binder</a>&lt; typename ExecutionContext::executor_type &gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a partial completion token that associates an execution context's executor. </p>

</div>
</div>
<a id="a842643dcfed065d8a99de34575e5a0e1" name="a842643dcfed065d8a99de34575e5a0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842643dcfed065d8a99de34575e5a0e1">&#9670;&#160;</a></span>bind_executor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, typename ExecutionContext::executor_type &gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate an object of type <code>T</code> with an execution context's executor. </p>

</div>
</div>
<a id="afdb335b2d8b9d84fb5f21ee1bca79287" name="afdb335b2d8b9d84fb5f21ee1bca79287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb335b2d8b9d84fb5f21ee1bca79287">&#9670;&#160;</a></span>bind_immediate_executor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1immediate__executor__binder.html">immediate_executor_binder</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; T &gt;, Executor &gt; asio::bind_immediate_executor </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associate an object of type <code>T</code> with a immediate executor of type <code>Executor</code>. </p>

</div>
</div>
<a id="a6a16fd72a8c7adcb9f00666e1291b8cc" name="a6a16fd72a8c7adcb9f00666e1291b8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a16fd72a8c7adcb9f00666e1291b8cc">&#9670;&#160;</a></span>bind_immediate_executor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1partial__immediate__executor__binder.html">partial_immediate_executor_binder</a>&lt; Executor &gt; asio::bind_immediate_executor </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a partial completion token that associates an executor. </p>

</div>
</div>
<a id="a0a2e76bbc8d686f8c816fe49873a4666" name="a0a2e76bbc8d686f8c816fe49873a4666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2e76bbc8d686f8c816fe49873a4666">&#9670;&#160;</a></span>buffer() <span class="overload">[1/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
<div class="ttc" id="aclassasio_1_1const__buffer_html"><div class="ttname"><a href="classasio_1_1const__buffer.html">asio::const_buffer</a></div><div class="ttdoc">Holds a buffer that cannot be modified.</div><div class="ttdef"><b>Definition</b> buffer.hpp:213</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a00c6a9bbe7e9cba49430d37caae476cd" name="a00c6a9bbe7e9cba49430d37caae476cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c6a9bbe7e9cba49430d37caae476cd">&#9670;&#160;</a></span>buffer() <span class="overload">[2/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8e6a0ab72797048aa4629781e650d65e" name="a8e6a0ab72797048aa4629781e650d65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6a0ab72797048aa4629781e650d65e">&#9670;&#160;</a></span>buffer() <span class="overload">[3/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af92b80f670c5f74b5402342f87fd9d28" name="af92b80f670c5f74b5402342f87fd9d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92b80f670c5f74b5402342f87fd9d28">&#9670;&#160;</a></span>buffer() <span class="overload">[4/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3e2c9f5266bd40548109072a006bd4db" name="a3e2c9f5266bd40548109072a006bd4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2c9f5266bd40548109072a006bd4db">&#9670;&#160;</a></span>buffer() <span class="overload">[5/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>const_buffer(b)</code>. </dd></dl>

</div>
</div>
<a id="a8e22c4da973f9cec891970c007ea8a7b" name="a8e22c4da973f9cec891970c007ea8a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e22c4da973f9cec891970c007ea8a7b">&#9670;&#160;</a></span>buffer() <span class="overload">[6/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   b.data(),</div>
<div class="line">   min(b.size(), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a83bc6057a4682b36c1180b56107ff160" name="a83bc6057a4682b36c1180b56107ff160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83bc6057a4682b36c1180b56107ff160">&#9670;&#160;</a></span>buffer() <span class="overload">[7/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a buffer representing the entire registered buffer. </p>

</div>
</div>
<a id="aaaa87a00e12c0e47cf34203dfb2c3ef1" name="aaaa87a00e12c0e47cf34203dfb2c3ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa87a00e12c0e47cf34203dfb2c3ef1">&#9670;&#160;</a></span>buffer() <span class="overload">[8/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a buffer representing part of a registered buffer. </p>

</div>
</div>
<a id="af691d016b23fd6c2da9ac91ce00c2e7e" name="af691d016b23fd6c2da9ac91ce00c2e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af691d016b23fd6c2da9ac91ce00c2e7e">&#9670;&#160;</a></span>buffer() <span class="overload">[9/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>mutable_buffer(b)</code>. </dd></dl>

</div>
</div>
<a id="a2b4a73cd878cb3ce83da935fb9932f23" name="a2b4a73cd878cb3ce83da935fb9932f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4a73cd878cb3ce83da935fb9932f23">&#9670;&#160;</a></span>buffer() <span class="overload">[10/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   b.data(),</div>
<div class="line">   min(b.size(), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="afe13ad24e316f94e7ff8a197ac2a40be" name="afe13ad24e316f94e7ff8a197ac2a40be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe13ad24e316f94e7ff8a197ac2a40be">&#9670;&#160;</a></span>buffer() <span class="overload">[11/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a buffer representing the entire registered buffer. </p>

</div>
</div>
<a id="aacafdf44af129753e05ba770785b4acc" name="aacafdf44af129753e05ba770785b4acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacafdf44af129753e05ba770785b4acc">&#9670;&#160;</a></span>buffer() <span class="overload">[12/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a buffer representing part of a registered buffer. </p>

</div>
</div>
<a id="a1f2b1693298fb564b28c7440eff1774e" name="a1f2b1693298fb564b28c7440eff1774e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2b1693298fb564b28c7440eff1774e">&#9670;&#160;</a></span>buffer() <span class="overload">[13/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const PodType(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(data),</div>
<div class="line">   N * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a66b5df59bccdd5b06f8d93416472105c" name="a66b5df59bccdd5b06f8d93416472105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b5df59bccdd5b06f8d93416472105c">&#9670;&#160;</a></span>buffer() <span class="overload">[14/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const PodType(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(data),</div>
<div class="line">   min(N * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac28b3f525cd9132dde4eceff0d1c8611" name="ac28b3f525cd9132dde4eceff0d1c8611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28b3f525cd9132dde4eceff0d1c8611">&#9670;&#160;</a></span>buffer() <span class="overload">[15/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>(data.data(), data.size() * sizeof(Elem))</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="aca8ad05e2147e00fe0019da3b12caac1" name="aca8ad05e2147e00fe0019da3b12caac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8ad05e2147e00fe0019da3b12caac1">&#9670;&#160;</a></span>buffer() <span class="overload">[16/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a32d16f55d0457afe5971519eafa4f2b2" name="a32d16f55d0457afe5971519eafa4f2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d16f55d0457afe5971519eafa4f2b2">&#9670;&#160;</a></span>buffer() <span class="overload">[17/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PodType, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * sizeof(PodType)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="aa8958d330420418a8ca049279026dc3f" name="aa8958d330420418a8ca049279026dc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8958d330420418a8ca049279026dc3f">&#9670;&#160;</a></span>buffer() <span class="overload">[18/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PodType, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(data.size() * sizeof(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="a7df15a068b182e5dbc67e7a9831ac663" name="a7df15a068b182e5dbc67e7a9831ac663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df15a068b182e5dbc67e7a9831ac663">&#9670;&#160;</a></span>buffer() <span class="overload">[19/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::const_iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * sizeof(typename T::value_type)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1725cb81df773d48f415111dc9d66d07" name="a1725cb81df773d48f415111dc9d66d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1725cb81df773d48f415111dc9d66d07">&#9670;&#160;</a></span>buffer() <span class="overload">[20/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::const_iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(</div>
<div class="line">     data.size() * sizeof(typename T::value_type),</div>
<div class="line">     max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a609e222330f06ff048c78d40431953e5" name="a609e222330f06ff048c78d40431953e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609e222330f06ff048c78d40431953e5">&#9670;&#160;</a></span>buffer() <span class="overload">[21/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Returns</dt><dd><code>const_buffer(data, size_in_bytes)</code>. </dd></dl>

</div>
</div>
<a id="a4ddf466e8044ce08813fc66d4097d213" name="a4ddf466e8044ce08813fc66d4097d213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddf466e8044ce08813fc66d4097d213">&#9670;&#160;</a></span>buffer() <span class="overload">[22/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(data),</div>
<div class="line">   N * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a56a0a6ae44a23ca25b1836da782cd616" name="a56a0a6ae44a23ca25b1836da782cd616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a0a6ae44a23ca25b1836da782cd616">&#9670;&#160;</a></span>buffer() <span class="overload">[23/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(data),</div>
<div class="line">   min(N * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adfa3e7d25d0f90000eebc400c02dfbf0" name="adfa3e7d25d0f90000eebc400c02dfbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa3e7d25d0f90000eebc400c02dfbf0">&#9670;&#160;</a></span>buffer() <span class="overload">[24/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; const PodType, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae1f602fab6a887916ee3aac0769dc46a" name="ae1f602fab6a887916ee3aac0769dc46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f602fab6a887916ee3aac0769dc46a">&#9670;&#160;</a></span>buffer() <span class="overload">[25/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; const PodType, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5da2efeb42c04e368055e1b5f7780132" name="a5da2efeb42c04e368055e1b5f7780132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da2efeb42c04e368055e1b5f7780132">&#9670;&#160;</a></span>buffer() <span class="overload">[26/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; PodType, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aff494b6b08d0ae82723ec370cd91d39a" name="aff494b6b08d0ae82723ec370cd91d39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff494b6b08d0ae82723ec370cd91d39a">&#9670;&#160;</a></span>buffer() <span class="overload">[27/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; PodType, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a691ba65873879c5541119faff29aa0f4" name="a691ba65873879c5541119faff29aa0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691ba65873879c5541119faff29aa0f4">&#9670;&#160;</a></span>buffer() <span class="overload">[28/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a>(data.size() ? &amp;data[0] : 0, data.size() * sizeof(Elem))</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a1dc4d596625f545097450584d532a71e" name="a1dc4d596625f545097450584d532a71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc4d596625f545097450584d532a71e">&#9670;&#160;</a></span>buffer() <span class="overload">[29/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(data.size() * sizeof(Elem), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a84688fa20c384874e1eddf5c81d8c331" name="a84688fa20c384874e1eddf5c81d8c331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84688fa20c384874e1eddf5c81d8c331">&#9670;&#160;</a></span>buffer() <span class="overload">[30/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * sizeof(PodType)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="af717cc04e6415768402160b063ec6202" name="af717cc04e6415768402160b063ec6202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af717cc04e6415768402160b063ec6202">&#9670;&#160;</a></span>buffer() <span class="overload">[31/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(data.size() * sizeof(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="aeb3bc2e4b9e6bf8ff64eab08344002aa" name="aeb3bc2e4b9e6bf8ff64eab08344002aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3bc2e4b9e6bf8ff64eab08344002aa">&#9670;&#160;</a></span>buffer() <span class="overload">[32/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_const&lt; <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * sizeof(typename T::value_type)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9025af2d8c7f20168a21c860ce06d2fd" name="a9025af2d8c7f20168a21c860ce06d2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9025af2d8c7f20168a21c860ce06d2fd">&#9670;&#160;</a></span>buffer() <span class="overload">[33/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_const&lt; <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * sizeof(typename T::value_type)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a230a757727dfa8eac34c54df06cf6fa0" name="a230a757727dfa8eac34c54df06cf6fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230a757727dfa8eac34c54df06cf6fa0">&#9670;&#160;</a></span>buffer() <span class="overload">[34/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_const&lt; <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(</div>
<div class="line">     data.size() * sizeof(typename T::value_type),</div>
<div class="line">     max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a52644e5a827859367e71ebeafe1a9fca" name="a52644e5a827859367e71ebeafe1a9fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52644e5a827859367e71ebeafe1a9fca">&#9670;&#160;</a></span>buffer() <span class="overload">[35/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_const&lt; <a class="el" href="#a8f77cce220380ae23fa06dbf2181a30a">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(</div>
<div class="line">     data.size() * sizeof(typename T::value_type),</div>
<div class="line">     max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a390401d56dbdf838be8a09ec7ce4d4d4" name="a390401d56dbdf838be8a09ec7ce4d4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390401d56dbdf838be8a09ec7ce4d4d4">&#9670;&#160;</a></span>buffer() <span class="overload">[36/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Returns</dt><dd><code>mutable_buffer(data, size_in_bytes)</code>. </dd></dl>

</div>
</div>
<a id="a240b9552e7e1deb855c98e11583b88a5" name="a240b9552e7e1deb855c98e11583b88a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240b9552e7e1deb855c98e11583b88a5">&#9670;&#160;</a></span>buffer_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerToPodType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointerToPodType asio::buffer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a non-modifiable buffer to a specified pointer to POD type. </p>

</div>
</div>
<a id="a8365a4bf9ba53918c758263fd3b0fb36" name="a8365a4bf9ba53918c758263fd3b0fb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8365a4bf9ba53918c758263fd3b0fb36">&#9670;&#160;</a></span>buffer_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerToPodType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointerToPodType asio::buffer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a non-modifiable buffer to a specified pointer to POD type. </p>

</div>
</div>
<a id="a9ab876ca15e1fd4f5f12caa8e0cac327" name="a9ab876ca15e1fd4f5f12caa8e0cac327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab876ca15e1fd4f5f12caa8e0cac327">&#9670;&#160;</a></span>buffer_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_copy </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies bytes from a source buffer sequence to a target buffer sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>A modifiable buffer sequence representing the memory regions to which the bytes will be copied.</td></tr>
    <tr><td class="paramname">source</td><td>A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of bytes copied is the lesser of:</dd></dl>
<ul>
<li><code>buffer_size(target)</code> </li>
</ul>
<ul>
<li><code>buffer_size(source)</code> </li>
</ul>
<p>This function is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions. </p>

</div>
</div>
<a id="a4f84f2c9b443140a1b8693c5491ffde4" name="a4f84f2c9b443140a1b8693c5491ffde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f84f2c9b443140a1b8693c5491ffde4">&#9670;&#160;</a></span>buffer_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_copy </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_bytes_to_copy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a limited number of bytes from a source buffer sequence to a target buffer sequence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>A modifiable buffer sequence representing the memory regions to which the bytes will be copied.</td></tr>
    <tr><td class="paramname">source</td><td>A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.</td></tr>
    <tr><td class="paramname">max_bytes_to_copy</td><td>The maximum number of bytes to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of bytes copied is the lesser of:</dd></dl>
<ul>
<li><code>buffer_size(target)</code> </li>
</ul>
<ul>
<li><code>buffer_size(source)</code> </li>
</ul>
<ul>
<li><code>max_bytes_to_copy</code> </li>
</ul>
<p>This function is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions. </p>

</div>
</div>
<a id="afbcd07567a0f9eeaacd8bd0b08689e80" name="afbcd07567a0f9eeaacd8bd0b08689e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcd07567a0f9eeaacd8bd0b08689e80">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a1288ea04d255a07a8050e8016b554d0b" name="a1288ea04d255a07a8050e8016b554d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1288ea04d255a07a8050e8016b554d0b">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a95c94685a98b1d93e7f90b1168e3c3eb" name="a95c94685a98b1d93e7f90b1168e3c3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c94685a98b1d93e7f90b1168e3c3eb">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="aba5379d7d15e3bba2686bb4ae4501cf0" name="aba5379d7d15e3bba2686bb4ae4501cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5379d7d15e3bba2686bb4ae4501cf0">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const ConstBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; const ConstBuffer *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a9efef73a4b2f1f8de3e2ea5573316333" name="a9efef73a4b2f1f8de3e2ea5573316333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efef73a4b2f1f8de3e2ea5573316333">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a17e0bcfde373158541e95fc70d778a83" name="a17e0bcfde373158541e95fc70d778a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e0bcfde373158541e95fc70d778a83">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const MutableBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; const MutableBuffer *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="afe41182ab29c34a81752396b25ba0d1a" name="afe41182ab29c34a81752396b25ba0d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe41182ab29c34a81752396b25ba0d1a">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="ab7a057966e62697d09cafab0009eda0e" name="ab7a057966e62697d09cafab0009eda0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a057966e62697d09cafab0009eda0e">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a3f5bbedd70cf1b2a0f6b9e1a86ab0533" name="a3f5bbedd70cf1b2a0f6b9e1a86ab0533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5bbedd70cf1b2a0f6b9e1a86ab0533">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a6000fe4e6f28afe90848ce314b6f4ba9" name="a6000fe4e6f28afe90848ce314b6f4ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6000fe4e6f28afe90848ce314b6f4ba9">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const ConstBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; const ConstBuffer *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a133bf449a986c6c427b7c865e8a944eb" name="a133bf449a986c6c427b7c865e8a944eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133bf449a986c6c427b7c865e8a944eb">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a95a21227870fa0ff7261f8c452dc83fd" name="a95a21227870fa0ff7261f8c452dc83fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a21227870fa0ff7261f8c452dc83fd">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const MutableBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; const MutableBuffer *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a32ffb00a82a2cb0dcbb976e02d82cc79" name="a32ffb00a82a2cb0dcbb976e02d82cc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ffb00a82a2cb0dcbb976e02d82cc79">&#9670;&#160;</a></span>buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_size </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of bytes in a buffer sequence. </p>
<p>The <code>buffer_size</code> function determines the total size of all buffers in the buffer sequence, as if computed as follows:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">size_t</span> total_size = 0;</div>
<div class="line"><span class="keyword">auto</span> i = <a class="code hl_function" href="#a17e0bcfde373158541e95fc70d778a83">asio::buffer_sequence_begin</a>(buffers);</div>
<div class="line"><span class="keyword">auto</span> end = <a class="code hl_function" href="#a95a21227870fa0ff7261f8c452dc83fd">asio::buffer_sequence_end</a>(buffers);</div>
<div class="line"><span class="keywordflow">for</span> (; i != end; ++i)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a> b(*i);</div>
<div class="line">  total_size += b.size();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> total_size; </div>
<div class="ttc" id="anamespaceasio_html_a17e0bcfde373158541e95fc70d778a83"><div class="ttname"><a href="#a17e0bcfde373158541e95fc70d778a83">asio::buffer_sequence_begin</a></div><div class="ttdeci">const mutable_buffer * buffer_sequence_begin(const MutableBuffer &amp;b, constraint_t&lt; is_convertible&lt; const MutableBuffer *, const mutable_buffer * &gt;::value &gt;=0) noexcept</div><div class="ttdoc">Get an iterator to the first element in a buffer sequence.</div><div class="ttdef"><b>Definition</b> buffer.hpp:374</div></div>
<div class="ttc" id="anamespaceasio_html_a95a21227870fa0ff7261f8c452dc83fd"><div class="ttname"><a href="#a95a21227870fa0ff7261f8c452dc83fd">asio::buffer_sequence_end</a></div><div class="ttdeci">const mutable_buffer * buffer_sequence_end(const MutableBuffer &amp;b, constraint_t&lt; is_convertible&lt; const MutableBuffer *, const mutable_buffer * &gt;::value &gt;=0) noexcept</div><div class="ttdoc">Get an iterator to one past the end element in a buffer sequence.</div><div class="ttdef"><b>Definition</b> buffer.hpp:425</div></div>
</div><!-- fragment --><p>The <code>BufferSequence</code> template parameter may meet either of the <code>ConstBufferSequence</code> or <code>MutableBufferSequence</code> type requirements. </p>

</div>
</div>
<a id="a42e267c80155b2747d041d2932357762" name="a42e267c80155b2747d041d2932357762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e267c80155b2747d041d2932357762">&#9670;&#160;</a></span>buffers_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt; asio::buffers_begin </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator representing the beginning of the buffers' data. </p>

</div>
</div>
<a id="a1c586f56452e13b3798ae1925bd35595" name="a1c586f56452e13b3798ae1925bd35595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c586f56452e13b3798ae1925bd35595">&#9670;&#160;</a></span>buffers_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt; asio::buffers_end </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator representing the end of the buffers' data. </p>

</div>
</div>
<a id="a4dd64d454a700ebaf2e3700e78f78bbc" name="a4dd64d454a700ebaf2e3700e78f78bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd64d454a700ebaf2e3700e78f78bbc">&#9670;&#160;</a></span>cancel_after() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename WaitTraits , typename Executor , typename Rep , typename Period , typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__after__timer.html">cancel_after_timer</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, chrono::steady_clock &gt; asio::cancel_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a></td>          <td class="paramname"><span class="paramname"><em>cancel_type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to cancel an operation if not complete before the specified relative timeout has elapsed. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_after, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="a3d74bcfbaf070baec84be8495c338808" name="a3d74bcfbaf070baec84be8495c338808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d74bcfbaf070baec84be8495c338808">&#9670;&#160;</a></span>cancel_after() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename WaitTraits , typename Executor , typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__cancel__after__timer.html">partial_cancel_after_timer</a>&lt; Clock, WaitTraits, Executor &gt; asio::cancel_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a></td>          <td class="paramname"><span class="paramname"><em>cancel_type</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a partial completion token adapter that cancels an operation if not complete before the specified relative timeout has elapsed. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_after, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="a712cef0b8cfcc8d2ddeeeb9caf450756" name="a712cef0b8cfcc8d2ddeeeb9caf450756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712cef0b8cfcc8d2ddeeeb9caf450756">&#9670;&#160;</a></span>cancel_after() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename WaitTraits , typename Executor , typename Rep , typename Period , typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__after__timer.html">cancel_after_timer</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock, WaitTraits, Executor &gt; asio::cancel_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to cancel an operation if not complete before the specified relative timeout has elapsed. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_after, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="a13770f033d42f095f9ea50974d8500ef" name="a13770f033d42f095f9ea50974d8500ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13770f033d42f095f9ea50974d8500ef">&#9670;&#160;</a></span>cancel_after() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__after__t.html">cancel_after_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, chrono::steady_clock &gt; asio::cancel_after </td>
          <td>(</td>
          <td class="paramtype">const chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a></td>          <td class="paramname"><span class="paramname"><em>cancel_type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to cancel an operation if not complete before the specified relative timeout has elapsed. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_after, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="a49286c4e58bf3276fb1b5520c324a989" name="a49286c4e58bf3276fb1b5520c324a989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49286c4e58bf3276fb1b5520c324a989">&#9670;&#160;</a></span>cancel_after() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__cancel__after.html">partial_cancel_after</a>&lt; chrono::steady_clock &gt; asio::cancel_after </td>
          <td>(</td>
          <td class="paramtype">const chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a></td>          <td class="paramname"><span class="paramname"><em>cancel_type</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a partial completion token adapter that cancels an operation if not complete before the specified relative timeout has elapsed. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_after, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="a4724d3f5c4f9b3fb6c1cc993340b8eb4" name="a4724d3f5c4f9b3fb6c1cc993340b8eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724d3f5c4f9b3fb6c1cc993340b8eb4">&#9670;&#160;</a></span>cancel_after() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__after__t.html">cancel_after_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, chrono::steady_clock &gt; asio::cancel_after </td>
          <td>(</td>
          <td class="paramtype">const chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to cancel an operation if not complete before the specified relative timeout has elapsed. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_after, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="adb7d481e9f19fb72ae68a0bf0f84ccc8" name="adb7d481e9f19fb72ae68a0bf0f84ccc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7d481e9f19fb72ae68a0bf0f84ccc8">&#9670;&#160;</a></span>cancel_at() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename Clock , typename WaitTraits , typename Executor , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__at__timer.html">cancel_at_timer</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock, WaitTraits, Executor &gt; asio::cancel_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const chrono::time_point&lt; Clock, Duration &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expiry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a></td>          <td class="paramname"><span class="paramname"><em>cancel_type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to cancel an operation if not complete by the specified absolute time. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_at, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="aaea0d0ae1b733917509414f752ba6529" name="aaea0d0ae1b733917509414f752ba6529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea0d0ae1b733917509414f752ba6529">&#9670;&#160;</a></span>cancel_at() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename WaitTraits , typename Executor , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__cancel__at__timer.html">partial_cancel_at_timer</a>&lt; Clock, WaitTraits, Executor &gt; asio::cancel_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const chrono::time_point&lt; Clock, Duration &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expiry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a></td>          <td class="paramname"><span class="paramname"><em>cancel_type</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a partial completion token adapter that cancels an operation if not complete by the specified absolute time. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_at, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="a74049aec78c3f878ae5d28ad3356ae0d" name="a74049aec78c3f878ae5d28ad3356ae0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74049aec78c3f878ae5d28ad3356ae0d">&#9670;&#160;</a></span>cancel_at() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename Clock , typename WaitTraits , typename Executor , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__at__timer.html">cancel_at_timer</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock, WaitTraits, Executor &gt; asio::cancel_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; Clock, WaitTraits, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const chrono::time_point&lt; Clock, Duration &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expiry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to cancel an operation if not complete by the specified absolute time. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_at, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="ae92e3624896711511ba6af632d30d4c8" name="ae92e3624896711511ba6af632d30d4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92e3624896711511ba6af632d30d4c8">&#9670;&#160;</a></span>cancel_at() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__at__t.html">cancel_at_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock &gt; asio::cancel_at </td>
          <td>(</td>
          <td class="paramtype">const chrono::time_point&lt; Clock, Duration &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expiry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a></td>          <td class="paramname"><span class="paramname"><em>cancel_type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to cancel an operation if not complete by the specified absolute time. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_at, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="aaeeeba97e9f7bc2a799b364155e91489" name="aaeeeba97e9f7bc2a799b364155e91489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeeeba97e9f7bc2a799b364155e91489">&#9670;&#160;</a></span>cancel_at() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__cancel__at.html">partial_cancel_at</a>&lt; Clock &gt; asio::cancel_at </td>
          <td>(</td>
          <td class="paramtype">const chrono::time_point&lt; Clock, Duration &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expiry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a></td>          <td class="paramname"><span class="paramname"><em>cancel_type</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a partial completion token adapter that cancels an operation if not complete by the specified absolute time. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_at, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="a44038279338e1f3adabe29a7e9ae278d" name="a44038279338e1f3adabe29a7e9ae278d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44038279338e1f3adabe29a7e9ae278d">&#9670;&#160;</a></span>cancel_at() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancel__at__t.html">cancel_at_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, Clock &gt; asio::cancel_at </td>
          <td>(</td>
          <td class="paramtype">const chrono::time_point&lt; Clock, Duration &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expiry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to cancel an operation if not complete by the specified absolute time. </p><dl class="section user"><dt>Thread Safety</dt><dd>When an asynchronous operation is used with cancel_at, a timer async_wait operation is performed in parallel to the main operation. If this parallel async_wait completes first, a cancellation request is emitted to cancel the main operation. Consequently, the application must ensure that the asynchronous operation is performed within an implicit or explicit strand. </dd></dl>

</div>
</div>
<a id="ac40ca2867bf91f9aa7a24230e422fc9b" name="ac40ca2867bf91f9aa7a24230e422fc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40ca2867bf91f9aa7a24230e422fc9b">&#9670;&#160;</a></span>composed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ASIO_COMPLETION_SIGNATURE... Signatures, typename Implementation , typename... IoObjectsOrExecutors&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::composed </td>
          <td>(</td>
          <td class="paramtype">Implementation &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>implementation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IoObjectsOrExecutors &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>io_objects_or_executors</em></span>&#160;) -&gt; decltype(
    <a class="el" href="namespaceasio_1_1detail.html#ac086ff2f548545f78952448a038abbc8">detail::make_initiate_composed</a>&lt;Signatures...&gt;(
      static_cast&lt;Implementation&amp;&amp;&gt;(implementation),
      <a class="el" href="namespaceasio_1_1detail.html#aebfd213c14f7d960fd686315d844b471">detail::make_composed_io_executors</a>(
        <a class="el" href="namespaceasio_1_1detail.html#a390920449946d0e5b743593f9fa8ac27">detail::get_composed_io_executor</a>(
          static_cast&lt;IoObjectsOrExecutors&amp;&amp;&gt;(
            io_objects_or_executors))...)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an initiation function object that may be used to launch an asynchronous operation with a stateful implementation. The <code>composed</code> function simplifies the implementation of composed asynchronous operations automatically by wrapping a stateful function object for use as an initiation function object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">implementation</td><td>A function object that contains the implementation of the composed asynchronous operation. The first argument to the function object is a non-const reference to the enclosing intermediate completion handler. The remaining arguments are any arguments that originate from the completion handlers of any asynchronous operations performed by the implementation.</td></tr>
    <tr><td class="paramname">io_objects_or_executors</td><td>Zero or more I/O objects or I/O executors for which outstanding work must be maintained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>By default, terminal per-operation cancellation is enabled for composed operations that are implemented using <code>composed</code>. To disable cancellation for the composed operation, or to alter its supported cancellation types, call the <code>self</code> object's <code>reset_cancellation_state</code> function.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">struct </span>async_echo_implementation</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; socket_;</div>
<div class="line">  <a class="code hl_class" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> buffer_;</div>
<div class="line">  <span class="keyword">enum</span> { starting, reading, writing } state_;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Self&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(Self&amp; self,</div>
<div class="line">      <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> error,</div>
<div class="line">      std::size_t n)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">switch</span> (state_)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> starting:</div>
<div class="line">      state_ = reading;</div>
<div class="line">      socket_.async_read_some(</div>
<div class="line">          buffer_, std::move(self));</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> reading:</div>
<div class="line">      <span class="keywordflow">if</span> (error)</div>
<div class="line">      {</div>
<div class="line">        self.complete(error, 0);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        state_ = writing;</div>
<div class="line">        <a class="code hl_function" href="#a533d82c389058d9f3c70e6ba04fa5e78">asio::async_write</a>(socket_, buffer_,</div>
<div class="line">            <a class="code hl_function" href="#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a>(n),</div>
<div class="line">            std::move(self));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> writing:</div>
<div class="line">      self.complete(error, n);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionToken&gt;</div>
<div class="line"><span class="keyword">auto</span> async_echo(tcp::socket&amp; socket,</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> buffer,</div>
<div class="line">    CompletionToken&amp;&amp; <a class="code hl_variable" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>)</div>
<div class="line">  -&gt; <span class="keyword">decltype</span>(</div>
<div class="line">    <a class="code hl_function" href="#ab2209de8d875481208ea96c76c1c49e4">asio::async_initiate</a>&lt;CompletionToken,</div>
<div class="line">      <a class="code hl_variable" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(</div>
<div class="line">        <a class="code hl_function" href="#ac40ca2867bf91f9aa7a24230e422fc9b">asio::composed</a>(</div>
<div class="line">          async_echo_implementation{<a class="code hl_function" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">buffer</a>,</div>
<div class="line">            async_echo_implementation::starting}, <a class="code hl_function" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>),</div>
<div class="line">        <a class="code hl_variable" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="#ab2209de8d875481208ea96c76c1c49e4">asio::async_initiate</a>&lt;CompletionToken,</div>
<div class="line">    <a class="code hl_variable" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(<a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(</div>
<div class="line">      <a class="code hl_function" href="#ac40ca2867bf91f9aa7a24230e422fc9b">asio::composed</a>(</div>
<div class="line">        async_echo_implementation{<a class="code hl_function" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">buffer</a>,</div>
<div class="line">          async_echo_implementation::starting}, <a class="code hl_function" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>),</div>
<div class="line">      <a class="code hl_variable" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>{}, 0);</div>
<div class="line">} </div>
<div class="ttc" id="anamespaceasio_html_ab2209de8d875481208ea96c76c1c49e4"><div class="ttname"><a href="#ab2209de8d875481208ea96c76c1c49e4">asio::async_initiate</a></div><div class="ttdeci">auto async_initiate(Initiation &amp;&amp;initiation, type_identity_t&lt; CompletionToken &gt; &amp;token, Args &amp;&amp;... args) -&gt; decltype(enable_if_t&lt; enable_if_t&lt; detail::are_completion_signatures&lt; Signatures... &gt;::value, detail::async_result_has_initiate_memfn&lt; CompletionToken, Signatures... &gt; &gt;::value, async_result&lt; decay_t&lt; CompletionToken &gt;, Signatures... &gt; &gt;::initiate(static_cast&lt; Initiation &amp;&amp; &gt;(initiation), static_cast&lt; CompletionToken &amp;&amp; &gt;(token), static_cast&lt; Args &amp;&amp; &gt;(args)...))</div><div class="ttdef"><b>Definition</b> async_result.hpp:616</div></div>
<div class="ttc" id="anamespaceasio_html_ac40ca2867bf91f9aa7a24230e422fc9b"><div class="ttname"><a href="#ac40ca2867bf91f9aa7a24230e422fc9b">asio::composed</a></div><div class="ttdeci">auto composed(Implementation &amp;&amp;implementation, IoObjectsOrExecutors &amp;&amp;... io_objects_or_executors) -&gt; decltype(detail::make_initiate_composed&lt; Signatures... &gt;(static_cast&lt; Implementation &amp;&amp; &gt;(implementation), detail::make_composed_io_executors(detail::get_composed_io_executor(static_cast&lt; IoObjectsOrExecutors &amp;&amp; &gt;(io_objects_or_executors))...)))</div><div class="ttdef"><b>Definition</b> composed.hpp:391</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5abd764e6b852835571e5cb4c930bd7e" name="a5abd764e6b852835571e5cb4c930bd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abd764e6b852835571e5cb4c930bd7e">&#9670;&#160;</a></span>connect() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line"><a class="code hl_function" href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, r.resolve(q), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">} </div>
<div class="ttc" id="anamespaceasio_html_ad9722498362a99a18c1daabb554ac3f7"><div class="ttname"><a href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a></div><div class="ttdeci">Protocol::endpoint connect(basic_socket&lt; Protocol, Executor &gt; &amp;s, const EndpointSequence &amp;endpoints, constraint_t&lt; is_endpoint_sequence&lt; EndpointSequence &gt;::value &gt;=0)</div><div class="ttdoc">Establishes a socket connection by trying each endpoint in a sequence.</div><div class="ttdef"><b>Definition</b> connect.hpp:78</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4646beddee1d8c46a01e9e9110ac51ce" name="a4646beddee1d8c46a01e9e9110ac51ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4646beddee1d8c46a01e9e9110ac51ce">&#9670;&#160;</a></span>connect() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">tcp::endpoint e = <a class="code hl_function" href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    r.resolve(q), my_connect_condition(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8432621bada84252d7ba046f7debb6bd" name="a8432621bada84252d7ba046f7debb6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8432621bada84252d7ba046f7debb6bd">&#9670;&#160;</a></span>connect() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, decltype(declval&lt; const EndpointSequence &amp; &gt;().begin())&gt;::value</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line">tcp::endpoint e = <a class="code hl_function" href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    r.resolve(q), my_connect_condition());</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl; </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad9722498362a99a18c1daabb554ac3f7" name="ad9722498362a99a18c1daabb554ac3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9722498362a99a18c1daabb554ac3f7">&#9670;&#160;</a></span>connect() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code hl_function" href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, r.resolve(q)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1a7e6e620a9da1d4d64236c162eed826" name="a1a7e6e620a9da1d4d64236c162eed826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7e6e620a9da1d4d64236c162eed826">&#9670;&#160;</a></span>connect() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="a6b137487ce51957fc4e8adf77238f439" name="a6b137487ce51957fc4e8adf77238f439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b137487ce51957fc4e8adf77238f439">&#9670;&#160;</a></span>connect() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="a327861511f29f5caf62d92b4bd62b42f" name="a327861511f29f5caf62d92b4bd62b42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327861511f29f5caf62d92b4bd62b42f">&#9670;&#160;</a></span>connect() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="a43a264859b2129ad503e72850c37ae31" name="a43a264859b2129ad503e72850c37ae31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a264859b2129ad503e72850c37ae31">&#9670;&#160;</a></span>connect() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="aa8c58255744686dfcd930523d98bc0c2" name="aa8c58255744686dfcd930523d98bc0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c58255744686dfcd930523d98bc0c2">&#9670;&#160;</a></span>connect() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code hl_function" href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, e.begin(), e.end()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5be799cfeb2dc75e371ffba20d2e62db" name="a5be799cfeb2dc75e371ffba20d2e62db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be799cfeb2dc75e371ffba20d2e62db">&#9670;&#160;</a></span>connect() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line"><a class="code hl_function" href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, e.begin(), e.end(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae30facd82bc6bcefe12df7e1fee4a9ac" name="ae30facd82bc6bcefe12df7e1fee4a9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30facd82bc6bcefe12df7e1fee4a9ac">&#9670;&#160;</a></span>connect() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">tcp::resolver::results_type::iterator i = <a class="code hl_function" href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(</div>
<div class="line">    <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, e.begin(), e.end(), my_connect_condition());</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl;</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2c1b8204e11c8f8470313127d6edf304" name="a2c1b8204e11c8f8470313127d6edf304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1b8204e11c8f8470313127d6edf304">&#9670;&#160;</a></span>connect() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__connect__condition.html">is_connect_condition</a>&lt; ConnectCondition, Iterator &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line">tcp::socket <a class="code hl_typedef" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line">tcp::resolver::results_type::iterator i = <a class="code hl_function" href="#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(</div>
<div class="line">    <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, e.begin(), e.end(), my_connect_condition());</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl; </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a05b89b67408806b08981fc972fd035d5" name="a05b89b67408806b08981fc972fd035d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b89b67408806b08981fc972fd035d5">&#9670;&#160;</a></span>consign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename... Values&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> constexpr <a class="el" href="classasio_1_1consign__t.html">consign_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Values &gt;... &gt; asio::consign </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completion token adapter used to specify that the completion handler should carry additional values along with it. This completion token adapter is typically used to keep at least one copy of an object, such as a smart pointer, alive until the completion handler is called. </p>

</div>
</div>
<a id="ab024cd3bf6ed204f3db126141ac1f5c0" name="ab024cd3bf6ed204f3db126141ac1f5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab024cd3bf6ed204f3db126141ac1f5c0">&#9670;&#160;</a></span>defer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto asio::defer </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__defer__with__executor.html">detail::initiate_defer_with_executor</a>&lt;Executor&gt;&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="#a22593523345cc52158f906f33a38cb15" title="Submits a completion token or function object for execution.">defer()</a></code>.</p>
<p>The use of <code><a class="el" href="#a22593523345cc52158f906f33a38cb15" title="Submits a completion token or function object for execution.">defer()</a></code>, rather than <a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b">post()</a>, indicates the caller's preference that the executor defer the queueing of the function object. This may allow the executor to optimise queueing for cases when the function object represents a continuation of the current call context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The target executor.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, void()&gt;(Init{ex}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>executor_type = Executor;</div>
<div class="line">  <span class="keyword">explicit</span> Init(<span class="keyword">const</span> Executor&amp; ex) : ex_(ex) {}</div>
<div class="line">  executor_type get_executor() const noexcept { <span class="keywordflow">return</span> ex_; }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Executor ex_; <span class="comment">// exposition only</span></div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> of type <code>Ex1</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> ex1 = <a class="code hl_function" href="#a3903c51139fd81095f65dde896a4342a">get_associated_executor</a>(handler, ex); </div>
<div class="ttc" id="anamespaceasio_html_a3903c51139fd81095f65dde896a4342a"><div class="ttname"><a href="#a3903c51139fd81095f65dde896a4342a">asio::get_associated_executor</a></div><div class="ttdeci">ASIO_NODISCARD associated_executor&lt; T &gt;::type get_associated_executor(const T &amp;t) noexcept</div><div class="ttdoc">Helper function to obtain an object's associated executor.</div><div class="ttdef"><b>Definition</b> associated_executor.hpp:143</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler); </div>
<div class="ttc" id="anamespaceasio_html_a811ede45b709fd7686e42bfee42c057d"><div class="ttname"><a href="#a811ede45b709fd7686e42bfee42c057d">asio::get_associated_allocator</a></div><div class="ttdeci">ASIO_NODISCARD associated_allocator&lt; T &gt;::type get_associated_allocator(const T &amp;t) noexcept</div><div class="ttdoc">Helper function to obtain an object's associated allocator.</div><div class="ttdef"><b>Definition</b> associated_allocator.hpp:140</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is true, constructs a function object <code>f</code> with a member <code>executor_</code> that is initialised with <code>prefer(ex1, execution::outstanding_work.tracked)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler_);</div>
<div class="line">prefer(executor_, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(<a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>)).execute(std::move(handler_));</div>
<div class="ttc" id="anamespaceasio_1_1execution_html_aa0f6bb39f9a4abd07fc08f856d3a9e8b"><div class="ttname"><a href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">asio::execution::allocator</a></div><div class="ttdeci">ASIO_INLINE_VARIABLE constexpr allocator_t&lt; void &gt; allocator</div><div class="ttdef"><b>Definition</b> allocator.hpp:228</div></div>
<div class="ttc" id="anamespaceasio_html_aa80c4033469ae5aaa092c0d49852403c"><div class="ttname"><a href="#aa80c4033469ae5aaa092c0d49852403c">asio::a</a></div><div class="ttdeci">awaitable&lt; T, AwaitableExecutor &gt; a</div><div class="ttdef"><b>Definition</b> co_spawn.hpp:359</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is false, constructs a function object <code>f</code> with a member <code>work_</code> that is initialised with <code>make_work_guard(ex1)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler_);</div>
<div class="line">work_.get_executor().dispatch(std::move(handler_), <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>);</div>
<div class="line">work_.reset(); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line">prefer(</div>
<div class="line">   require(ex, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aea1c66e343eac1d4e9f55c0567bc077c">execution::blocking</a>.never),</div>
<div class="line">   <a class="code hl_variable" href="namespaceasio_1_1execution.html#afa40430ba26bfa7bac718228ecad5ae0">execution::relationship</a>.continuation,</div>
<div class="line">   <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(alloc)</div>
<div class="line"> ).execute(std::move(<a class="code hl_variable" href="#ac172b717c13db01d7f99af7e42edcb68">f</a>)); </div>
<div class="ttc" id="anamespaceasio_1_1execution_html_aea1c66e343eac1d4e9f55c0567bc077c"><div class="ttname"><a href="namespaceasio_1_1execution.html#aea1c66e343eac1d4e9f55c0567bc077c">asio::execution::blocking</a></div><div class="ttdeci">ASIO_INLINE_VARIABLE constexpr blocking_t blocking</div><div class="ttdef"><b>Definition</b> blocking.hpp:895</div></div>
<div class="ttc" id="anamespaceasio_1_1execution_html_afa40430ba26bfa7bac718228ecad5ae0"><div class="ttname"><a href="namespaceasio_1_1execution.html#afa40430ba26bfa7bac718228ecad5ae0">asio::execution::relationship</a></div><div class="ttdeci">ASIO_INLINE_VARIABLE constexpr relationship_t relationship</div><div class="ttdef"><b>Definition</b> relationship.hpp:545</div></div>
<div class="ttc" id="anamespaceasio_html_ac172b717c13db01d7f99af7e42edcb68"><div class="ttname"><a href="#ac172b717c13db01d7f99af7e42edcb68">asio::f</a></div><div class="ttdeci">F &amp;&amp; f</div><div class="ttdef"><b>Definition</b> co_spawn.hpp:427</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.defer(std::move(<a class="code hl_variable" href="#ac172b717c13db01d7f99af7e42edcb68">f</a>), alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a710475c7cb3c1a1624cb78bf67c4997f" name="a710475c7cb3c1a1624cb78bf67c4997f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710475c7cb3c1a1624cb78bf67c4997f">&#9670;&#160;</a></span>defer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto asio::defer </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;typename&#160;ExecutionContext::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__defer__with__executor.html">detail::initiate_defer_with_executor</a>&lt;
        typename ExecutionContext::executor_type&gt;&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which the target executor is obtained.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>defer(ctx.get_executor(), forward&lt;NullaryToken&gt;(token))</code>.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a22593523345cc52158f906f33a38cb15" name="a22593523345cc52158f906f33a38cb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22593523345cc52158f906f33a38cb15">&#9670;&#160;</a></span>defer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto asio::defer </td>
          <td>(</td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td> -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__defer.html">detail::initiate_defer</a>&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="#a22593523345cc52158f906f33a38cb15" title="Submits a completion token or function object for execution.">defer()</a></code>.</p>
<p>The use of <code><a class="el" href="#a22593523345cc52158f906f33a38cb15" title="Submits a completion token or function object for execution.">defer()</a></code>, rather than <a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b">post()</a>, indicates the caller's preference that the executor defer the queueing of the function object. This may allow the executor to optimise queueing for cases when the function object represents a continuation of the current call context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, void()&gt;(Init{}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> of type <code>Ex</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> ex = <a class="code hl_function" href="#a3903c51139fd81095f65dde896a4342a">get_associated_executor</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line">prefer(</div>
<div class="line">   require(ex, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aea1c66e343eac1d4e9f55c0567bc077c">execution::blocking</a>.never),</div>
<div class="line">   <a class="code hl_variable" href="namespaceasio_1_1execution.html#afa40430ba26bfa7bac718228ecad5ae0">execution::relationship</a>.continuation,</div>
<div class="line">   <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(alloc)</div>
<div class="line"> ).execute(std::forward&lt;CompletionHandler&gt;(completion_handler)); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.defer(</div>
<div class="line">   std::forward&lt;CompletionHandler&gt;(completion_handler),</div>
<div class="line">   alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3b55c8f57836701c5d8cdb06cec3f30a" name="a3b55c8f57836701c5d8cdb06cec3f30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b55c8f57836701c5d8cdb06cec3f30a">&#9670;&#160;</a></span>dispatch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__dispatch__with__executor.html">detail::initiate_dispatch_with_executor</a>&lt;Executor&gt;&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object may be called from the current thread prior to returning from <code><a class="el" href="#a0b53f4ff238fefdfbaf52153b89e6abd" title="Submits a completion token or function object for execution.">dispatch()</a></code>. Otherwise, it is queued for execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The target executor.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, void()&gt;(Init{ex}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>executor_type = Executor;</div>
<div class="line">  <span class="keyword">explicit</span> Init(<span class="keyword">const</span> Executor&amp; ex) : ex_(ex) {}</div>
<div class="line">  executor_type get_executor() const noexcept { <span class="keywordflow">return</span> ex_; }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Executor ex_; <span class="comment">// exposition only</span></div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> of type <code>Ex1</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> ex1 = <a class="code hl_function" href="#a3903c51139fd81095f65dde896a4342a">get_associated_executor</a>(handler, ex); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is true, constructs a function object <code>f</code> with a member <code>executor_</code> that is initialised with <code>prefer(ex1, execution::outstanding_work.tracked)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler_);</div>
<div class="line">prefer(executor_, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(<a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>)).execute(std::move(handler_));</div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is false, constructs a function object <code>f</code> with a member <code>work_</code> that is initialised with <code>make_work_guard(ex1)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler_);</div>
<div class="line">work_.get_executor().dispatch(std::move(handler_), <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>);</div>
<div class="line">work_.reset(); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line">prefer(ex, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(alloc)).execute(std::move(<a class="code hl_variable" href="#ac172b717c13db01d7f99af7e42edcb68">f</a>)); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.dispatch(std::move(<a class="code hl_variable" href="#ac172b717c13db01d7f99af7e42edcb68">f</a>), alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a493afa7d5a111aea6b0bb9ddb2dca5ab" name="a493afa7d5a111aea6b0bb9ddb2dca5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493afa7d5a111aea6b0bb9ddb2dca5ab">&#9670;&#160;</a></span>dispatch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;ExecutionContext::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__dispatch__with__executor.html">detail::initiate_dispatch_with_executor</a>&lt;
        typename ExecutionContext::executor_type&gt;&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which the target executor is obtained.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dispatch(ctx.get_executor(), forward&lt;NullaryToken&gt;(token))</code>.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0b53f4ff238fefdfbaf52153b89e6abd" name="a0b53f4ff238fefdfbaf52153b89e6abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b53f4ff238fefdfbaf52153b89e6abd">&#9670;&#160;</a></span>dispatch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td> -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__dispatch.html">detail::initiate_dispatch</a>&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object may be called from the current thread prior to returning from <code><a class="el" href="#a0b53f4ff238fefdfbaf52153b89e6abd" title="Submits a completion token or function object for execution.">dispatch()</a></code>. Otherwise, it is queued for execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, void()&gt;(Init{}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> of type <code>Ex</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> ex = <a class="code hl_function" href="#a3903c51139fd81095f65dde896a4342a">get_associated_executor</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line">prefer(ex, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(alloc)).execute(</div>
<div class="line">   std::forward&lt;CompletionHandler&gt;(completion_handler)); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.dispatch(</div>
<div class="line">   std::forward&lt;CompletionHandler&gt;(completion_handler),</div>
<div class="line">   alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae8af2c940f947441ddf9aabdc3f330d2" name="ae8af2c940f947441ddf9aabdc3f330d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8af2c940f947441ddf9aabdc3f330d2">&#9670;&#160;</a></span>dynamic_buffer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><code>dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data)</code>. </dd></dl>

</div>
</div>
<a id="aa750035aeca47b2576366ce261172618" name="aa750035aeca47b2576366ce261172618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa750035aeca47b2576366ce261172618">&#9670;&#160;</a></span>dynamic_buffer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><code>dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data,
max_size)</code>. </dd></dl>

</div>
</div>
<a id="ac2215113263af583c61ce8c28bb3b15e" name="ac2215113263af583c61ce8c28bb3b15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2215113263af583c61ce8c28bb3b15e">&#9670;&#160;</a></span>dynamic_buffer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Elem, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given vector. </p>
<dl class="section return"><dt>Returns</dt><dd><code>dynamic_vector_buffer&lt;Elem, Allocator&gt;(data)</code>. </dd></dl>

</div>
</div>
<a id="a1701decd6c6a2c330d6e85c7ce98bcce" name="a1701decd6c6a2c330d6e85c7ce98bcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1701decd6c6a2c330d6e85c7ce98bcce">&#9670;&#160;</a></span>dynamic_buffer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Elem, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given vector. </p>
<dl class="section return"><dt>Returns</dt><dd><code>dynamic_vector_buffer&lt;Elem, Allocator&gt;(data, max_size)</code>. </dd></dl>

</div>
</div>
<a id="a811ede45b709fd7686e42bfee42c057d" name="a811ede45b709fd7686e42bfee42c057d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811ede45b709fd7686e42bfee42c057d">&#9670;&#160;</a></span>get_associated_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; T &gt;::type asio::get_associated_allocator </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_allocator&lt;T&gt;::get(t)</code> </dd></dl>

</div>
</div>
<a id="a82c18a9b1d0d55eb89746a4c0e679345" name="a82c18a9b1d0d55eb89746a4c0e679345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c18a9b1d0d55eb89746a4c0e679345">&#9670;&#160;</a></span>get_associated_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto asio::get_associated_allocator </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;) -&gt; decltype(<a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt;T, Allocator&gt;::get(t, <a class="el" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_allocator&lt;T, Allocator&gt;::get(t, a)</code> </dd></dl>

</div>
</div>
<a id="a877d182f3515b5768c7bc6b8560c3345" name="a877d182f3515b5768c7bc6b8560c3345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877d182f3515b5768c7bc6b8560c3345">&#9670;&#160;</a></span>get_associated_cancellation_slot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt; T &gt;::type asio::get_associated_cancellation_slot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_cancellation_slot&lt;T&gt;::get(t)</code> </dd></dl>

</div>
</div>
<a id="a69ba7c6fbf3206e8f4fbc64bc69c5644" name="a69ba7c6fbf3206e8f4fbc64bc69c5644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ba7c6fbf3206e8f4fbc64bc69c5644">&#9670;&#160;</a></span>get_associated_cancellation_slot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CancellationSlot &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto asio::get_associated_cancellation_slot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CancellationSlot &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>&#160;) -&gt; decltype(<a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt;T, CancellationSlot&gt;::get(t, st))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="structasio_1_1associated__cancellation__slot.html" title="Traits type used to obtain the cancellation_slot associated with an object.">associated_cancellation_slot</a>&lt;T, CancellationSlot&gt;::get(t, st)</code> </dd></dl>

</div>
</div>
<a id="a3903c51139fd81095f65dde896a4342a" name="a3903c51139fd81095f65dde896a4342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3903c51139fd81095f65dde896a4342a">&#9670;&#160;</a></span>get_associated_executor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T &gt;::type asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_executor&lt;T&gt;::get(t)</code> </dd></dl>

</div>
</div>
<a id="ad0f3ac3ddba1f3274b26dcb8f4b8c6f6" name="ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f3ac3ddba1f3274b26dcb8f4b8c6f6">&#9670;&#160;</a></span>get_associated_executor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(<a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, Executor&gt;::get(t, ex))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_executor&lt;T, Executor&gt;::get(t, ex)</code> </dd></dl>

</div>
</div>
<a id="af69838843d4aeddd379614f0e6eb2c67" name="af69838843d4aeddd379614f0e6eb2c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69838843d4aeddd379614f0e6eb2c67">&#9670;&#160;</a></span>get_associated_executor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, typenameExecutionContext::executor_type &gt;::type asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="structasio_1_1associated__executor.html" title="Traits type used to obtain the executor associated with an object.">associated_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::get(t, ctx.get_executor())</code> </dd></dl>

</div>
</div>
<a id="a754bcbf3e3c8b84637a949642a35e03b" name="a754bcbf3e3c8b84637a949642a35e03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754bcbf3e3c8b84637a949642a35e03b">&#9670;&#160;</a></span>get_associated_immediate_executor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto asio::get_associated_immediate_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(<a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt;T, Executor&gt;::get(t, ex))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_immediate_executor&lt;T, Executor&gt;::get(t, ex)</code> </dd></dl>

</div>
</div>
<a id="adc6affbf42afc0af12992946d9d5d4a6" name="adc6affbf42afc0af12992946d9d5d4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6affbf42afc0af12992946d9d5d4a6">&#9670;&#160;</a></span>get_associated_immediate_executor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt; T, typenameExecutionContext::executor_type &gt;::type asio::get_associated_immediate_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="structasio_1_1associated__immediate__executor.html" title="Traits type used to obtain the immediate executor associated with an object.">associated_immediate_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::get(t, ctx.get_executor())</code> </dd></dl>

</div>
</div>
<a id="a2e34e09c0ef0fc9a740fc96a62c4d2d5" name="a2e34e09c0ef0fc9a740fc96a62c4d2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e34e09c0ef0fc9a740fc96a62c4d2d5">&#9670;&#160;</a></span>has_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::has_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to determine whether the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> contains a service object corresponding to the given service type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> contains the service. </dd></dl>

</div>
</div>
<a id="ab15a1fc7487a02a33c700f0a42e55774" name="ab15a1fc7487a02a33c700f0a42e55774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15a1fc7487a02a33c700f0a42e55774">&#9670;&#160;</a></span>make_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::make_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to add a service to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
    <tr><td class="paramname">args</td><td>Zero or more arguments to be passed to the service constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1service__already__exists.html">asio::service_already_exists</a></td><td>Thrown if a service of the given type is already present in the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca177b6e4828630b6433a536de7c5c26" name="aca177b6e4828630b6433a536de7c5c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca177b6e4828630b6433a536de7c5c26">&#9670;&#160;</a></span>make_strand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; Executor &gt; asio::make_strand </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>An executor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A strand constructed with the specified executor. </dd></dl>

</div>
</div>
<a id="a7096c735b433a3ac870f0e9ace0e0b1a" name="a7096c735b433a3ac870f0e9ace0e0b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7096c735b433a3ac870f0e9ace0e0b1a">&#9670;&#160;</a></span>make_strand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; typename ExecutionContext::executor_type &gt; asio::make_strand </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an execution context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which an executor will be obtained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A strand constructed with the execution context's executor, obtained by performing <code>ctx.get_executor()</code>. </dd></dl>

</div>
</div>
<a id="a5433b8ec69df1bcf0d8cd5e1c46f67c3" name="a5433b8ec69df1bcf0d8cd5e1c46f67c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5433b8ec69df1bcf0d8cd5e1c46f67c3">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; Executor &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>An executor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A work guard constructed with the specified executor. </dd></dl>

</div>
</div>
<a id="ab4f613167bcdab70b6f15e066895852c" name="ab4f613167bcdab70b6f15e066895852c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f613167bcdab70b6f15e066895852c">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; T &gt;::value &amp;&amp;!is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value, <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T &gt; &gt;::type &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An arbitrary object, such as a completion handler, for which the associated executor will be obtained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A work guard constructed with the associated executor of the object <code>t</code>, which is obtained as if by calling <code>get_associated_executor(t)</code>. </dd></dl>

</div>
</div>
<a id="ad22761a1a102b7be5645be991f2c2194" name="ad22761a1a102b7be5645be991f2c2194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22761a1a102b7be5645be991f2c2194">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; <a class="el" href="#a0c819bb7b358898e38408c978e6c93f2">associated_executor_t</a>&lt; T, Executor &gt; &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An arbitrary object, such as a completion handler, for which the associated executor will be obtained.</td></tr>
    <tr><td class="paramname">ex</td><td>An executor to be used as the candidate object when determining the associated executor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A work guard constructed with the associated executor of the object <code>t</code>, which is obtained as if by calling <code>get_associated_executor(t,
ex)</code>. </dd></dl>

</div>
</div>
<a id="ad852081c67675531caa1024485970f63" name="ad852081c67675531caa1024485970f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad852081c67675531caa1024485970f63">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; <a class="el" href="#a0c819bb7b358898e38408c978e6c93f2">associated_executor_t</a>&lt; T, typename ExecutionContext::executor_type &gt; &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; T &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An arbitrary object, such as a completion handler, for which the associated executor will be obtained.</td></tr>
    <tr><td class="paramname">ctx</td><td>An execution context, from which an executor is obtained to use as the candidate object for determining the associated executor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A work guard constructed with the associated executor of the object <code>t</code>, which is obtained as if by calling <code>get_associated_executor(t, ctx.get_executor())</code>. </dd></dl>

</div>
</div>
<a id="ac99d916ce3bce6e49e0f941c63732645" name="ac99d916ce3bce6e49e0f941c63732645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99d916ce3bce6e49e0f941c63732645">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename ExecutionContext::executor_type &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which an executor will be obtained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A work guard constructed with the execution context's executor, obtained by performing <code>ctx.get_executor()</code>. </dd></dl>

</div>
</div>
<a id="acb1502dd4243e9745eaad2753e5ee24c" name="acb1502dd4243e9745eaad2753e5ee24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1502dd4243e9745eaad2753e5ee24c">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Head , typename Tail &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::operator| </td>
          <td>(</td>
          <td class="paramtype">Head</td>          <td class="paramname"><span class="paramname"><em>head</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tail &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>tail</em></span>&#160;) -&gt; <a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt;
      <a class="el" href="structasio_1_1is__deferred.html">is_deferred</a>&lt;Head&gt;::value,
      decltype(static_cast&lt;Head&amp;&amp;&gt;(head)(static_cast&lt;Tail&amp;&amp;&gt;(tail)))
    &gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipe operator used to chain deferred operations. </p>

</div>
</div>
<a id="a5da1abe028648eee310abc4e6954afbe" name="a5da1abe028648eee310abc4e6954afbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da1abe028648eee310abc4e6954afbe">&#9670;&#160;</a></span>post() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::post </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;Executor&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__post__with__executor.html">detail::initiate_post_with_executor</a>&lt;Executor&gt;&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">post()</a></code>.</p>
<p>The use of <code><a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">post()</a></code>, rather than <a class="el" href="#a22593523345cc52158f906f33a38cb15">defer()</a>, indicates the caller's preference that the function object be eagerly queued for execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The target executor.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, void()&gt;(Init{ex}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>executor_type = Executor;</div>
<div class="line">  <span class="keyword">explicit</span> Init(<span class="keyword">const</span> Executor&amp; ex) : ex_(ex) {}</div>
<div class="line">  executor_type get_executor() const noexcept { <span class="keywordflow">return</span> ex_; }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Executor ex_; <span class="comment">// exposition only</span></div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> of type <code>Ex1</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> ex1 = <a class="code hl_function" href="#a3903c51139fd81095f65dde896a4342a">get_associated_executor</a>(handler, ex); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is true, constructs a function object <code>f</code> with a member <code>executor_</code> that is initialised with <code>prefer(ex1, execution::outstanding_work.tracked)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler_);</div>
<div class="line">prefer(executor_, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(<a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>)).execute(std::move(handler_));</div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is false, constructs a function object <code>f</code> with a member <code>work_</code> that is initialised with <code>make_work_guard(ex1)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler_);</div>
<div class="line">work_.get_executor().dispatch(std::move(handler_), <a class="code hl_variable" href="#aa80c4033469ae5aaa092c0d49852403c">a</a>);</div>
<div class="line">work_.reset(); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line">prefer(</div>
<div class="line">   require(ex, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aea1c66e343eac1d4e9f55c0567bc077c">execution::blocking</a>.never),</div>
<div class="line">   <a class="code hl_variable" href="namespaceasio_1_1execution.html#afa40430ba26bfa7bac718228ecad5ae0">execution::relationship</a>.<a class="code hl_define" href="yield_8hpp.html#ab2e49d0b8dbb3181c7d1f622fd5ea1b4">fork</a>,</div>
<div class="line">   <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(alloc)</div>
<div class="line"> ).execute(std::move(<a class="code hl_variable" href="#ac172b717c13db01d7f99af7e42edcb68">f</a>)); </div>
<div class="ttc" id="ayield_8hpp_html_ab2e49d0b8dbb3181c7d1f622fd5ea1b4"><div class="ttname"><a href="yield_8hpp.html#ab2e49d0b8dbb3181c7d1f622fd5ea1b4">fork</a></div><div class="ttdeci">#define fork</div><div class="ttdef"><b>Definition</b> yield.hpp:22</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.post(std::move(<a class="code hl_variable" href="#ac172b717c13db01d7f99af7e42edcb68">f</a>), alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9bd1c5c73685cdaf49fc3f2cb770a5c8" name="a9bd1c5c73685cdaf49fc3f2cb770a5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd1c5c73685cdaf49fc3f2cb770a5c8">&#9670;&#160;</a></span>post() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::post </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;ExecutionContext::executor_type&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__post__with__executor.html">detail::initiate_post_with_executor</a>&lt;
        typename ExecutionContext::executor_type&gt;&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which the target executor is obtained.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>post(ctx.get_executor(), forward&lt;NullaryToken&gt;(token))</code>.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab96ddebcabf9c7f1524f803bc063a62b" name="ab96ddebcabf9c7f1524f803bc063a62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96ddebcabf9c7f1524f803bc063a62b">&#9670;&#160;</a></span>post() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(void()) NullaryToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::post </td>
          <td>(</td>
          <td class="paramtype">NullaryToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td> -&gt; decltype(
    <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt;NullaryToken, void()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__post.html">detail::initiate_post</a>&gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">post()</a></code>.</p>
<p>The use of <code><a class="el" href="#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">post()</a></code>, rather than <a class="el" href="#a22593523345cc52158f906f33a38cb15">defer()</a>, indicates the caller's preference that the function object be eagerly queued for execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, void()&gt;(Init{}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> of type <code>Ex</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> ex = <a class="code hl_function" href="#a3903c51139fd81095f65dde896a4342a">get_associated_executor</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code hl_function" href="#a811ede45b709fd7686e42bfee42c057d">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line">prefer(</div>
<div class="line">   require(ex, <a class="code hl_variable" href="namespaceasio_1_1execution.html#aea1c66e343eac1d4e9f55c0567bc077c">execution::blocking</a>.never),</div>
<div class="line">   <a class="code hl_variable" href="namespaceasio_1_1execution.html#afa40430ba26bfa7bac718228ecad5ae0">execution::relationship</a>.<a class="code hl_define" href="yield_8hpp.html#ab2e49d0b8dbb3181c7d1f622fd5ea1b4">fork</a>,</div>
<div class="line">   <a class="code hl_variable" href="namespaceasio_1_1execution.html#aa0f6bb39f9a4abd07fc08f856d3a9e8b">execution::allocator</a>(alloc)</div>
<div class="line"> ).execute(std::forward&lt;CompletionHandler&gt;(completion_handler)); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.post(</div>
<div class="line">   std::forward&lt;CompletionHandler&gt;(completion_handler),</div>
<div class="line">   alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a69ef4e735fba9b7b6f18061d85135718" name="a69ef4e735fba9b7b6f18061d85135718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ef4e735fba9b7b6f18061d85135718">&#9670;&#160;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename... Values&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> constexpr <a class="el" href="classasio_1_1prepend__t.html">prepend_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; Values &gt;... &gt; asio::prepend </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completion token type used to specify that the completion handler arguments should be passed additional values before the results of the operation. </p>

</div>
</div>
<a id="aaeda9d140628ff399cbe4a076cb15cee" name="aaeda9d140628ff399cbe4a076cb15cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeda9d140628ff399cbe4a076cb15cee">&#9670;&#160;</a></span>read() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a6b4be0038c7c334d9f3a52d3b569275c"><div class="ttname"><a href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a></div><div class="ttdeci">std::size_t read(SyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec, constraint_t&lt; is_mutable_buffer_sequence&lt; MutableBufferSequence &gt;::value &gt;, constraint_t&lt; is_completion_condition&lt; CompletionCondition &gt;::value &gt;)</div><div class="ttdoc">Attempt to read a certain amount of data from a stream before returning.</div><div class="ttdef"><b>Definition</b> read.hpp:63</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abc0bc3183df1291c7b2a35ec30d5428c" name="abc0bc3183df1291c7b2a35ec30d5428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0bc3183df1291c7b2a35ec30d5428c">&#9670;&#160;</a></span>read() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ace05ca9407b860d216912f3d1b523740" name="ace05ca9407b860d216912f3d1b523740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace05ca9407b860d216912f3d1b523740">&#9670;&#160;</a></span>read() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a74efe4ab9a1e1ab911451678a99e9416" name="a74efe4ab9a1e1ab911451678a99e9416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74efe4ab9a1e1ab911451678a99e9416">&#9670;&#160;</a></span>read() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32d5cec2634f5f444db542d796627711" name="a32d5cec2634f5f444db542d796627711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d5cec2634f5f444db542d796627711">&#9670;&#160;</a></span>read() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6b4be0038c7c334d9f3a52d3b569275c" name="a6b4be0038c7c334d9f3a52d3b569275c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4be0038c7c334d9f3a52d3b569275c">&#9670;&#160;</a></span>read() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a610eadff7bf636a2b3b1d46ef93afeed" name="a610eadff7bf636a2b3b1d46ef93afeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610eadff7bf636a2b3b1d46ef93afeed">&#9670;&#160;</a></span>read() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a5a1b66b2a02d69ef013a6c4624ac1b33" name="a5a1b66b2a02d69ef013a6c4624ac1b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1b66b2a02d69ef013a6c4624ac1b33">&#9670;&#160;</a></span>read() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5e5c5badc73ea0bd9cd960bf9149d0ea" name="a5e5c5badc73ea0bd9cd960bf9149d0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5c5badc73ea0bd9cd960bf9149d0ea">&#9670;&#160;</a></span>read() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a173b6d6f8e45f47505abf845bd090604" name="a173b6d6f8e45f47505abf845bd090604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173b6d6f8e45f47505abf845bd090604">&#9670;&#160;</a></span>read() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a1adc8b332a4551e12a9c62e3824af22d" name="a1adc8b332a4551e12a9c62e3824af22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adc8b332a4551e12a9c62e3824af22d">&#9670;&#160;</a></span>read() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63cdc4a188b5ee7270c030ab39182d5" name="ae63cdc4a188b5ee7270c030ab39182d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63cdc4a188b5ee7270c030ab39182d5">&#9670;&#160;</a></span>read() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6cc36adb5f0d169ee071a8b975f31a91" name="a6cc36adb5f0d169ee071a8b975f31a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc36adb5f0d169ee071a8b975f31a91">&#9670;&#160;</a></span>read() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab2f3630d17b3fa0cc9386a35314770be" name="ab2f3630d17b3fa0cc9386a35314770be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f3630d17b3fa0cc9386a35314770be">&#9670;&#160;</a></span>read() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="aa72519ed41d6309161d04e5612f9cce4" name="aa72519ed41d6309161d04e5612f9cce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72519ed41d6309161d04e5612f9cce4">&#9670;&#160;</a></span>read() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae71e9ea0f6b103926654caf7acf87578" name="ae71e9ea0f6b103926654caf7acf87578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71e9ea0f6b103926654caf7acf87578">&#9670;&#160;</a></span>read() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a301406c670bc22190df6e8628cbf0037" name="a301406c670bc22190df6e8628cbf0037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301406c670bc22190df6e8628cbf0037">&#9670;&#160;</a></span>read_at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a4eb46469ca33aac1a846c0ee80fb37a1">asio::read_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a4eb46469ca33aac1a846c0ee80fb37a1"><div class="ttname"><a href="#a4eb46469ca33aac1a846c0ee80fb37a1">asio::read_at</a></div><div class="ttdeci">std::size_t read_at(SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec, constraint_t&lt; is_completion_condition&lt; CompletionCondition &gt;::value &gt;)</div><div class="ttdef"><b>Definition</b> read_at.hpp:67</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4511bad893697fc58d379d6e00aa84ff" name="a4511bad893697fc58d379d6e00aa84ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4511bad893697fc58d379d6e00aa84ff">&#9670;&#160;</a></span>read_at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a4eb46469ca33aac1a846c0ee80fb37a1">asio::read_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6714ec6c4c8411e0337a5020f34788a2" name="a6714ec6c4c8411e0337a5020f34788a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6714ec6c4c8411e0337a5020f34788a2">&#9670;&#160;</a></span>read_at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a13cb906daf2dc90517c0ae95cbe71507" name="a13cb906daf2dc90517c0ae95cbe71507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cb906daf2dc90517c0ae95cbe71507">&#9670;&#160;</a></span>read_at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ef7a26ff401494d673ad462a3f3f5c0" name="a4ef7a26ff401494d673ad462a3f3f5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef7a26ff401494d673ad462a3f3f5c0">&#9670;&#160;</a></span>read_at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a4eb46469ca33aac1a846c0ee80fb37a1">asio::read_at</a>(d, 42, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a4eb46469ca33aac1a846c0ee80fb37a1">asio::read_at</a>(</div>
<div class="line">   d, 42, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6587e766e26325457154a5dac2a0b785" name="a6587e766e26325457154a5dac2a0b785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6587e766e26325457154a5dac2a0b785">&#9670;&#160;</a></span>read_at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a4eb46469ca33aac1a846c0ee80fb37a1">asio::read_at</a>(d, 42,</div>
<div class="line">   <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a4eb46469ca33aac1a846c0ee80fb37a1">asio::read_at</a>(</div>
<div class="line">   d, 42, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4eb46469ca33aac1a846c0ee80fb37a1" name="a4eb46469ca33aac1a846c0ee80fb37a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb46469ca33aac1a846c0ee80fb37a1">&#9670;&#160;</a></span>read_at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a768142a9f1b61d423db9c9e7796edced" name="a768142a9f1b61d423db9c9e7796edced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768142a9f1b61d423db9c9e7796edced">&#9670;&#160;</a></span>read_at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a4eb46469ca33aac1a846c0ee80fb37a1">asio::read_at</a>(d, 42, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a03a433d903eae4dd097bc2c55efbf1ee" name="a03a433d903eae4dd097bc2c55efbf1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a433d903eae4dd097bc2c55efbf1ee">&#9670;&#160;</a></span>read_until() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code hl_class" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div>
<div class="line"><a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::istream is(&amp;b);</div>
<div class="line">std::string line;</div>
<div class="line">std::getline(is, line); </div>
<div class="ttc" id="anamespaceasio_html_a2b92bb6fafc1878dfaad835ed99bdf87"><div class="ttname"><a href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a></div><div class="ttdeci">std::size_t read_until(SyncReadStream &amp;s, DynamicBuffer_v1 &amp;&amp;buffers, char delim, constraint_t&lt; is_dynamic_buffer_v1&lt; decay_t&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;, constraint_t&lt; !is_dynamic_buffer_v2&lt; decay_t&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;)</div><div class="ttdef"><b>Definition</b> read_until.hpp:89</div></div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a78faf8cf08d47515162de95b18b0a860" name="a78faf8cf08d47515162de95b18b0a860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78faf8cf08d47515162de95b18b0a860">&#9670;&#160;</a></span>read_until() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="a1aae2baa82596a6a9ad320e80b016006" name="a1aae2baa82596a6a9ad320e80b016006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aae2baa82596a6a9ad320e80b016006">&#9670;&#160;</a></span>read_until() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code hl_class" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div>
<div class="line"><a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::istream is(&amp;b);</div>
<div class="line">std::string line;</div>
<div class="line">std::getline(is, line); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ab9d265cc5b757caf9c9a602da2d6a3e5" name="ab9d265cc5b757caf9c9a602da2d6a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d265cc5b757caf9c9a602da2d6a3e5">&#9670;&#160;</a></span>read_until() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ab02f689946ae31e0c60cdaa926419f43" name="ab02f689946ae31e0c60cdaa926419f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02f689946ae31e0c60cdaa926419f43">&#9670;&#160;</a></span>read_until() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type</a>&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="a8372fc4edf57763c49ed1f8cf42e6a4f" name="a8372fc4edf57763c49ed1f8cf42e6a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8372fc4edf57763c49ed1f8cf42e6a4f">&#9670;&#160;</a></span>read_until() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type</a>&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::streambuf::const_buffers_type</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::streambuf b;</div>
<div class="line"><a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code hl_class" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> c) : c_(c) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code hl_class" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">asio::streambuf b;</div>
<div class="line"><a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab5ac3f1bd64b19dbb8abce621fd4d787" name="ab5ac3f1bd64b19dbb8abce621fd4d787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ac3f1bd64b19dbb8abce621fd4d787">&#9670;&#160;</a></span>read_until() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ab9d6987da09298caf984161767c717b0" name="ab9d6987da09298caf984161767c717b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d6987da09298caf984161767c717b0">&#9670;&#160;</a></span>read_until() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    <a class="code hl_function" href="#ae8af2c940f947441ddf9aabdc3f330d2">asio::dynamic_buffer</a>(data), <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::string line = data.substr(0, n);</div>
<div class="line">data.erase(0, n); </div>
<div class="ttc" id="anamespaceasio_html_ae8af2c940f947441ddf9aabdc3f330d2"><div class="ttname"><a href="#ae8af2c940f947441ddf9aabdc3f330d2">asio::dynamic_buffer</a></div><div class="ttdeci">ASIO_NODISCARD dynamic_string_buffer&lt; Elem, Traits, Allocator &gt; dynamic_buffer(std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</div><div class="ttdoc">Create a new dynamic buffer that represents the given string.</div><div class="ttdef"><b>Definition</b> buffer.hpp:2194</div></div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ab5efc2077fba4bcbd64343b35235e822" name="ab5efc2077fba4bcbd64343b35235e822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5efc2077fba4bcbd64343b35235e822">&#9670;&#160;</a></span>read_until() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="a2b92bb6fafc1878dfaad835ed99bdf87" name="a2b92bb6fafc1878dfaad835ed99bdf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b92bb6fafc1878dfaad835ed99bdf87">&#9670;&#160;</a></span>read_until() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    <a class="code hl_function" href="#ae8af2c940f947441ddf9aabdc3f330d2">asio::dynamic_buffer</a>(data), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::string line = data.substr(0, n);</div>
<div class="line">data.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ac64f933f108873c05208b585d4030dda" name="ac64f933f108873c05208b585d4030dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64f933f108873c05208b585d4030dda">&#9670;&#160;</a></span>read_until() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;DynamicBuffer_v1::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="a0721392f813226742ab9d5f61ab50222" name="a0721392f813226742ab9d5f61ab50222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0721392f813226742ab9d5f61ab50222">&#9670;&#160;</a></span>read_until() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;typename DynamicBuffer_v1::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic_buffer's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a dynamic buffer sequence until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code hl_class" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> c) : c_(c) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code hl_class" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9d7a79fc07a0a5dcbb8ac5c4e9658466" name="a9d7a79fc07a0a5dcbb8ac5c4e9658466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7a79fc07a0a5dcbb8ac5c4e9658466">&#9670;&#160;</a></span>read_until() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="a0bc4d5ec4ec23d9aec3cdf8ae4e76872" name="a0bc4d5ec4ec23d9aec3cdf8ae4e76872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc4d5ec4ec23d9aec3cdf8ae4e76872">&#9670;&#160;</a></span>read_until() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    <a class="code hl_function" href="#ae8af2c940f947441ddf9aabdc3f330d2">asio::dynamic_buffer</a>(data), <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::string line = data.substr(0, n);</div>
<div class="line">data.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ae9cb7c507ff2509dc675e040ebce3338" name="ae9cb7c507ff2509dc675e040ebce3338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cb7c507ff2509dc675e040ebce3338">&#9670;&#160;</a></span>read_until() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ab935fe986ec9477db62af1e7d514e6ed" name="ab935fe986ec9477db62af1e7d514e6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab935fe986ec9477db62af1e7d514e6ed">&#9670;&#160;</a></span>read_until() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    <a class="code hl_function" href="#ae8af2c940f947441ddf9aabdc3f330d2">asio::dynamic_buffer</a>(data), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::string line = data.substr(0, n);</div>
<div class="line">data.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a57d2663e7af5457346f4463d16e4237a" name="a57d2663e7af5457346f4463d16e4237a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d2663e7af5457346f4463d16e4237a">&#9670;&#160;</a></span>read_until() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;DynamicBuffer_v2::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="a8c499c6a5bf36dfe4eae35c9afdb76a2" name="a8c499c6a5bf36dfe4eae35c9afdb76a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c499c6a5bf36dfe4eae35c9afdb76a2">&#9670;&#160;</a></span>read_until() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;typename DynamicBuffer_v2::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic_buffer's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a dynamic buffer sequence until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code hl_class" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> c) : c_(c) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code hl_class" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code hl_function" href="#a2b92bb6fafc1878dfaad835ed99bdf87">asio::read_until</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <a class="code hl_class" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a589081fc458bda3b74d839c1f48124cd" name="a589081fc458bda3b74d839c1f48124cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589081fc458bda3b74d839c1f48124cd">&#9670;&#160;</a></span>redirect_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1partial__redirect__error.html">partial_redirect_error</a> asio::redirect_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a partial completion token adapter that captures error_code values to a variable. </p>

</div>
</div>
<a id="a057ab21c3bde13bdeb5e6769c69e3e09" name="a057ab21c3bde13bdeb5e6769c69e3e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057ab21c3bde13bdeb5e6769c69e3e09">&#9670;&#160;</a></span>redirect_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; CompletionToken &gt; &gt; asio::redirect_error </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>completion_token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapt a completion_token to capture error_code values to a variable. </p>

</div>
</div>
<a id="aab2fee74d508667d6f19d7cb7ea7b8ab" name="aab2fee74d508667d6f19d7cb7ea7b8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2fee74d508667d6f19d7cb7ea7b8ab">&#9670;&#160;</a></span>register_buffers() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename MutableBufferSequence , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence, Allocator &gt; asio::register_buffers </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer_sequence</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register buffers with an execution context. </p>

</div>
</div>
<a id="a9c7c33f5b8301df64b83beeff3313d0f" name="a9c7c33f5b8301df64b83beeff3313d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7c33f5b8301df64b83beeff3313d0f">&#9670;&#160;</a></span>register_buffers() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence &gt; asio::register_buffers </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer_sequence</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register buffers with an execution context. </p>

</div>
</div>
<a id="a9e2e57093cdd5fcf9aa90c234580b023" name="a9e2e57093cdd5fcf9aa90c234580b023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2e57093cdd5fcf9aa90c234580b023">&#9670;&#160;</a></span>register_buffers() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename MutableBufferSequence , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence, Allocator &gt; asio::register_buffers </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer_sequence</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register buffers with an execution context. </p>

</div>
</div>
<a id="a1eefb1ef980d2fd4ff57988ef1a20ac2" name="a1eefb1ef980d2fd4ff57988ef1a20ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eefb1ef980d2fd4ff57988ef1a20ac2">&#9670;&#160;</a></span>register_buffers() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence &gt; asio::register_buffers </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer_sequence</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register buffers with an execution context. </p>

</div>
</div>
<a id="a04d7d7c26ad60f669c579ab03c129e02" name="a04d7d7c26ad60f669c579ab03c129e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d7d7c26ad60f669c579ab03c129e02">&#9670;&#160;</a></span>spawn() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename F , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt; &gt;::type) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::spawn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;Executor&#160;&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt;  decltype( <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt; &gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine, inheriting the executor of another. </p>
<p>This function is used to launch a new stackful coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Identifies the current coroutine as a parent of the new coroutine. This specifies that the new coroutine should inherit the executor of the parent. For example, if the parent coroutine is executing in a particular strand, then the new coroutine will execute in the same strand.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must be callable the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_class" href="classasio_1_1basic__yield__context.html">basic_yield_context&lt;Executor&gt;</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
<div class="ttc" id="aclassasio_1_1basic__yield__context_html"><div class="ttname"><a href="classasio_1_1basic__yield__context.html">asio::basic_yield_context</a></div><div class="ttdoc">A completion_token that represents the currently executing coroutine.</div><div class="ttdef"><b>Definition</b> spawn.hpp:186</div></div>
<div class="ttc" id="ayield_8hpp_html_abaa9287233697b1cd0175180304c7e1d"><div class="ttname"><a href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a></div><div class="ttdeci">#define yield</div><div class="ttdef"><b>Definition</b> yield.hpp:18</div></div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will handle the notification that the coroutine has completed. If the return type <code>R</code> of <code>function</code> is <code>void</code>, the function signature of the completion handler must be:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr); </div>
</div><!-- fragment --><p> Otherwise, the function signature of the completion handler must be: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr, R); </div>
</div><!-- fragment --><dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(std::exception_ptr, R) </div>
</div><!-- fragment --> where <code>R</code> is the return type of the function object.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>The new thread of execution is created with a cancellation state that supports <code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> values only. To change the cancellation state, call the <a class="el" href="classasio_1_1basic__yield__context.html" title="A completion_token that represents the currently executing coroutine.">basic_yield_context</a> member function <code>reset_cancellation_state</code>. </dd></dl>

</div>
</div>
<a id="a546edfac9aee7ffe3500b6e4fbe020fa" name="a546edfac9aee7ffe3500b6e4fbe020fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546edfac9aee7ffe3500b6e4fbe020fa">&#9670;&#160;</a></span>spawn() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename F , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt; &gt;::type) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::spawn </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;Executor&#160;&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt;  decltype( <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt; &gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; Executor &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine that executes on a given executor. </p>
<p>This function is used to launch a new stackful coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>Identifies the executor that will run the stackful coroutine.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must be callable the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_class" href="classasio_1_1basic__yield__context.html">basic_yield_context&lt;Executor&gt;</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will handle the notification that the coroutine has completed. If the return type <code>R</code> of <code>function</code> is <code>void</code>, the function signature of the completion handler must be:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr); </div>
</div><!-- fragment --><p> Otherwise, the function signature of the completion handler must be: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr, R); </div>
</div><!-- fragment --><dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(std::exception_ptr, R) </div>
</div><!-- fragment --> where <code>R</code> is the return type of the function object.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>The new thread of execution is created with a cancellation state that supports <code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> values only. To change the cancellation state, call the <a class="el" href="classasio_1_1basic__yield__context.html" title="A completion_token that represents the currently executing coroutine.">basic_yield_context</a> member function <code>reset_cancellation_state</code>. </dd></dl>

</div>
</div>
<a id="adceeed5aaac4506fb950c60a8465975e" name="adceeed5aaac4506fb950c60a8465975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adceeed5aaac4506fb950c60a8465975e">&#9670;&#160;</a></span>spawn() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename F , <a class="el" href="include_2asio_2async__result_8hpp.html#a23e288a45eb3f7eaf2b331aee6814fb8">ASIO_COMPLETION_TOKEN_FOR</a>(typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; typename ExecutionContext::executor_type &gt;)&gt; &gt;::type) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::spawn </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae20e77355502b24334a3e9a37b76156a">default_completion_token_t</a>&lt;&#160;typename&#160;ExecutionContext::executor_type&#160;&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) -&gt;  decltype( <a class="el" href="#ab2209de8d875481208ea96c76c1c49e4">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="#a517ab729aaffa516bb92bdffe2a49cb9">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; typename ExecutionContext::executor_type &gt;)&gt; &gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; typename ExecutionContext::executor_type &gt; &gt;(), <a class="el" href="#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine that executes on a given execution context. </p>
<p>This function is used to launch a new stackful coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Identifies the execution context that will run the stackful coroutine.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must be callable the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_class" href="classasio_1_1basic__yield__context.html">basic_yield_context&lt;Executor&gt;</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will handle the notification that the coroutine has completed. If the return type <code>R</code> of <code>function</code> is <code>void</code>, the function signature of the completion handler must be:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr); </div>
</div><!-- fragment --><p> Otherwise, the function signature of the completion handler must be: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr, R); </div>
</div><!-- fragment --><dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(std::exception_ptr, R) </div>
</div><!-- fragment --> where <code>R</code> is the return type of the function object.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>The new thread of execution is created with a cancellation state that supports <code><a class="el" href="#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> values only. To change the cancellation state, call the <a class="el" href="classasio_1_1basic__yield__context.html" title="A completion_token that represents the currently executing coroutine.">basic_yield_context</a> member function <code>reset_cancellation_state</code>. </dd></dl>

</div>
</div>
<a id="ac4859eacaf587bf46901d9597e139f6c" name="ac4859eacaf587bf46901d9597e139f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4859eacaf587bf46901d9597e139f6c">&#9670;&#160;</a></span>system_category()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> const <a class="el" href="#ae434d49ea968ad09c18f44d08c98aaa4">error_category</a> &amp; asio::system_category </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error category used for the system errors produced by asio. </p>

</div>
</div>
<a id="a4a82e92df79aa8401a8bc2117d4cf900" name="a4a82e92df79aa8401a8bc2117d4cf900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a82e92df79aa8401a8bc2117d4cf900">&#9670;&#160;</a></span>transfer_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__all__t.html">detail::transfer_all_t</a> asio::transfer_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until all of the data has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full: <div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> buf;</div>
<div class="line"><a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">    sock, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(buf),</div>
<div class="line">    <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n == 128</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassboost_1_1array_html"><div class="ttname"><a href="classboost_1_1array.html">boost::array</a></div><div class="ttdef"><b>Definition</b> array_fwd.hpp:23</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2b10af704afcd6c7ed7f0d3b740033ef" name="a2b10af704afcd6c7ed7f0d3b740033ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b10af704afcd6c7ed7f0d3b740033ef">&#9670;&#160;</a></span>transfer_at_least()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__at__least__t.html">detail::transfer_at_least_t</a> asio::transfer_at_least </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>minimum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full or contains at least 64 bytes: <div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> buf;</div>
<div class="line"><a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">    sock, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(buf),</div>
<div class="line">    <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(64), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n &gt;= 64 &amp;&amp; n &lt;= 128</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adb2ada9400d78a5df0e5f65dd2b9967e" name="adb2ada9400d78a5df0e5f65dd2b9967e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2ada9400d78a5df0e5f65dd2b9967e">&#9670;&#160;</a></span>transfer_exactly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__exactly__t.html">detail::transfer_exactly_t</a> asio::transfer_exactly </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full or contains exactly 64 bytes: <div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> buf;</div>
<div class="line"><a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#a6b4be0038c7c334d9f3a52d3b569275c">asio::read</a>(</div>
<div class="line">    sock, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(buf),</div>
<div class="line">    <a class="code hl_function" href="#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a>(64), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n == 64</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1810b2cc34a2ed373b761420a3d3a729" name="a1810b2cc34a2ed373b761420a3d3a729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1810b2cc34a2ed373b761420a3d3a729">&#9670;&#160;</a></span>use_service() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> will create a new instance of the service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a0d34f8c7897fc264ad87590429a7429a" name="a0d34f8c7897fc264ad87590429a7429a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d34f8c7897fc264ad87590429a7429a">&#9670;&#160;</a></span>use_service() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ioc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality.">io_context</a> will create a new instance of the service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ioc</td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality.">io_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is preserved for backwards compatibility with services that inherit from <a class="el" href="classasio_1_1io__context_1_1service.html" title="Base class for all io_context services.">io_context::service</a>. </dd></dl>

</div>
</div>
<a id="a764e1235aa162478633294d9b20ef3e3" name="a764e1235aa162478633294d9b20ef3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764e1235aa162478633294d9b20ef3e3">&#9670;&#160;</a></span>use_service&lt; detail::io_context_impl &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceasio_1_1detail.html#a31c14df804409e01448213346a224e80">detail::io_context_impl</a> &amp; <a class="el" href="#a1810b2cc34a2ed373b761420a3d3a729">asio::use_service</a>&lt; <a class="el" href="namespaceasio_1_1detail.html#a31c14df804409e01448213346a224e80">detail::io_context_impl</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ioc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85807d13da87adf48b62979f65f41152" name="a85807d13da87adf48b62979f65f41152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85807d13da87adf48b62979f65f41152">&#9670;&#160;</a></span>write() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a831273634fcb7d19b6c8a2f56c00d7f5"><div class="ttname"><a href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a></div><div class="ttdeci">std::size_t write(SyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec, constraint_t&lt; is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;, constraint_t&lt; is_completion_condition&lt; CompletionCondition &gt;::value &gt;)</div><div class="ttdoc">Write a certain amount of data to a stream before returning.</div><div class="ttdef"><b>Definition</b> write.hpp:61</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af72f7eddd7d4629ea2e2b7f5b7f355bc" name="af72f7eddd7d4629ea2e2b7f5b7f355bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72f7eddd7d4629ea2e2b7f5b7f355bc">&#9670;&#160;</a></span>write() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abf8f8a9367c07e485e1b626b863591a9" name="abf8f8a9367c07e485e1b626b863591a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8f8a9367c07e485e1b626b863591a9">&#9670;&#160;</a></span>write() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="ad4139d4d096173216b89c46333099038" name="ad4139d4d096173216b89c46333099038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4139d4d096173216b89c46333099038">&#9670;&#160;</a></span>write() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae86befc1c843c2b0a1dae51cb7696a23" name="ae86befc1c843c2b0a1dae51cb7696a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86befc1c843c2b0a1dae51cb7696a23">&#9670;&#160;</a></span>write() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a831273634fcb7d19b6c8a2f56c00d7f5" name="a831273634fcb7d19b6c8a2f56c00d7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831273634fcb7d19b6c8a2f56c00d7f5">&#9670;&#160;</a></span>write() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a04492a713027cad28491d62420af55e2" name="a04492a713027cad28491d62420af55e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04492a713027cad28491d62420af55e2">&#9670;&#160;</a></span>write() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a0c18920cf77046e1a78823245148256e" name="a0c18920cf77046e1a78823245148256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c18920cf77046e1a78823245148256e">&#9670;&#160;</a></span>write() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(<a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa6487c8fe492bf17fc7e08b61d960f17" name="aa6487c8fe492bf17fc7e08b61d960f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6487c8fe492bf17fc7e08b61d960f17">&#9670;&#160;</a></span>write() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a03a7528f07309a5531a6d9e6610eae75" name="a03a7528f07309a5531a6d9e6610eae75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a7528f07309a5531a6d9e6610eae75">&#9670;&#160;</a></span>write() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a041edf0d14932a201d095d8d17687a35" name="a041edf0d14932a201d095d8d17687a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041edf0d14932a201d095d8d17687a35">&#9670;&#160;</a></span>write() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43cd7d671f4ac42f5d2c702d92db29c" name="ad43cd7d671f4ac42f5d2c702d92db29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43cd7d671f4ac42f5d2c702d92db29c">&#9670;&#160;</a></span>write() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="#a961c7a660a10d1a9506ea4d6eb366023">decay_t</a>&lt; DynamicBuffer_v1 &gt; &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5eabfb4da832af9df0f85696c8022727" name="a5eabfb4da832af9df0f85696c8022727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eabfb4da832af9df0f85696c8022727">&#9670;&#160;</a></span>write() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae460d619d1642598e71e32b0dc382398" name="ae460d619d1642598e71e32b0dc382398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae460d619d1642598e71e32b0dc382398">&#9670;&#160;</a></span>write() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="aeae9a65aa623c0bfc52366134d665f92" name="aeae9a65aa623c0bfc52366134d665f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae9a65aa623c0bfc52366134d665f92">&#9670;&#160;</a></span>write() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af982fe40762c23e1eb4ea166b4019208" name="af982fe40762c23e1eb4ea166b4019208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af982fe40762c23e1eb4ea166b4019208">&#9670;&#160;</a></span>write() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a831273634fcb7d19b6c8a2f56c00d7f5">asio::write</a>(</div>
<div class="line">   <a class="code hl_struct" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1db1f75a907c17918092b41f2f242104" name="a1db1f75a907c17918092b41f2f242104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1f75a907c17918092b41f2f242104">&#9670;&#160;</a></span>write_at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a8d06a113e19b6fa1d67145d13afc4416">asio::write_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a8d06a113e19b6fa1d67145d13afc4416"><div class="ttname"><a href="#a8d06a113e19b6fa1d67145d13afc4416">asio::write_at</a></div><div class="ttdeci">std::size_t write_at(SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec, constraint_t&lt; is_completion_condition&lt; CompletionCondition &gt;::value &gt;)</div><div class="ttdoc">Write a certain amount of data at a specified offset before returning.</div><div class="ttdef"><b>Definition</b> write_at.hpp:65</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa6f42435acf937c35ee4c81af44ee6ce" name="aa6f42435acf937c35ee4c81af44ee6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f42435acf937c35ee4c81af44ee6ce">&#9670;&#160;</a></span>write_at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a8d06a113e19b6fa1d67145d13afc4416">asio::write_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a49dff7a50c833dbd9683952d4d179551" name="a49dff7a50c833dbd9683952d4d179551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dff7a50c833dbd9683952d4d179551">&#9670;&#160;</a></span>write_at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="ac29270019add1d462dea4f5a8f76db22" name="ac29270019add1d462dea4f5a8f76db22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29270019add1d462dea4f5a8f76db22">&#9670;&#160;</a></span>write_at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add67a05a29d183782491d14aceec7d41" name="add67a05a29d183782491d14aceec7d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add67a05a29d183782491d14aceec7d41">&#9670;&#160;</a></span>write_at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a8d06a113e19b6fa1d67145d13afc4416">asio::write_at</a>(d, 42, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a8d06a113e19b6fa1d67145d13afc4416">asio::write_at</a>(</div>
<div class="line">   d, offset, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8c1abcb5870505ea2a0c524a59638da0" name="a8c1abcb5870505ea2a0c524a59638da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1abcb5870505ea2a0c524a59638da0">&#9670;&#160;</a></span>write_at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a8d06a113e19b6fa1d67145d13afc4416">asio::write_at</a>(d, 42,</div>
<div class="line">   <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a8d06a113e19b6fa1d67145d13afc4416">asio::write_at</a>(</div>
<div class="line">   d, offset, buffers,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8d06a113e19b6fa1d67145d13afc4416" name="a8d06a113e19b6fa1d67145d13afc4416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d06a113e19b6fa1d67145d13afc4416">&#9670;&#160;</a></span>write_at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a24be5a5c262ce6245d836011e0421752" name="a24be5a5c262ce6245d836011e0421752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24be5a5c262ce6245d836011e0421752">&#9670;&#160;</a></span>write_at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1691b4f2369ad1304498c7244449fd47">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__completion__condition.html">is_completion_condition</a>&lt; CompletionCondition &gt;::value &gt;</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a8d06a113e19b6fa1d67145d13afc4416">asio::write_at</a>(d, 42, <a class="code hl_function" href="#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa80c4033469ae5aaa092c0d49852403c" name="aa80c4033469ae5aaa092c0d49852403c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80c4033469ae5aaa092c0d49852403c">&#9670;&#160;</a></span>a</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">awaitable&lt; void, AwaitableExecutor &gt; asio::a</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ff4c1c8e98b8cefd3d532bd417989f3" name="a0ff4c1c8e98b8cefd3d532bd417989f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff4c1c8e98b8cefd3d532bd417989f3">&#9670;&#160;</a></span>as_tuple</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="structasio_1_1partial__as__tuple.html">partial_as_tuple</a> asio::as_tuple</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function object that adapts a completion_token to specify that the completion handler arguments should be combined into a single tuple argument. May also be used directly as a completion token, in which case it adapts the asynchronous operation's default completion token (or <a class="el" href="#a359cf8fa7c4df1b720eaea875a50f069">asio::deferred</a> if no default is available). </p>

</div>
</div>
<a id="a359cf8fa7c4df1b720eaea875a50f069" name="a359cf8fa7c4df1b720eaea875a50f069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359cf8fa7c4df1b720eaea875a50f069">&#9670;&#160;</a></span>deferred</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="classasio_1_1deferred__t.html">deferred_t</a> asio::deferred</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A completion_token object used to specify that an asynchronous operation should return a function object to lazily launch the operation. See the documentation for <a class="el" href="classasio_1_1deferred__t.html">asio::deferred_t</a> for a usage example. </p>

</div>
</div>
<a id="aaea4315d6a817e4253248982b5f8b2c3" name="aaea4315d6a817e4253248982b5f8b2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea4315d6a817e4253248982b5f8b2c3">&#9670;&#160;</a></span>detached</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="classasio_1_1detached__t.html">detached_t</a> asio::detached</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A completion_token object used to specify that an asynchronous operation is detached. See the documentation for <a class="el" href="classasio_1_1detached__t.html">asio::detached_t</a> for a usage example. </p>

</div>
</div>
<a id="afa9b2d20d2003d88a06a522445f0bd37" name="afa9b2d20d2003d88a06a522445f0bd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9b2d20d2003d88a06a522445f0bd37">&#9670;&#160;</a></span>executor_arg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a236fc685e1d9c5f370c36fbf9144c972">ASIO_INLINE_VARIABLE</a> constexpr <a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a> asio::executor_arg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A special value, similar to std::nothrow, used to disambiguate constructors that accept executor arguments. See <a class="el" href="structasio_1_1executor__arg__t.html">asio::executor_arg_t</a> and <a class="el" href="structasio_1_1uses__executor.html">asio::uses_executor</a> for more information. </p>

</div>
</div>
<a id="ac172b717c13db01d7f99af7e42edcb68" name="ac172b717c13db01d7f99af7e42edcb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac172b717c13db01d7f99af7e42edcb68">&#9670;&#160;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F &amp;&amp; asio::f</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adff1e9f7bb336026f18afa2221c9df07" name="adff1e9f7bb336026f18afa2221c9df07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff1e9f7bb336026f18afa2221c9df07">&#9670;&#160;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F CompletionToken &amp;&amp; asio::token</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
